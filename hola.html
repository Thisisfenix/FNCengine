<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pepe's Quest: El Guardián de Aethermoor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
        }

        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }

        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }

        #objective {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #4CAF50;
        }

        #health-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }

        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #00ff00);
            transition: width 0.3s;
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #4CAF50;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div>Salud: <span id="health">100</span>/100</div>
        <div>Puntos: <span id="score">0</span></div>
        <div>Enemigos derrotados: <span id="kills">0</span></div>
        <div>Cristales: <span id="crystals">0</span>/4</div>
    </div>

    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Objetos: <span id="objects">0</span></div>
    </div>

    <div id="objective">
        <h3>MISIÓN ACTUAL</h3>
        <p id="mission-text">Explora Aethermoor y encuentra los 4 cristales de poder para derrotar al Señor Oscuro</p>
    </div>

    <div id="health-bar">
        <div id="health-fill"></div>
    </div>

    <div id="controls">
        WASD: Mover | Espacio: Saltar | Click: Atacar | R: Correr | P: Poción | Q: Hablar | I: Inventario | M: Minimapa
        | C: Cámara | F5: Guardar Rápido | F6: Menú Guardar | F9: Cargar | ESC: Pausa
    </div>

    <div id="notification"></div>

    <!-- Menú Principal -->
    <div id="main-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h1 style="font-size: 3em; margin-bottom: 30px; text-shadow: 2px 2px 4px #000;">PEPE'S QUEST</h1>
        <h2 style="margin-bottom: 50px; color: #4CAF50;">El Guardián de Aethermoor</h2>
        <button id="start-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nueva
            Aventura</button>
        <button id="load-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #9C27B0; color: white; border: none; border-radius: 5px; cursor: pointer;">Cargar
            Partida</button>
        <button id="settings-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuración</button>
        <button id="tutorial-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #FF5722; color: white; border: none; border-radius: 5px; cursor: pointer;">Tutorial</button>
    </div>

    <!-- Menú de Pausa -->
    <div id="pause-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h2 style="margin-bottom: 30px;">JUEGO PAUSADO</h2>
        <button id="resume-game"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Continuar</button>
        <button id="pause-settings"
            style="padding: 10px 20px; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuración</button>
        <button id="main-menu-btn"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Menú
            Principal</button>
    </div>

    <!-- Configuración -->
    <div id="settings-menu"
        style="position: fixed; top: 50px; left: 50px; width: 450px; max-height: 80vh; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1001; display: none; overflow-y: auto;">
        <h3>Configuración</h3>
        <div style="margin: 10px 0;">Calidad de Sombras: <select id="shadow-quality">
                <option value="off">Desactivadas</option>
                <option value="low">Bajas</option>
                <option value="high">Altas</option>
            </select></div>
        <div style="margin: 10px 0;">Modo de Cámara: <select id="camera-mode">
                <option value="third">3ª Persona</option>
                <option value="first">1ª Persona</option>
                <option value="free">Libre</option>
            </select></div>
        <div style="margin: 10px 0;">Mostrar Minimapa: <input type="checkbox" id="show-minimap" checked></div>
        <div style="margin: 10px 0;">Mostrar Brújula: <input type="checkbox" id="show-compass" checked></div>
        <div style="margin: 10px 0;">Ciclo Día/Noche: <input type="checkbox" id="day-night-cycle"></div>
        <div style="margin: 10px 0;">Pantalla Completa: <button id="fullscreen-btn"
                style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Activar</button>
        </div>
        <div style="margin: 10px 0;">Dificultad: <select id="difficulty-select">
                <option value="easy">Fácil</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Difícil</option>
            </select></div>
        <div style="margin: 10px 0;">Volumen: <input type="range" id="volume-slider" min="0" max="100" value="50"
                style="width: 100px;"> <span id="volume-display">50%</span></div>
        <div style="margin: 10px 0;">Auto-Guardar: <input type="checkbox" id="auto-save" checked></div>

        <!-- Controles Personalizables -->
        <div style="margin: 15px 0; border-top: 1px solid #555; padding-top: 15px;">
            <h4>Controles</h4>
            <div id="key-bindings" style="font-size: 12px;">
                <div style="margin: 5px 0;">Mover Adelante: <input type="text" id="key-forward" value="W" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Mover Atrás: <input type="text" id="key-backward" value="S" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Mover Izquierda: <input type="text" id="key-left" value="A" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Mover Derecha: <input type="text" id="key-right" value="D" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Correr: <input type="text" id="key-run" value="R" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Usar Poción: <input type="text" id="key-potion" value="P" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Inventario: <input type="text" id="key-inventory" value="I" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
                <div style="margin: 5px 0;">Hablar: <input type="text" id="key-interact" value="Q" maxlength="1"
                        style="width: 30px; text-align: center;"></div>
            </div>
        </div>

        <!-- Controles Táctiles (solo Android) -->
        <div id="mobile-settings" style="margin: 15px 0; border-top: 1px solid #555; padding-top: 15px; display: none;">
            <h4>Controles Táctiles</h4>
            <div style="margin: 10px 0;">Tamaño Joystick: <input type="range" id="joystick-size" min="80" max="140"
                    value="100" style="width: 100px;"> <span id="joystick-size-display">100px</span></div>
            <div style="margin: 10px 0;">Tamaño Botones: <input type="range" id="button-size" min="40" max="80"
                    value="60" style="width: 100px;"> <span id="button-size-display">60px</span></div>
            <div style="margin: 10px 0;">Opacidad: <input type="range" id="controls-opacity" min="30" max="100"
                    value="80" style="width: 100px;"> <span id="opacity-display">80%</span></div>
            <div style="margin: 10px 0;">Vibración: <input type="checkbox" id="haptic-feedback" checked></div>
        </div>

        <div style="margin: 15px 0; border-top: 1px solid #555; padding-top: 15px;">
            <button id="controls-btn"
                style="padding: 8px 15px; margin: 5px; background: #FF9800; color: white; border: none; border-radius: 3px; cursor: pointer;">Ver
                Controles</button>
            <button id="tutorial-btn-settings"
                style="padding: 8px 15px; margin: 5px; background: #FF5722; color: white; border: none; border-radius: 3px; cursor: pointer;">Tutorial</button>
        </div>
        <button id="close-settings"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Minimapa -->
    <div id="minimap"
        style="position: fixed; top: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 10px; z-index: 100;">
    </div>

    <!-- Brújula -->
    <div id="compass"
        style="position: fixed; top: 180px; right: 20px; width: 80px; height: 80px; background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 50%; z-index: 100; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">
        N</div>

    <!-- Inventario -->
    <div id="inventory"
        style="position: fixed; bottom: 100px; left: 20px; width: 350px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Inventario</h4>
        <div id="inventory-items"></div>
        <div id="player-stats" style="margin-top: 10px; font-size: 12px; color: #ccc;"></div>
    </div>

    <!-- Logros -->
    <div id="achievements"
        style="position: fixed; top: 50%; right: 20px; width: 250px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Logros Desbloqueados</h4>
        <div id="achievement-list"></div>
    </div>

    <!-- Clima -->
    <div id="weather-info"
        style="position: fixed; top: 200px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; z-index: 100; font-size: 12px;">
    </div>

    <!-- Tienda -->
    <div id="shop"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1002; display: none;">
        <h3>Tienda del Mercader</h3>
        <div id="shop-items"></div>
        <button id="close-shop"
            style="padding: 10px 20px; margin-top: 20px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Misiones -->
    <div id="quest-panel"
        style="position: fixed; top: 20px; left: 200px; width: 300px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Misiones Activas</h4>
        <div id="quest-list"></div>
    </div>

    <!-- Guardado -->
    <div id="save-menu"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1003; display: none;">
        <h3>Guardar/Cargar Partida</h3>
        <div id="save-slots"></div>
        <button id="close-save"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Tutorial -->
    <div id="tutorial"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1005; display: none; text-align: center;">
        <h2>Tutorial - Pepe's Quest</h2>
        <div id="tutorial-content"></div>
        <button id="tutorial-next"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Siguiente</button>
        <button id="tutorial-skip"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Saltar</button>
    </div>

    <!-- Panel de Controles -->
    <div id="controls-panel"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; max-height: 80vh; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1006; display: none; overflow-y: auto;">
        <h2>Controles del Juego</h2>
        <div id="controls-content"></div>
        <button id="controls-close"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Controles Móviles Mejorados -->
    <div id="mobile-controls" style="position: fixed; bottom: 20px; left: 20px; z-index: 100; display: none;">
        <div id="joystick"
            style="width: 100px; height: 100px; background: rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; position: relative; box-shadow: 0 0 10px rgba(0,0,0,0.3);">
            <div id="joystick-knob"
                style="width: 40px; height: 40px; background: rgba(255,255,255,0.9); border-radius: 50%; position: absolute; top: 30px; left: 30px; transition: all 0.1s; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
            </div>
        </div>
        <button id="mobile-attack"
            style="position: absolute; left: 120px; bottom: 0; width: 60px; height: 60px; background: #f44336; color: white; border: none; border-radius: 50%; font-size: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;">⚔</button>
        <button id="mobile-jump"
            style="position: absolute; left: 120px; bottom: 70px; width: 60px; height: 60px; background: #4CAF50; color: white; border: none; border-radius: 50%; font-size: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;">↑</button>
        <button id="mobile-potion"
            style="position: absolute; left: 190px; bottom: 0; width: 50px; height: 50px; background: #9C27B0; color: white; border: none; border-radius: 50%; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;">🧪</button>
        <button id="mobile-inventory"
            style="position: absolute; left: 190px; bottom: 60px; width: 50px; height: 50px; background: #FF9800; color: white; border: none; border-radius: 50%; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;">🎒</button>
        <button id="mobile-camera"
            style="position: absolute; left: 190px; bottom: 120px; width: 50px; height: 50px; background: #2196F3; color: white; border: none; border-radius: 50%; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;">📷</button>
    </div>

    <!-- Indicador de cámara táctil -->
    <div id="camera-hint"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 200; display: none; text-align: center;">
        📱 Desliza la pantalla para rotar la cámara
    </div>

    <!-- Botón de pausa para móvil -->
    <div id="mobile-pause" style="position: fixed; top: 20px; right: 20px; z-index: 101; display: none;">
        <button onclick="togglePause()"
            style="width: 50px; height: 50px; background: rgba(0,0,0,0.7); color: white; border: 2px solid white; border-radius: 50%; font-size: 16px; cursor: pointer;">⏸</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales
        let scene, camera, renderer, clock;
        let player, enemies = [], items = [], crystals = [], villagers = [], bosses = [];
        let keys = {}, gameActive = false, gamePaused = false, gameStarted = false;
        let playerHealth = 100, score = 0, kills = 0, crystalsFound = 0, playerLevel = 1, playerXP = 0;
        let stats = { fps: 0, lastTime: 0, frames: 0 };
        let cameraMode = 'third', dayTime = 0.5, isMobile = false;
        let inventory = { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
        let currentQuest = { name: 'Encuentra los Cristales', progress: 0, total: 4 };
        let settings = { shadows: 'low', minimap: true, compass: true, dayNight: false, audio: true, volume: 0.5, autoSave: true, difficulty: 'normal' };
        let keyBindings = { forward: 'KeyW', backward: 'KeyS', left: 'KeyA', right: 'KeyD', run: 'KeyR', potion: 'KeyP', inventory: 'KeyI', interact: 'KeyQ' };
        let mobileSettings = { joystickSize: 100, buttonSize: 60, opacity: 80, hapticFeedback: true };
        let weather = { type: 'clear', intensity: 0, particles: [] };
        let achievements = [];
        let gameTime = 0;
        let playerStats = { totalDistance: 0, totalJumps: 0, totalAttacks: 0 };
        let merchants = [], quests = [], particles = [];
        let audioContext, sounds = {};
        let saveSlots = [null, null, null];
        let currentSaveSlot = 0;

        // Configuración
        const config = {
            playerSpeed: 8,
            jumpForce: 12,
            gravity: -30,
            attackRange: 4,
            worldSize: 300
        };

        // Detectar dispositivo móvil
        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            // Detectar tipos específicos de móvil
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const isWindowsPhone = /IEMobile/i.test(navigator.userAgent);

            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                setupMobileControls();
                optimizeForMobile();

                // Configuraciones específicas por plataforma
                if (isAndroid) {
                    setupAndroidSpecific();
                } else if (isIOS) {
                    setupIOSSpecific();
                } else if (isWindowsPhone) {
                    setupWindowsPhoneSpecific();
                } else {
                    setupGenericMobileSpecific();
                }
            }
        }

        // Configuración específica para Android
        function setupAndroidSpecific() {
            // Prevenir el menú contextual en Android
            document.addEventListener('contextmenu', e => e.preventDefault());

            // Optimizar para diferentes versiones de Android
            const androidVersion = parseFloat(navigator.userAgent.match(/Android (\d+\.\d+)/)?.[1] || '0');

            if (androidVersion < 7.0) {
                // Android más antiguo - más optimizaciones
                config.playerSpeed = 6;
                settings.shadows = 'off';
                config.worldSize = 150; // Mundo más pequeño
            }

            // Configurar wake lock para mantener pantalla activa
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => { });
            }

            // Configurar fullscreen automático en Android
            setTimeout(() => {
                if (gameActive && isMobile) {
                    enterFullscreen();
                }
            }, 2000);

            // Botón flotante de configuración rápida para Android
            addAndroidQuickSettings();
            
            // Gestos de Android
            setupAndroidGestures();
            
            // Notificaciones nativas de Android
            setupAndroidNotifications();
        }

        // Configurar controles personalizables
        function setupKeyBindings() {
            const keyInputs = ['forward', 'backward', 'left', 'right', 'run', 'potion', 'inventory', 'interact'];
            keyInputs.forEach(action => {
                const input = document.getElementById(`key-${action}`);
                if (input) {
                    input.addEventListener('input', (e) => {
                        const key = e.target.value.toUpperCase();
                        if (key) {
                            keyBindings[action] = 'Key' + key;
                            localStorage.setItem('pepequest_keybindings', JSON.stringify(keyBindings));
                        }
                    });
                }
            });

            // Cargar configuración guardada
            const saved = localStorage.getItem('pepequest_keybindings');
            if (saved) {
                keyBindings = JSON.parse(saved);
                Object.keys(keyBindings).forEach(action => {
                    const input = document.getElementById(`key-${action}`);
                    if (input) input.value = keyBindings[action].replace('Key', '');
                });
            }
        }

        // Configurar ajustes móviles
        function setupMobileSettings() {
            if (!isMobile) return;

            document.getElementById('mobile-settings').style.display = 'block';

            const joystickSizeSlider = document.getElementById('joystick-size');
            const buttonSizeSlider = document.getElementById('button-size');
            const opacitySlider = document.getElementById('controls-opacity');
            const hapticCheck = document.getElementById('haptic-feedback');

            if (joystickSizeSlider) {
                joystickSizeSlider.addEventListener('input', (e) => {
                    mobileSettings.joystickSize = e.target.value;
                    document.getElementById('joystick-size-display').textContent = e.target.value + 'px';
                    updateMobileControls();
                });
            }

            if (buttonSizeSlider) {
                buttonSizeSlider.addEventListener('input', (e) => {
                    mobileSettings.buttonSize = e.target.value;
                    document.getElementById('button-size-display').textContent = e.target.value + 'px';
                    updateMobileControls();
                });
            }

            if (opacitySlider) {
                opacitySlider.addEventListener('input', (e) => {
                    mobileSettings.opacity = e.target.value;
                    document.getElementById('opacity-display').textContent = e.target.value + '%';
                    updateMobileControls();
                });
            }

            if (hapticCheck) {
                hapticCheck.addEventListener('change', (e) => {
                    mobileSettings.hapticFeedback = e.target.checked;
                });
            }

            // Cargar configuración guardada
            const saved = localStorage.getItem('pepequest_mobilesettings');
            if (saved) {
                mobileSettings = JSON.parse(saved);
                if (joystickSizeSlider) joystickSizeSlider.value = mobileSettings.joystickSize;
                if (buttonSizeSlider) buttonSizeSlider.value = mobileSettings.buttonSize;
                if (opacitySlider) opacitySlider.value = mobileSettings.opacity;
                if (hapticCheck) hapticCheck.checked = mobileSettings.hapticFeedback;
                updateMobileControls();
            }
        }

        // Actualizar controles móviles
        function updateMobileControls() {
            const joystick = document.getElementById('joystick');
            const buttons = document.querySelectorAll('#mobile-controls button');

            if (joystick) {
                joystick.style.width = mobileSettings.joystickSize + 'px';
                joystick.style.height = mobileSettings.joystickSize + 'px';
                joystick.style.opacity = mobileSettings.opacity / 100;
            }

            buttons.forEach(button => {
                if (button.id !== 'mobile-pause') {
                    button.style.width = mobileSettings.buttonSize + 'px';
                    button.style.height = mobileSettings.buttonSize + 'px';
                    button.style.opacity = mobileSettings.opacity / 100;
                }
            });

            localStorage.setItem('pepequest_mobilesettings', JSON.stringify(mobileSettings));
        }

        // Optimizar para móviles
        function optimizeForMobile() {
            // Reducir calidad automáticamente en móviles
            settings.shadows = 'off';
            updateGraphics();

            // Ajustar controles para pantalla táctil
            document.body.style.touchAction = 'none';
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
            document.body.style.webkitTouchCallout = 'none';

            // Prevenir zoom en iOS y Android
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            document.addEventListener('touchmove', e => {
                if (e.scale !== 1) e.preventDefault();
            }, { passive: false });

            // Orientación de pantalla preferida horizontal
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => { });
            }

            // Mostrar botón de pausa móvil
            document.getElementById('mobile-pause').style.display = 'block';

            // Ajustar UI para móvil
            adjustMobileUI();

            // Optimizar rendimiento para Android
            optimizeAndroidPerformance();

            // Mostrar hint de cámara táctil
            setTimeout(() => {
                if (gameActive) {
                    document.getElementById('camera-hint').style.display = 'block';
                    setTimeout(() => {
                        document.getElementById('camera-hint').style.display = 'none';
                    }, 4000);
                }
            }, 3000);
        }

        // Ajustar UI para móvil
        function adjustMobileUI() {
            // Hacer elementos de UI más grandes
            const ui = document.getElementById('ui');
            if (ui) {
                ui.style.fontSize = '14px';
                ui.style.padding = '15px';
            }

            const stats = document.getElementById('stats');
            if (stats) {
                stats.style.fontSize = '12px';
                stats.style.padding = '10px';
            }

            const objective = document.getElementById('objective');
            if (objective) {
                objective.style.fontSize = '14px';
                objective.style.padding = '20px';
                objective.style.bottom = '100px'; // Mover arriba para no tapar controles
            }

            const controls = document.getElementById('controls');
            if (controls) {
                controls.style.display = 'none'; // Ocultar en móvil
            }
        }

        // Optimizar rendimiento para Android
        function optimizeAndroidPerformance() {
            // Reducir FPS objetivo en Android
            const targetFPS = 30;
            
            // Reducir complejidad de objetos
            config.worldSize = 200;

            // Limitar número de enemigos según rendimiento
            const maxEnemies = navigator.hardwareConcurrency > 4 ? 20 : 12;

            // Desactivar efectos costosos
            scene.fog.density = 0.01;

            // Usar geometrías más simples
            if (renderer) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                // Modo de bajo consumo
                renderer.powerPreference = 'low-power';
            }
            
            // Limpieza automática de memoria más frecuente
            setInterval(() => {
                if (enemies.length > maxEnemies) {
                    // Eliminar enemigos más lejanos
                    enemies.sort((a, b) => 
                        player.position.distanceTo(b.position) - player.position.distanceTo(a.position)
                    );
                    const toRemove = enemies.splice(maxEnemies);
                    toRemove.forEach(enemy => scene.remove(enemy));
                }
            }, 10000);
        }

        // Configurar menús
        function setupMenus() {
            const startBtn = document.getElementById('start-game');
            const settingsBtn = document.getElementById('settings-btn');
            const controlsBtn = document.getElementById('controls-btn');
            const tutorialBtn = document.getElementById('tutorial-btn');
            const tutorialBtnSettings = document.getElementById('tutorial-btn-settings');
            const closeSettingsBtn = document.getElementById('close-settings');
            const resumeBtn = document.getElementById('resume-game');
            const pauseSettingsBtn = document.getElementById('pause-settings');
            const mainMenuBtn = document.getElementById('main-menu-btn');

            if (startBtn) startBtn.addEventListener('click', startGame);
            if (settingsBtn) settingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (controlsBtn) controlsBtn.addEventListener('click', showControls);
            if (tutorialBtn) tutorialBtn.addEventListener('click', showTutorial);
            if (tutorialBtnSettings) tutorialBtnSettings.addEventListener('click', showTutorial);
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'none';
            });
            if (resumeBtn) resumeBtn.addEventListener('click', resumeGame);
            if (pauseSettingsBtn) pauseSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (mainMenuBtn) mainMenuBtn.addEventListener('click', () => {
                gameActive = false;
                gamePaused = false;
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
            });

            // Botones de guardado/carga
            const loadBtn = document.getElementById('load-game');
            if (loadBtn) loadBtn.addEventListener('click', showSaveMenu);

            // Configuración
            const shadowQuality = document.getElementById('shadow-quality');
            const cameraSelect = document.getElementById('camera-mode');
            const minimapCheck = document.getElementById('show-minimap');
            const compassCheck = document.getElementById('show-compass');
            const dayNightCheck = document.getElementById('day-night-cycle');

            if (shadowQuality) shadowQuality.addEventListener('change', (e) => {
                settings.shadows = e.target.value;
                updateGraphics();
            });
            if (cameraSelect) cameraSelect.addEventListener('change', (e) => {
                cameraMode = e.target.value;
            });
            if (minimapCheck) minimapCheck.addEventListener('change', (e) => {
                settings.minimap = e.target.checked;
                document.getElementById('minimap').style.display = e.target.checked ? 'block' : 'none';
            });
            if (compassCheck) compassCheck.addEventListener('change', (e) => {
                settings.compass = e.target.checked;
                document.getElementById('compass').style.display = e.target.checked ? 'block' : 'none';
            });
            if (dayNightCheck) dayNightCheck.addEventListener('change', (e) => {
                settings.dayNight = e.target.checked;
            });

            // Fullscreen
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Detectar cambios de fullscreen
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.addEventListener('mozfullscreenchange', updateFullscreenButton);
            document.addEventListener('MSFullscreenChange', updateFullscreenButton);

            // Configuraciones adicionales
            const difficultySelect = document.getElementById('difficulty-select');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeDisplay = document.getElementById('volume-display');
            const autoSaveCheck = document.getElementById('auto-save');

            if (difficultySelect) difficultySelect.addEventListener('change', (e) => {
                changeDifficulty(e.target.value);
            });
            if (volumeSlider) volumeSlider.addEventListener('input', (e) => {
                settings.volume = e.target.value / 100;
                volumeDisplay.textContent = e.target.value + '%';
            });
            if (autoSaveCheck) autoSaveCheck.addEventListener('change', (e) => {
                settings.autoSave = e.target.checked;
            });

            // Configurar controles personalizables
            setupKeyBindings();
            setupMobileSettings();
        }

        function showControls() {
            const content = document.getElementById('controls-content');

            if (isMobile) {
                content.innerHTML = `
                    <div style="text-align: left; line-height: 1.6;">
                        <h3 style="color: #4CAF50; text-align: center;">Controles Móviles</h3>
                        <div style="margin: 15px 0;">
                            <div style="margin: 8px 0;"><strong>Joystick:</strong> Mover (borde para correr)</div>
                            <div style="margin: 8px 0;"><strong>⚔️ Botón Rojo:</strong> Atacar</div>
                            <div style="margin: 8px 0;"><strong>↑ Botón Verde:</strong> Saltar</div>
                            <div style="margin: 8px 0;"><strong>🧪 Botón Morado:</strong> Usar Poción</div>
                            <div style="margin: 8px 0;"><strong>🎒 Botón Naranja:</strong> Inventario</div>
                            <div style="margin: 8px 0;"><strong>📷 Botón Azul:</strong> Cambiar Cámara</div>
                            <div style="margin: 8px 0;"><strong>💾 Botón Morado:</strong> Guardar Partida</div>
                            <div style="margin: 8px 0;"><strong>Doble Toque:</strong> Hablar con NPCs</div>
                            <div style="margin: 8px 0;"><strong>⏸ Botón Pausa:</strong> Pausar Juego</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>Tip:</strong> Puedes personalizar el tamaño y opacidad de los controles en Configuración.
                        </div>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <div style="text-align: left; line-height: 1.6;">
                        <h3 style="color: #4CAF50; text-align: center;">Controles PC</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                            <div>
                                <h4 style="color: #FF9800;">Movimiento</h4>
                                <div style="margin: 5px 0;"><strong>${keyBindings.forward.replace('Key', '')}:</strong> Mover Adelante</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.backward.replace('Key', '')}:</strong> Mover Atrás</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.left.replace('Key', '')}:</strong> Mover Izquierda</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.right.replace('Key', '')}:</strong> Mover Derecha</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.run.replace('Key', '')}:</strong> Correr</div>
                                <div style="margin: 5px 0;"><strong>Espacio:</strong> Saltar</div>
                            </div>
                            <div>
                                <h4 style="color: #FF9800;">Acciones</h4>
                                <div style="margin: 5px 0;"><strong>Click Izq:</strong> Atacar</div>
                                <div style="margin: 5px 0;"><strong>Click Der:</strong> Bloquear</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.potion.replace('Key', '')}:</strong> Usar Poción</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.interact.replace('Key', '')}:</strong> Hablar con NPCs</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.inventory.replace('Key', '')}:</strong> Inventario</div>
                                <div style="margin: 5px 0;"><strong>M:</strong> Minimapa</div>
                            </div>
                        </div>
                        <div style="margin: 15px 0;">
                            <h4 style="color: #FF9800;">Sistema</h4>
                            <div style="margin: 5px 0;"><strong>C:</strong> Cambiar Cámara</div>
                            <div style="margin: 5px 0;"><strong>F5:</strong> Guardar Rápido</div>
                            <div style="margin: 5px 0;"><strong>F6:</strong> Menú Guardar/Cargar</div>
                            <div style="margin: 5px 0;"><strong>F9:</strong> Cargar Última Partida</div>
                            <div style="margin: 5px 0;"><strong>ESC:</strong> Pausar Juego</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>Tip:</strong> Puedes personalizar las teclas en Configuración → Controles.
                        </div>
                    </div>
                `;
            }

            document.getElementById('controls-panel').style.display = 'block';
        }

        // Cerrar panel de controles
        document.getElementById('controls-close').addEventListener('click', () => {
            document.getElementById('controls-panel').style.display = 'none';
        });

        function showTutorial() {
            const tutorialSteps = [
                "Bienvenido a Pepe's Quest! Eres el último guardián de Aethermoor.",
                "Tu misión: Encontrar los 4 cristales principales y derrotar a todos los jefes.",
                "Explora los reinos elementales: Fuego, Agua, Aire y Tierra.",
                "Recoge monedas, pociones y mejoras de armas por el camino.",
                "Habla con aldeanos para obtener pistas sobre los cristales.",
                "Abre cofres para conseguir tesoros y mejoras.",
                "Derrota enemigos para ganar experiencia y subir de nivel.",
                "Usa pociones cuando tu salud esté baja.",
                "¡Buena suerte, héroe! Aethermoor cuenta contigo."
            ];

            let currentStep = 0;

            function showTutorialStep() {
                if (currentStep < tutorialSteps.length) {
                    const content = document.getElementById('tutorial-content');
                    content.innerHTML = `
                        <div style="margin: 20px 0; font-size: 16px;">
                            <div style="color: #4CAF50; margin-bottom: 10px;">Paso ${currentStep + 1} de ${tutorialSteps.length}</div>
                            <div>${tutorialSteps[currentStep]}</div>
                        </div>
                    `;

                    const nextBtn = document.getElementById('tutorial-next');
                    const skipBtn = document.getElementById('tutorial-skip');

                    nextBtn.textContent = currentStep === tutorialSteps.length - 1 ? 'Finalizar' : 'Siguiente';

                    nextBtn.onclick = () => {
                        currentStep++;
                        if (currentStep >= tutorialSteps.length) {
                            closeTutorial();
                        } else {
                            showTutorialStep();
                        }
                    };

                    skipBtn.onclick = closeTutorial;
                }
            }

            function closeTutorial() {
                document.getElementById('tutorial').style.display = 'none';
                currentStep = 0;
            }

            document.getElementById('tutorial').style.display = 'block';
            showTutorialStep();
        }

        // Iniciar juego
        function startGame() {
            showSlotSelection();
        }

        // Seleccionar slot para nueva aventura
        function showSlotSelection() {
            const container = document.getElementById('save-slots');
            container.innerHTML = '<h4>Selecciona un Slot para Nueva Aventura:</h4>';

            for (let i = 0; i < 3; i++) {
                const saved = localStorage.getItem(`pepequest_slot_${i}`);
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 5px; cursor: pointer; border: 2px solid transparent;';
                slotDiv.onmouseover = () => slotDiv.style.borderColor = '#4CAF50';
                slotDiv.onmouseout = () => slotDiv.style.borderColor = 'transparent';

                if (saved) {
                    const data = JSON.parse(saved);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Nivel ${data.playerLevel || 1}</div>
                        <div style="font-size: 12px; color: #ccc; margin: 5px 0;">${date}</div>
                        <div style="color: #ff9800; font-size: 12px;">⚠️ Se sobrescribirá la partida existente</div>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Vacío</div>
                        <div style="color: #4CAF50; font-size: 12px;">✓ Listo para nueva aventura</div>
                    `;
                }

                slotDiv.onclick = () => startNewGame(i);
                container.appendChild(slotDiv);
            }

            document.getElementById('save-menu').style.display = 'block';
        }

        // Iniciar nueva aventura en slot seleccionado
        function startNewGame(slot) {
            currentSaveSlot = slot;
            document.getElementById('save-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'none';

            if (!gameStarted) {
                init();
                gameStarted = true;
            } else {
                // Reiniciar variables para nueva partida
                playerHealth = 100; score = 0; kills = 0; crystalsFound = 0;
                playerLevel = 1; playerXP = 0; gameTime = 0;
                inventory = { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
                achievements = []; playerStats = { totalDistance: 0, totalJumps: 0, totalAttacks: 0 };
                if (player) player.position.set(0, 0, 0);
            }

            gameActive = true;
            gamePaused = false;
            updateUI();
            updateInventoryUI();
            showNotification(`Nueva aventura iniciada en Slot ${slot + 1}`, 3000);
        }

        // Pausar/Reanudar juego
        function togglePause() {
            if (!gameActive) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-menu').style.display = gamePaused ? 'flex' : 'none';
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-menu').style.display = 'none';
        }

        // Inicializar juego
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // Crear cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Crear renderizador
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.body.appendChild(renderer.domElement);

            // Crear luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Crear mundo
            createWorld();
            createPlayer();
            spawnEnemies();
            spawnVillagers();
            spawnItems();
            spawnCrystals();
            spawnBosses();
            spawnTreasureChests();
            initWeatherSystem();
            initAchievements();

            // Configurar eventos
            setupControls();
            setupMenus();
            detectMobile();

            // Iniciar reloj
            clock = new THREE.Clock();
            stats.lastTime = performance.now();

            // Configurar rendimiento automático
            setupPerformanceOptimization();

            // Mostrar lore inicial
            showNotification("¡Bienvenido a Aethermoor, Pepe!\n\nLos 4 reinos han caído en la oscuridad.\nEncuentra los cristales de poder para restaurar la paz.", 5000);

            // Actualizar UI inicial
            updateUI();
            updateInventoryUI();

            // Iniciar bucle de juego
            animate();
        }

        // Crear mundo
        function createWorld() {
            // Terreno base
            const groundGeometry = new THREE.PlaneGeometry(config.worldSize, config.worldSize);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Reino Central (spawn)
            createKingdom(0, 0, 0x4CAF50, "Reino Central");

            // Reinos elementales
            createKingdom(-80, -80, 0xff4444, "Reino del Fuego");
            createKingdom(80, -80, 0x4444ff, "Reino del Agua");
            createKingdom(80, 80, 0xffff44, "Reino del Aire");
            createKingdom(-80, 80, 0x8B4513, "Reino de la Tierra");

            // Mazmorras
            createDungeon(0, -120, 0x444444);
            createDungeon(120, 0, 0x444444);
            createDungeon(0, 120, 0x444444);
            createDungeon(-120, 0, 0x444444);
        }

        // Crear reino
        function createKingdom(x, z, color, name) {
            const kingdom = new THREE.Group();

            // Castillo principal
            const castleGeometry = new THREE.BoxGeometry(10, 15, 10);
            const castleMaterial = new THREE.MeshLambertMaterial({ color });
            const castle = new THREE.Mesh(castleGeometry, castleMaterial);
            castle.position.y = 7.5;
            castle.castShadow = true;
            kingdom.add(castle);

            // Torres
            for (let i = 0; i < 4; i++) {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 18, 8),
                    castleMaterial
                );
                const angle = (i * Math.PI) / 2;
                tower.position.set(Math.cos(angle) * 8, 9, Math.sin(angle) * 8);
                tower.castShadow = true;
                kingdom.add(tower);
            }

            // Casas
            for (let i = 0; i < 8; i++) {
                const house = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                const angle = (i * Math.PI) / 4;
                house.position.set(Math.cos(angle) * 20, 3, Math.sin(angle) * 20);
                house.castShadow = true;
                kingdom.add(house);
            }

            kingdom.position.set(x, 0, z);
            scene.add(kingdom);
        }

        // Crear mazmorra
        function createDungeon(x, z, color) {
            const dungeon = new THREE.Group();

            // Entrada
            const entrance = new THREE.Mesh(
                new THREE.BoxGeometry(8, 4, 8),
                new THREE.MeshLambertMaterial({ color })
            );
            entrance.position.y = 2;
            entrance.castShadow = true;
            dungeon.add(entrance);

            // Pilares
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1, 10, 6),
                    new THREE.MeshLambertMaterial({ color })
                );
                const angle = (i * Math.PI) / 2;
                pillar.position.set(Math.cos(angle) * 6, 5, Math.sin(angle) * 6);
                pillar.castShadow = true;
                dungeon.add(pillar);
            }

            dungeon.position.set(x, 0, z);
            scene.add(dungeon);
        }

        // Crear jugador
        function createPlayer() {
            player = new THREE.Group();

            // Cuerpo
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 0.5),
                new THREE.MeshLambertMaterial({ color: 0x3366ff })
            );
            body.position.y = 1;
            body.castShadow = true;
            player.add(body);

            // Cabeza
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 2.4;
            head.castShadow = true;
            player.add(head);

            // Brazos
            const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.65, 1.4, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.65, 1.4, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // Piernas
            const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x3333ff });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.6, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.6, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            // Espada
            const sword = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 2, 0.1),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            sword.position.set(1, 1.5, 0);
            sword.visible = false;
            player.add(sword);

            player.position.set(0, 0, 0);
            player.userData = {
                velocity: new THREE.Vector3(),
                isGrounded: true,
                isAttacking: false,
                attackTime: 0,
                parts: { body, head, leftArm, rightArm, leftLeg, rightLeg, sword }
            };

            scene.add(player);

            // Posicionar cámara
            camera.position.set(0, 8, 12);
            camera.lookAt(player.position);
        }

        // Generar enemigos - MUCHOS MÁS
        function spawnEnemies() {
            // Enemigos básicos (30)
            for (let i = 0; i < 30; i++) {
                createEnemy('basic');
            }
            // Enemigos fuertes (15)
            for (let i = 0; i < 15; i++) {
                createEnemy('strong');
            }
            // Enemigos élite (8)
            for (let i = 0; i < 8; i++) {
                createEnemy('elite');
            }
        }

        // Crear enemigo con tipos
        function createEnemy(type = 'basic') {
            const enemy = new THREE.Group();

            let color, health, speed, damage, size, xpReward, scoreReward;

            switch (type) {
                case 'strong':
                    color = 0x660000;
                    health = 60;
                    speed = 2;
                    damage = 15;
                    size = 1.2;
                    xpReward = 40;
                    scoreReward = 150;
                    break;
                case 'elite':
                    color = 0x330000;
                    health = 100;
                    speed = 1.5;
                    damage = 25;
                    size = 1.5;
                    xpReward = 75;
                    scoreReward = 250;
                    break;
                default: // basic
                    color = 0x990000;
                    health = 30;
                    speed = 2.5;
                    damage = 10;
                    size = 1;
                    xpReward = 25;
                    scoreReward = 100;
            }

            // Cuerpo principal
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4 * size, 0.6 * size, 1.8 * size, 8),
                new THREE.MeshLambertMaterial({ color })
            );
            body.position.y = 0.9 * size;
            body.castShadow = true;
            enemy.add(body);

            // Cabeza esférica
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.5 * size, 12, 12),
                new THREE.MeshLambertMaterial({ color: color + 0x111111 })
            );
            head.position.y = 2.2 * size;
            head.castShadow = true;
            enemy.add(head);

            // Ojos rojos brillantes
            const eyeGeometry = new THREE.SphereGeometry(0.08 * size, 6, 6);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x440000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2 * size, 2.3 * size, 0.4 * size);
            enemy.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2 * size, 2.3 * size, 0.4 * size);
            enemy.add(rightEye);

            // Brazos
            const armGeometry = new THREE.CylinderGeometry(0.15 * size, 0.2 * size, 1.2 * size, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: color - 0x222222 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.8 * size, 1.2 * size, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            enemy.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8 * size, 1.2 * size, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            enemy.add(rightArm);

            // Piernas
            const legGeometry = new THREE.CylinderGeometry(0.2 * size, 0.25 * size, 1 * size, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: color - 0x111111 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3 * size, 0.5 * size, 0);
            leftLeg.castShadow = true;
            enemy.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3 * size, 0.5 * size, 0);
            rightLeg.castShadow = true;
            enemy.add(rightLeg);

            // Arma según tipo
            if (type === 'strong' || type === 'elite') {
                const weaponGeometry = new THREE.BoxGeometry(0.1 * size, 1.5 * size, 0.1 * size);
                const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(1.2 * size, 1.5 * size, 0);
                weapon.castShadow = true;
                enemy.add(weapon);
            }

            // Posición aleatoria
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 120;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            enemy.userData = {
                type,
                health,
                maxHealth: health,
                speed,
                damage,
                attackRange: 3,
                attackCooldown: 0,
                xpReward,
                scoreReward,
                lastPlayerPosition: new THREE.Vector3(),
                searchTime: 0,
                state: 'patrol',
                patrolTarget: new THREE.Vector3(
                    enemy.position.x + (Math.random() - 0.5) * 20,
                    0,
                    enemy.position.z + (Math.random() - 0.5) * 20
                ),
                parts: { body, head, leftEye, rightEye, leftArm, rightArm, leftLeg, rightLeg }
            };

            enemies.push(enemy);
            scene.add(enemy);
        }

        // Generar ítems - MUCHOS MÁS
        function spawnItems() {
            // Monedas (50)
            for (let i = 0; i < 50; i++) {
                const item = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xffff00 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 140;
                item.position.set(
                    Math.cos(angle) * distance,
                    0.5,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 10, type: 'coin', coins: 5 };
                items.push(item);
                scene.add(item);
            }

            // Pociones (25)
            for (let i = 0; i < 25; i++) {
                const item = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xff0080 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 120;
                item.position.set(
                    Math.cos(angle) * distance,
                    0.8,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 25, type: 'potion' };
                items.push(item);
                scene.add(item);
            }

            // Armas mejoradas (10)
            for (let i = 0; i < 10; i++) {
                const item = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1.5, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 100;
                item.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 100, type: 'weapon' };
                items.push(item);
                scene.add(item);
            }
        }

        // Generar cristales - MUCHOS MÁS
        function spawnCrystals() {
            // Cristales principales (4)
            const mainPositions = [[-80, -80], [80, -80], [80, 80], [-80, 80]];
            const mainColors = [0xff0000, 0x0000ff, 0xffff00, 0x8B4513];

            for (let i = 0; i < 4; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 4, 6),
                    new THREE.MeshLambertMaterial({ color: mainColors[i] })
                );
                crystal.position.set(mainPositions[i][0], 3, mainPositions[i][1]);
                crystal.userData = { type: 'main_crystal', id: i, power: 100 };
                crystals.push(crystal);
                scene.add(crystal);
            }

            // Cristales menores (20)
            for (let i = 0; i < 20; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.5, 1.5, 6),
                    new THREE.MeshLambertMaterial({ color: 0x00ffff })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 100;
                crystal.position.set(
                    Math.cos(angle) * distance,
                    1.5,
                    Math.sin(angle) * distance
                );
                crystal.userData = { type: 'minor_crystal', power: 25 };
                crystals.push(crystal);
                scene.add(crystal);
            }
        }

        // Variables para control de cámara móvil
        let cameraRotation = { x: 0, y: 0 };
        let isDraggingCamera = false;
        let lastTouchX = 0, lastTouchY = 0;

        // Configurar controles
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (!gameActive && e.code !== 'Escape') return;

                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape') togglePause();
                if (e.code === keyBindings.inventory && gameActive && !gamePaused) toggleInventory();
                if (e.code === 'KeyM' && gameActive && !gamePaused) toggleMinimap();
                if (e.code === 'KeyC' && gameActive && !gamePaused) cycleCameraMode();
                if (e.code === keyBindings.potion && gameActive && !gamePaused) usePotion();
                if (e.code === keyBindings.interact && gameActive && !gamePaused) interactWithNearbyNPC();
                if (e.code === 'F5' && gameActive && !gamePaused) { saveSlot(currentSaveSlot || 0); e.preventDefault(); }
                if (e.code === 'F6' && gameActive && !gamePaused) { showSaveMenu(); e.preventDefault(); }
                if (e.code === 'F9' && gameActive && !gamePaused) { loadAutoSave(); e.preventDefault(); }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameActive && !gamePaused) attack();
                if (e.button === 2 && gameActive && !gamePaused) block();
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Controles de cámara táctil para móvil
            if (isMobile) {
                setupMobileCameraControls();
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Configurar controles de cámara para móvil - MEJORADO
        function setupMobileCameraControls() {
            document.addEventListener('touchstart', (e) => {
                // Solo activar rotación de cámara si no se toca un control
                if (e.touches.length === 1 && !e.target.closest('#mobile-controls') && !e.target.closest('#mobile-pause')) {
                    isDraggingCamera = true;
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingCamera && e.touches.length === 1 && gameActive && !gamePaused) {
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;

                    // Sensibilidad mejorada para rotación de cámara
                    const sensitivity = 0.008;
                    cameraRotation.y -= deltaX * sensitivity; // Invertido para que sea más natural
                    cameraRotation.x -= deltaY * sensitivity; // Invertido para que sea más natural

                    // Limitar rotación vertical para evitar que se voltee
                    cameraRotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraRotation.x));

                    // Normalizar rotación horizontal
                    if (cameraRotation.y > Math.PI) cameraRotation.y -= Math.PI * 2;
                    if (cameraRotation.y < -Math.PI) cameraRotation.y += Math.PI * 2;

                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchend', (e) => {
                if (isDraggingCamera) {
                    isDraggingCamera = false;
                    // Pequeña vibración para confirmar que se soltó la cámara
                    if (navigator.vibrate && mobileSettings.hapticFeedback) {
                        navigator.vibrate(20);
                    }
                }
            });

            // Prevenir scroll en iOS/Android cuando se arrastra la cámara
            document.addEventListener('touchmove', (e) => {
                if (isDraggingCamera) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // Controles móviles mejorados con posición horizontal
        function setupMobileControls() {
            // Reposicionar controles para modo horizontal - separar del joystick
            const mobileControls = document.getElementById('mobile-controls');
            if (window.innerWidth > window.innerHeight) {
                // Modo horizontal - joystick a la izquierda, botones a la derecha
                mobileControls.style.left = '20px';
                mobileControls.style.right = 'auto';
                mobileControls.style.bottom = '20px';

                // Reposicionar botones más a la derecha para separarlos del joystick
                const buttons = mobileControls.querySelectorAll('button');
                buttons.forEach((button, index) => {
                    if (button.id === 'mobile-attack') {
                        button.style.left = '200px'; // Más separado
                        button.style.bottom = '0';
                    } else if (button.id === 'mobile-jump') {
                        button.style.left = '200px';
                        button.style.bottom = '70px';
                    } else if (button.id === 'mobile-potion') {
                        button.style.left = '270px';
                        button.style.bottom = '0';
                    } else if (button.id === 'mobile-inventory') {
                        button.style.left = '270px';
                        button.style.bottom = '60px';
                    } else if (button.id === 'mobile-camera') {
                        button.style.left = '270px';
                        button.style.bottom = '120px';
                    }
                });
            } else {
                // Modo vertical - posición original
                mobileControls.style.left = '20px';
                mobileControls.style.right = 'auto';
                mobileControls.style.bottom = '20px';

                // Restaurar posiciones originales en vertical
                const buttons = mobileControls.querySelectorAll('button');
                buttons.forEach((button) => {
                    if (button.id === 'mobile-attack') {
                        button.style.left = '120px';
                        button.style.bottom = '0';
                    } else if (button.id === 'mobile-jump') {
                        button.style.left = '120px';
                        button.style.bottom = '70px';
                    } else if (button.id === 'mobile-potion') {
                        button.style.left = '190px';
                        button.style.bottom = '0';
                    } else if (button.id === 'mobile-inventory') {
                        button.style.left = '190px';
                        button.style.bottom = '60px';
                    } else if (button.id === 'mobile-camera') {
                        button.style.left = '190px';
                        button.style.bottom = '120px';
                    }
                });
            }

            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystick-knob');
            let isDragging = false;
            let touchId = null;

            // Joystick mejorado con mejor respuesta
            joystick.addEventListener('touchstart', (e) => {
                if (touchId === null) {
                    isDragging = true;
                    touchId = e.touches[0].identifier;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging || touchId === null) return;

                let touch = null;
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        touch = e.touches[i];
                        break;
                    }
                }

                if (!touch) return;

                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const distance = Math.min(30, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                knob.style.left = (30 + Math.cos(angle) * distance) + 'px';
                knob.style.top = (30 + Math.sin(angle) * distance) + 'px';

                // Simular teclas con mejor sensibilidad
                const sensitivity = 8;
                keys['KeyW'] = deltaY < -sensitivity;
                keys['KeyS'] = deltaY > sensitivity;
                keys['KeyA'] = deltaX < -sensitivity;
                keys['KeyD'] = deltaX > sensitivity;
                keys['KeyR'] = distance > 25; // Correr cuando se mueve al borde

                e.preventDefault();
            });

            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        isDragging = false;
                        touchId = null;
                        knob.style.left = '30px';
                        knob.style.top = '30px';
                        keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = keys['KeyR'] = false;
                        break;
                    }
                }
            });

            // Reposicionar en cambio de orientación
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    setupMobileControls(); // Reconfigurar completamente los controles
                }, 100);
            });

            // También reconfigurar en resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    setupMobileControls();
                }, 100);
            });

            // Botones mejorados con feedback haptico
            document.getElementById('mobile-attack').addEventListener('touchstart', (e) => {
                attack();
                if (navigator.vibrate) navigator.vibrate(50);
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });

            document.getElementById('mobile-attack').addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
                e.preventDefault();
            });

            document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
                keys['Space'] = true;
                if (navigator.vibrate) navigator.vibrate(30);
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });

            document.getElementById('mobile-jump').addEventListener('touchend', (e) => {
                keys['Space'] = false;
                e.target.style.transform = 'scale(1)';
                e.preventDefault();
            });

            // Configurar botones adicionales
            document.getElementById('mobile-potion').addEventListener('touchstart', (e) => {
                usePotion();
                if (navigator.vibrate) navigator.vibrate(40);
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });

            document.getElementById('mobile-potion').addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
            });

            document.getElementById('mobile-inventory').addEventListener('touchstart', (e) => {
                toggleInventory();
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });

            document.getElementById('mobile-inventory').addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
            });

            document.getElementById('mobile-camera').addEventListener('touchstart', (e) => {
                cycleCameraMode();
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });

            document.getElementById('mobile-camera').addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
            });

            // Configurar doble toque para interacciones
            setupDoubleTap();
        }

        // Configurar doble toque para interacciones
        function setupDoubleTap() {
            let lastTap = 0;

            document.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;

                if (tapLength < 500 && tapLength > 0) {
                    // Doble toque detectado
                    if (gameActive && !gamePaused) {
                        interactWithNearbyNPC();
                        if (navigator.vibrate) navigator.vibrate(60);
                    }
                    e.preventDefault();
                }

                lastTap = currentTime;
            });
        }

        // Botones adicionales para móvil
        addMobileButtons();


        // Añadir botones adicionales para móvil
        function addMobileButtons() {
            const mobileControls = document.getElementById('mobile-controls');

            // Botón de poción
            const potionBtn = document.createElement('button');
            potionBtn.innerHTML = '🧪';
            potionBtn.style.cssText = 'position: absolute; right: -190px; bottom: 0; width: 50px; height: 50px; background: #9C27B0; color: white; border: none; border-radius: 50%; font-size: 16px;';
            potionBtn.addEventListener('touchstart', (e) => {
                usePotion();
                if (navigator.vibrate) navigator.vibrate(40);
                e.preventDefault();
            });
            mobileControls.appendChild(potionBtn);

            // Botón de inventario
            const invBtn = document.createElement('button');
            invBtn.innerHTML = '🎒';
            invBtn.style.cssText = 'position: absolute; right: -190px; bottom: 60px; width: 50px; height: 50px; background: #FF9800; color: white; border: none; border-radius: 50%; font-size: 16px;';
            invBtn.addEventListener('touchstart', (e) => {
                toggleInventory();
                e.preventDefault();
            });
            mobileControls.appendChild(invBtn);
        }

        // Actualizar jugador
        function updatePlayer(delta) {
            const userData = player.userData;
            const speed = keys[keyBindings.run] ? config.playerSpeed * 1.5 : config.playerSpeed;

            // Movimiento
            const moveVector = new THREE.Vector3();
            if (keys[keyBindings.forward]) moveVector.z -= 1;
            if (keys[keyBindings.backward]) moveVector.z += 1;
            if (keys[keyBindings.left]) moveVector.x -= 1;
            if (keys[keyBindings.right]) moveVector.x += 1;

            if (moveVector.length() > 0) {
                moveVector.normalize();
                const oldPos = player.position.clone();
                player.position.x += moveVector.x * speed * delta;
                player.position.z += moveVector.z * speed * delta;
                playerStats.totalDistance += oldPos.distanceTo(player.position);

                // Rotar hacia dirección de movimiento
                const targetRotation = Math.atan2(moveVector.x, moveVector.z);
                player.rotation.y = targetRotation;
            }

            // Salto
            if (keys['Space'] && userData.isGrounded) {
                userData.velocity.y = config.jumpForce;
                userData.isGrounded = false;
                playerStats.totalJumps++;
                checkAchievement('jumper');
            }

            // Gravedad
            userData.velocity.y += config.gravity * delta;
            player.position.y += userData.velocity.y * delta;

            // Colisión con suelo
            if (player.position.y <= 0) {
                player.position.y = 0;
                userData.velocity.y = 0;
                userData.isGrounded = true;
            }

            // Actualizar cámara según modo
            switch (cameraMode) {
                case 'first':
                    camera.position.copy(player.position);
                    camera.position.y += 1.8;
                    if (isMobile) {
                        // Cámara primera persona con rotación táctil mejorada
                        const euler = new THREE.Euler(cameraRotation.x, cameraRotation.y + player.rotation.y, 0, 'YXZ');
                        camera.setRotationFromEuler(euler);
                    } else {
                        const forward = new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(player.quaternion);
                        camera.lookAt(player.position.clone().add(forward));
                    }
                    break;
                case 'free':
                    if (isMobile) {
                        // Cámara libre con rotación táctil mejorada
                        const radius = 15;
                        const x = Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x) * radius;
                        const y = Math.sin(cameraRotation.x) * radius + 8;
                        const z = Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x) * radius;

                        camera.position.set(
                            player.position.x + x,
                            player.position.y + y,
                            player.position.z + z
                        );
                        camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
                    } else {
                        // Cámara libre para PC (sin cambios)
                        const cameraOffset = new THREE.Vector3(0, 15, 15);
                        const desiredPosition = player.position.clone().add(cameraOffset);
                        camera.position.lerp(desiredPosition, delta * 3);
                        camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
                    }
                    break;
                default: // third person
                    if (isMobile) {
                        // Tercera persona con rotación táctil completamente funcional
                        const radius = 12;
                        const height = 8;
                        const x = Math.sin(cameraRotation.y) * radius;
                        const y = height + Math.sin(cameraRotation.x) * 5;
                        const z = Math.cos(cameraRotation.y) * radius;

                        camera.position.set(
                            player.position.x + x,
                            player.position.y + y,
                            player.position.z + z
                        );
                        camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
                    } else {
                        const cameraOffset = new THREE.Vector3(0, 8, 12);
                        const desiredPosition = player.position.clone().add(cameraOffset);
                        camera.position.lerp(desiredPosition, delta * 5);
                        camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
                    }
            }

            // Animación de ataque
            if (userData.isAttacking) {
                userData.attackTime += delta;
                userData.parts.sword.visible = true;

                if (userData.attackTime > 0.5) {
                    userData.isAttacking = false;
                    userData.attackTime = 0;
                    userData.parts.sword.visible = false;
                }
            }

            // Animación de caminar
            if (moveVector.length() > 0 && userData.isGrounded) {
                const time = Date.now() * 0.005;
                userData.parts.leftLeg.rotation.x = Math.sin(time) * 0.5;
                userData.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.5;
                userData.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                userData.parts.rightArm.rotation.x = Math.sin(time) * 0.3;
            }
        }

        // Atacar
        function attack() {
            if (player.userData.isAttacking) return;

            player.userData.isAttacking = true;
            player.userData.attackTime = 0;
            playerStats.totalAttacks++;
            checkAchievement('warrior');

            // Buscar enemigos en rango
            enemies.forEach((enemy, index) => {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < config.attackRange) {
                    enemy.userData.health -= 20 * inventory.sword;

                    if (enemy.userData.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                        score += enemy.userData.scoreReward;
                        kills++;
                        playerXP += enemy.userData.xpReward;
                        inventory.coins += Math.floor(Math.random() * 20) + 5;
                        checkLevelUp();
                        checkAchievement('first_kill');
                        updateUI();
                        updateInventoryUI();
                        showNotification(`+${enemy.userData.scoreReward} puntos! +${enemy.userData.xpReward} XP`, 1000);
                    }
                }
            });

            // Atacar jefes
            bosses.forEach((boss, index) => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < config.attackRange) {
                    boss.userData.health -= 30 * inventory.sword;

                    if (boss.userData.health <= 0) {
                        scene.remove(boss);
                        bosses.splice(index, 1);
                        score += 500;
                        playerXP += 100;
                        inventory.sword++;
                        checkLevelUp();
                        checkAchievement('boss_slayer');
                        updateUI();
                        updateInventoryUI();
                        showNotification("¡Jefe derrotado! +500 puntos! Espada mejorada!", 3000);

                        // Verificar victoria total
                        if (crystalsFound >= 4 && bosses.length === 0) {
                            setTimeout(() => {
                                showNotification("¡VICTORIA TOTAL!\n¡Has derrotado a todos los jefes y encontrado todos los cristales!\n¡Aethermoor está a salvo!", 5000);
                                setTimeout(() => gameOver(), 5000);
                            }, 3000);
                        }
                    }
                }
            });
        }

        // Sistema de niveles
        function checkLevelUp() {
            const xpNeeded = playerLevel * 100;
            if (playerXP >= xpNeeded) {
                playerXP -= xpNeeded;
                playerLevel++;
                playerHealth = Math.min(100, playerHealth + 20);
                inventory.potions++;
                showNotification(`¡Nivel ${playerLevel}! +20 HP, +1 Poción", 3000`);
                updateUI();
                updateInventoryUI();
            }
        }

        // Usar poción
        function usePotion() {
            if (inventory.potions > 0 && playerHealth < 100) {
                inventory.potions--;
                playerHealth = Math.min(100, playerHealth + 50);
                updateUI();
                updateInventoryUI();
                showNotification("+50 HP", 1500);
            }
        }

        // Actualizar enemigos con IA mejorada
        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                const userData = enemy.userData;
                const distance = player.position.distanceTo(enemy.position);
                const time = Date.now() * 0.003;

                // Estados de IA
                if (distance < 20) {
                    userData.state = 'chase';
                    userData.lastPlayerPosition.copy(player.position);
                    userData.searchTime = 0;
                } else if (userData.state === 'chase' && distance > 25) {
                    userData.state = 'search';
                    userData.searchTime = 3; // Buscar por 3 segundos
                } else if (userData.state === 'search') {
                    userData.searchTime -= delta;
                    if (userData.searchTime <= 0) {
                        userData.state = 'patrol';
                        // Nuevo punto de patrulla
                        userData.patrolTarget.set(
                            enemy.position.x + (Math.random() - 0.5) * 30,
                            0,
                            enemy.position.z + (Math.random() - 0.5) * 30
                        );
                    }
                }

                let targetPosition;
                switch (userData.state) {
                    case 'chase':
                        targetPosition = player.position;
                        break;
                    case 'search':
                        targetPosition = userData.lastPlayerPosition;
                        break;
                    case 'patrol':
                        targetPosition = userData.patrolTarget;
                        if (enemy.position.distanceTo(userData.patrolTarget) < 2) {
                            userData.patrolTarget.set(
                                enemy.position.x + (Math.random() - 0.5) * 30,
                                0,
                                enemy.position.z + (Math.random() - 0.5) * 30
                            );
                        }
                        break;
                }

                // Movimiento hacia objetivo
                const direction = new THREE.Vector3()
                    .subVectors(targetPosition, enemy.position)
                    .normalize();
                
                const moveSpeed = userData.state === 'chase' ? userData.speed : userData.speed * 0.5;
                enemy.position.add(direction.multiplyScalar(moveSpeed * delta));
                enemy.lookAt(targetPosition);

                // Atacar si está persiguiendo y cerca
                if (userData.state === 'chase' && distance < userData.attackRange && userData.attackCooldown <= 0) {
                    playerHealth -= userData.damage;
                    userData.attackCooldown = 2;
                    updateUI();
                    showNotification(`-${userData.damage} HP`, 800);
                    
                    // Vibración y notificación en móvil
                    if (isMobile && navigator.vibrate && mobileSettings.hapticFeedback) {
                        navigator.vibrate([100, 50, 100]); // Patrón de vibración
                    }
                    
                    // Notificación de Android si la app está en segundo plano
                    if (document.hidden) {
                        showAndroidNotification('¡Pepe bajo ataque!', `Enemigo ${userData.type} te atacó por ${userData.damage} HP`);
                    }

                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }

                if (userData.attackCooldown > 0) {
                    userData.attackCooldown -= delta;
                }

                // Animaciones mejoradas
                if (userData.state === 'chase') {
                    // Animación agresiva
                    userData.parts.leftArm.rotation.x = Math.sin(time * 2) * 0.8;
                    userData.parts.rightArm.rotation.x = Math.sin(time * 2 + Math.PI) * 0.8;
                    userData.parts.leftLeg.rotation.x = Math.sin(time * 3) * 0.6;
                    userData.parts.rightLeg.rotation.x = Math.sin(time * 3 + Math.PI) * 0.6;
                    userData.parts.body.rotation.z = Math.sin(time * 4) * 0.2;
                } else {
                    // Animación calmada
                    userData.parts.leftArm.rotation.x = Math.sin(time) * 0.3;
                    userData.parts.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                    userData.parts.leftLeg.rotation.x = Math.sin(time * 1.5) * 0.4;
                    userData.parts.rightLeg.rotation.x = Math.sin(time * 1.5 + Math.PI) * 0.4;
                    userData.parts.body.rotation.z = Math.sin(time) * 0.1;
                }

                // Ojos brillantes cuando persigue
                if (userData.parts.leftEye && userData.parts.rightEye) {
                    const intensity = userData.state === 'chase' ? 0.8 : 0.2;
                    userData.parts.leftEye.material.emissive.setHex(userData.state === 'chase' ? 0x880000 : 0x440000);
                    userData.parts.rightEye.material.emissive.setHex(userData.state === 'chase' ? 0x880000 : 0x440000);
                }
            });
        }

        // Actualizar ítems
        function updateItems(delta) {
            items.forEach((item, index) => {
                // Rotación
                item.rotation.y += delta * 2;

                // Colisión con jugador
                const distance = player.position.distanceTo(item.position);
                if (distance < 2) {
                    scene.remove(item);
                    items.splice(index, 1);
                    score += item.userData.points;

                    switch (item.userData.type) {
                        case 'coin':
                            inventory.coins += item.userData.coins || 5;
                            showNotification(`+${item.userData.coins || 5} monedas!`, 800);
                            break;
                        case 'potion':
                            inventory.potions++;
                            showNotification(`+1 Poción de Salud!`, 1000);
                            break;
                        case 'weapon':
                            inventory.sword++;
                            showNotification(`¡Espada mejorada! Nivel ${inventory.sword}`, 2000);
                            break;
                    }

                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Actualizar cristales
        function updateCrystals(delta) {
            crystals.forEach((crystal, index) => {
                // Rotación y flotación
                crystal.rotation.y += delta;
                crystal.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.5;

                // Colisión con jugador
                const distance = player.position.distanceTo(crystal.position);
                if (distance < 3) {
                    scene.remove(crystal);
                    crystals.splice(index, 1);

                    if (crystal.userData.type === 'main_crystal') {
                        crystalsFound++;
                        score += 1000;
                        playerXP += 200;
                        inventory.artifacts++;
                        showNotification(`¡Cristal Principal! +1000 puntos +200 XP`, 3000);

                        if (crystalsFound >= 4 && bosses.length === 0) {
                            checkAchievement('savior');
                            showNotification("¡Misión completada!\n¡Aethermoor ha sido salvado!", 5000);
                            setTimeout(() => gameOver(), 5000);
                        } else if (crystalsFound >= 4) {
                            showNotification("¡Todos los cristales principales encontrados!\nAhora debes derrotar a todos los jefes!", 5000);
                        }
                    } else {
                        score += 200;
                        playerXP += 50;
                        inventory.coins += 25;
                        showNotification(`Cristal Menor: +200 puntos +50 XP`, 1500);
                    }

                    checkAchievement('crystal_collector');
                    checkLevelUp();
                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Actualizar UI
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, playerHealth);
            document.getElementById('score').textContent = score;
            document.getElementById('kills').textContent = kills;
            document.getElementById('crystals').textContent = crystalsFound;
            document.getElementById('health-fill').style.width = Math.max(0, playerHealth) + '%';

            // Actualizar misión
            const totalCrystals = crystals.length + (crystalsFound * 5); // Estimar cristales restantes
            document.getElementById('mission-text').textContent =
                `Cristales Principales: ${crystalsFound}/4 | Cristales Menores: ${Math.max(0, 20 - (crystals.length - 4))}/20 | Jefes: ${4 - bosses.length}/4`;
        }

        // Mostrar notificación
        function showNotification(text, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        // Game Over
        function gameOver() {
            gameActive = false;
            gamePaused = true;

            const totalCrystalsCollected = 24 - crystals.length; // 4 main + 20 minor
            const isVictory = crystalsFound >= 4 && bosses.length === 0;

            const finalStats = `
                ${isVictory ? '¡VICTORIA TOTAL!' : '¡GAME OVER!'}
                
                Puntuación final: ${score || 0}
                Nivel alcanzado: ${playerLevel}
                Enemigos derrotados: ${kills}
                Cristales Principales: ${crystalsFound}/4
                Cristales Totales: ${totalCrystalsCollected}/24
                Jefes derrotados: ${4 - bosses.length}/4
                Cofres abiertos: ${20 - items.filter(i => i.userData.type === 'chest' && !i.userData.opened).length}/20
                Tiempo jugado: ${Math.floor(gameTime / 60)}m ${Math.floor(gameTime % 60)}s
                
                ${isVictory ? '¡FELICIDADES! Has salvado completamente Aethermoor!' : 'Aethermoor aún necesita tu ayuda...'}
            `;

            showNotification(finalStats, 20000);

            setTimeout(() => {
                document.getElementById('main-menu').style.display = 'flex';
            }, 20000);
        }

        // Actualizar estadísticas
        function updateStats() {
            stats.frames++;
            const now = performance.now();

            if (now - stats.lastTime >= 1000) {
                stats.fps = Math.round((stats.frames * 1000) / (now - stats.lastTime));
                stats.frames = 0;
                stats.lastTime = now;

                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('objects').textContent = scene.children.length;
            }
        }

        // Funciones adicionales
        function toggleInventory() {
            const inv = document.getElementById('inventory');
            inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
        }

        function toggleMinimap() {
            settings.minimap = !settings.minimap;
            document.getElementById('minimap').style.display = settings.minimap ? 'block' : 'none';
        }

        function cycleCameraMode() {
            const modes = ['third', 'first', 'free'];
            const currentIndex = modes.indexOf(cameraMode);
            cameraMode = modes[(currentIndex + 1) % modes.length];

            // Resetear rotación de cámara al cambiar modo para mejor experiencia
            if (isMobile) {
                cameraRotation = { x: 0, y: 0 };
            }

            const modeNames = {
                'third': '3ª Persona - Desliza para rotar cámara',
                'first': '1ª Persona - Desliza para mirar alrededor',
                'free': 'Cámara Libre - Desliza para orbitar'
            };

            showNotification(`📷 ${modeNames[cameraMode]}`, 3000);

            // Mostrar hint adicional para móvil
            if (isMobile) {
                setTimeout(() => {
                    showNotification('💡 Desliza fuera de los controles para rotar la cámara', 2000);
                }, 3500);
            }
        }

        function block() {
            if (inventory.shield > 0) {
                showNotification('Bloqueando...', 500);
            }
        }

        function updateInventoryUI() {
            const items = document.getElementById('inventory-items');
            items.innerHTML = `
                <div>Espada: Nivel ${inventory.sword}</div>
                <div>Escudo: Nivel ${inventory.shield}</div>
                <div>Pociones: ${inventory.potions} (P para usar)</div>
                <div>Llaves: ${inventory.keys}</div>
                <div>Monedas: ${inventory.coins}</div>
                <div>Artefactos: ${inventory.artifacts}</div>
                <div>Nivel: ${playerLevel} (XP: ${playerXP}/${playerLevel * 100})</div>
            `;

            const stats = document.getElementById('player-stats');
            const hours = Math.floor(gameTime / 3600);
            const minutes = Math.floor((gameTime % 3600) / 60);
            stats.innerHTML = `
                <div>Tiempo jugado: ${hours}h ${minutes}m</div>
                <div>Distancia recorrida: ${Math.floor(playerStats.totalDistance)}m</div>
                <div>Saltos realizados: ${playerStats.totalJumps}</div>
                <div>Ataques realizados: ${playerStats.totalAttacks}</div>
            `;
        }

        // Interactuar con NPCs
        function interactWithNearbyNPC() {
            villagers.forEach(villager => {
                const distance = player.position.distanceTo(villager.position);
                if (distance < 4) {
                    const dialogue = villager.userData.dialogue[villager.userData.currentDialogue];
                    showNotification(dialogue, 3000);
                    villager.userData.currentDialogue = (villager.userData.currentDialogue + 1) % villager.userData.dialogue.length;
                }
            });
        }

        // Limpieza de memoria mejorada
        function cleanupMemory() {
            if (!scene || window.gc) {
                if (window.gc) window.gc();
                return;
            }

            // Limpiar objetos eliminados
            scene.traverse((object) => {
                if (object.geometry && object.userData.disposed) {
                    object.geometry.dispose();
                }
                if (object.material && object.userData.disposed) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
            });
        }

        // Auto-limpieza cada 30 segundos
        setInterval(cleanupMemory, 30000);

        function updateGraphics() {
            if (!renderer) return;

            switch (settings.shadows) {
                case 'off':
                    renderer.shadowMap.enabled = false;
                    break;
                case 'low':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    break;
                case 'high':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    break;
            }
        }

        function setupPerformanceOptimization() {
            setInterval(() => {
                if (stats.fps < 30 && settings.shadows !== 'off') {
                    settings.shadows = 'off';
                    updateGraphics();
                    showNotification('Optimizando rendimiento...', 2000);
                }
            }, 5000);
        }

        // Generar aldeanos
        function spawnVillagers() {
            for (let i = 0; i < 6; i++) {
                const villager = createVillager();
                villagers.push(villager);
                scene.add(villager);
            }
        }

        function createVillager() {
            const villager = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.6, 0.4),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            body.position.y = 0.8;
            villager.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 1.8;
            villager.add(head);

            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 60;
            villager.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            villager.userData = {
                type: 'villager',
                dialogue: ['Hola Pepe!', 'Salva nuestro reino!', 'Los cristales están en los reinos elementales'],
                currentDialogue: 0
            };

            return villager;
        }

        // Generar jefes
        function spawnBosses() {
            const bossPositions = [[0, -120], [120, 0], [0, 120], [-120, 0]];

            bossPositions.forEach((pos, i) => {
                const boss = createBoss(pos[0], pos[1], i);
                bosses.push(boss);
                scene.add(boss);
            });
        }

        function createBoss(x, z, type) {
            const boss = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 1),
                new THREE.MeshLambertMaterial({ color: 0x330000 })
            );
            body.position.y = 2;
            body.castShadow = true;
            boss.add(body);

            const head = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.5, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x660000 })
            );
            head.position.y = 4.5;
            head.castShadow = true;
            boss.add(head);

            boss.position.set(x, 0, z);
            boss.userData = {
                type: 'boss',
                health: 200,
                maxHealth: 200,
                damage: 25,
                speed: 2,
                attackRange: 5,
                attackCooldown: 0,
                bossType: type
            };

            return boss;
        }

        // Bucle principal
        function animate() {
            requestAnimationFrame(animate);

            if (!gameActive || gamePaused) {
                renderer.render(scene, camera);
                return;
            }

            const delta = Math.min(clock.getDelta(), 0.033);
            gameTime += delta;

            updatePlayer(delta);
            updateEnemies(delta);
            updateVillagers(delta);
            updateBosses(delta);
            updateItems(delta);
            updateCrystals(delta);
            updateTreasureChests(delta);
            updateWeather(delta);
            updateDayNight(delta);
            updateMinimap();
            updateCompass();
            updateAchievements();
            updateStats();

            renderer.render(scene, camera);
        }

        function updateVillagers(delta) {
            villagers.forEach(villager => {
                const distance = player.position.distanceTo(villager.position);
                if (distance < 3) {
                    const dialogue = villager.userData.dialogue[villager.userData.currentDialogue];
                    showNotification(dialogue, 2000);
                    villager.userData.currentDialogue = (villager.userData.currentDialogue + 1) % villager.userData.dialogue.length;
                }
            });
        }

        function updateBosses(delta) {
            bosses.forEach(boss => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < 20) {
                    const direction = new THREE.Vector3()
                        .subVectors(player.position, boss.position)
                        .normalize();

                    boss.position.add(direction.multiplyScalar(boss.userData.speed * delta));
                    boss.lookAt(player.position);

                    if (distance < boss.userData.attackRange && boss.userData.attackCooldown <= 0) {
                        playerHealth -= boss.userData.damage;
                        boss.userData.attackCooldown = 2;
                        updateUI();
                        showNotification(`¡Jefe te ataca! -${boss.userData.damage} HP`, 1500);

                        if (playerHealth <= 0) {
                            gameOver();
                        }
                    }
                }

                if (boss.userData.attackCooldown > 0) {
                    boss.userData.attackCooldown -= delta;
                }
            });
        }

        function updateDayNight(delta) {
            if (!settings.dayNight) return;

            dayTime += delta * 0.1;
            if (dayTime > 1) dayTime = 0;

            const intensity = 0.3 + Math.sin(dayTime * Math.PI * 2) * 0.5;
            scene.children.forEach(child => {
                if (child.type === 'DirectionalLight') {
                    child.intensity = Math.max(0.2, intensity);
                }
            });
        }

        function updateMinimap() {
            if (!settings.minimap) return;

            const minimap = document.getElementById('minimap');
            if (!minimap) return;

            // Crear canvas para minimapa si no existe
            let canvas = minimap.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                minimap.appendChild(canvas);
            }

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 150);

            // Fondo
            ctx.fillStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.fillRect(0, 0, 150, 150);

            // Jugador (centro)
            ctx.fillStyle = 'blue';
            ctx.fillRect(72, 72, 6, 6);

            // Enemigos
            ctx.fillStyle = 'red';
            enemies.forEach(enemy => {
                const dx = enemy.position.x - player.position.x;
                const dz = enemy.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 3, 3);
                }
            });

            // Cristales
            ctx.fillStyle = 'yellow';
            crystals.forEach(crystal => {
                const dx = crystal.position.x - player.position.x;
                const dz = crystal.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 4, 4);
                }
            });
        }

        function updateCompass() {
            if (!settings.compass) return;
            const compass = document.getElementById('compass');
            if (!compass) return;

            const rotation = player.rotation.y * (180 / Math.PI);
            compass.style.transform = `rotate(${-rotation}deg)`;

            // Mostrar dirección al cristal más cercano
            if (crystals.length > 0) {
                let closestCrystal = crystals[0];
                let minDistance = player.position.distanceTo(closestCrystal.position);

                crystals.forEach(crystal => {
                    const distance = player.position.distanceTo(crystal.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCrystal = crystal;
                    }
                });

                const direction = new THREE.Vector3()
                    .subVectors(closestCrystal.position, player.position)
                    .normalize();
                const angle = Math.atan2(direction.x, direction.z) * (180 / Math.PI);

                compass.innerHTML = `N<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${angle}deg);">→</div>`;
            } else {
                compass.innerHTML = 'N';
            }
        }

        // Sistemas adicionales - MÁS COFRES
        function spawnTreasureChests() {
            for (let i = 0; i < 20; i++) {
                const chest = new THREE.Group();

                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 1.5),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                box.position.y = 0.5;
                chest.add(box);

                const lid = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.2, 1.6),
                    new THREE.MeshLambertMaterial({ color: 0xA0522D })
                );
                lid.position.y = 1.1;
                chest.add(lid);

                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 80;
                chest.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );

                chest.userData = {
                    type: 'chest',
                    opened: false,
                    contents: {
                        coins: 100 + Math.floor(Math.random() * 200),
                        potions: 1 + Math.floor(Math.random() * 4),
                        artifacts: Math.random() > 0.5 ? 1 : 0,
                        weaponUpgrade: Math.random() > 0.8 ? 1 : 0
                    }
                };

                scene.add(chest);
                items.push(chest);
            }
        }

        function updateTreasureChests(delta) {
            items.forEach((item, index) => {
                if (item.userData.type === 'chest' && !item.userData.opened) {
                    const distance = player.position.distanceTo(item.position);
                    if (distance < 2) {
                        item.userData.opened = true;
                        const contents = item.userData.contents;

                        inventory.coins += contents.coins;
                        inventory.potions += contents.potions;
                        inventory.artifacts += contents.artifacts;
                        if (contents.weaponUpgrade) inventory.sword++;

                        score += contents.coins;
                        updateUI();
                        updateInventoryUI();

                        let message = `Cofre abierto!\n+${contents.coins} monedas\n+${contents.potions} pociones`;
                        if (contents.artifacts) message += `\n+${contents.artifacts} artefactos`;
                        if (contents.weaponUpgrade) message += `\n¡Espada mejorada!`;
                        showNotification(message, 3000);

                        // Cambiar color del cofre
                        item.children[0].material.color.setHex(0x666666);

                        checkAchievement('treasure_hunter');
                    }
                }
            });
        }

        function initWeatherSystem() {
            weather.type = ['clear', 'rain', 'snow', 'fog'][Math.floor(Math.random() * 4)];
            updateWeatherDisplay();
        }

        function updateWeather(delta) {
            // Cambiar clima cada 2 minutos
            if (Math.floor(gameTime) % 120 === 0 && Math.floor(gameTime) > 0) {
                weather.type = ['clear', 'rain', 'snow', 'fog'][Math.floor(Math.random() * 4)];
                updateWeatherDisplay();
            }

            // Efectos visuales del clima
            switch (weather.type) {
                case 'fog':
                    scene.fog.density = 0.02;
                    break;
                case 'rain':
                    scene.fog.density = 0.01;
                    break;
                default:
                    scene.fog.density = 0.005;
            }
        }

        function updateWeatherDisplay() {
            const weatherNames = {
                clear: 'Despejado ☀️',
                rain: 'Lluvia 🌧️',
                snow: 'Nieve ❄️',
                fog: 'Niebla 🌫️'
            };
            document.getElementById('weather-info').textContent = weatherNames[weather.type];
        }

        function initAchievements() {
            const achievementDefs = {
                first_kill: { name: 'Primer Enemigo', desc: 'Derrota tu primer enemigo' },
                treasure_hunter: { name: 'Cazatesoros', desc: 'Abre tu primer cofre' },
                crystal_collector: { name: 'Coleccionista', desc: 'Encuentra tu primer cristal' },
                level_up: { name: 'Crecimiento', desc: 'Alcanza el nivel 2' },
                boss_slayer: { name: 'Matajefes', desc: 'Derrota tu primer jefe' },
                explorer: { name: 'Explorador', desc: 'Recorre 1000 metros' },
                jumper: { name: 'Saltarín', desc: 'Realiza 100 saltos' },
                warrior: { name: 'Guerrero', desc: 'Realiza 50 ataques' },
                savior: { name: 'Salvador de Aethermoor', desc: 'Encuentra todos los cristales' }
            };

            window.achievementDefs = achievementDefs;
        }

        function checkAchievement(id) {
            if (achievements.includes(id)) return;

            let unlocked = false;

            switch (id) {
                case 'first_kill':
                    unlocked = kills >= 1;
                    break;
                case 'treasure_hunter':
                    unlocked = true; // Se llama cuando se abre un cofre
                    break;
                case 'crystal_collector':
                    unlocked = crystalsFound >= 1;
                    break;
                case 'level_up':
                    unlocked = playerLevel >= 2;
                    break;
                case 'boss_slayer':
                    unlocked = bosses.length < 4;
                    break;
                case 'explorer':
                    unlocked = playerStats.totalDistance >= 1000;
                    break;
                case 'jumper':
                    unlocked = playerStats.totalJumps >= 100;
                    break;
                case 'warrior':
                    unlocked = playerStats.totalAttacks >= 50;
                    break;
                case 'savior':
                    unlocked = crystalsFound >= 4;
                    break;
            }

            if (unlocked) {
                achievements.push(id);
                const def = window.achievementDefs[id];
                showNotification(`🏆 LOGRO DESBLOQUEADO!\n${def.name}\n${def.desc}`, 4000);
                updateAchievementsUI();
            }
        }

        function updateAchievements() {
            checkAchievement('first_kill');
            checkAchievement('crystal_collector');
            checkAchievement('level_up');
            checkAchievement('boss_slayer');
            checkAchievement('explorer');
            checkAchievement('jumper');
            checkAchievement('warrior');
            checkAchievement('savior');
        }

        function updateAchievementsUI() {
            const list = document.getElementById('achievement-list');
            list.innerHTML = achievements.map(id => {
                const def = window.achievementDefs[id];
                return `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">🏆 ${def.name}</div>`;
            }).join('');

            if (achievements.length > 0) {
                document.getElementById('achievements').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('achievements').style.display = 'none';
                }, 5000);
            }
        }

        // Funciones de fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement &&
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                enterFullscreen();
            } else {
                exitFullscreen();
            }
        }

        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        function updateFullscreenButton() {
            const btn = document.getElementById('fullscreen-btn');
            if (!btn) return;

            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement;

            btn.textContent = isFullscreen ? 'Salir' : 'Activar';
            btn.style.background = isFullscreen ? '#f44336' : '#4CAF50';
        }

        // Cambiar dificultad
        function changeDifficulty(level) {
            settings.difficulty = level;
            switch (level) {
                case 'easy':
                    config.playerSpeed = 10;
                    if (player) playerHealth = Math.min(150, playerHealth + 50);
                    break;
                case 'hard':
                    config.playerSpeed = 6;
                    if (player) playerHealth = Math.max(50, playerHealth - 25);
                    break;
                default: // normal
                    config.playerSpeed = 8;
            }
            updateUI();
            showNotification(`Dificultad: ${level.toUpperCase()}`, 2000);
        }

        // Auto-guardar en slot actual
        function autoSave() {
            if (!settings.autoSave || !gameActive || currentSaveSlot === null) return;
            const saveData = {
                playerHealth, score, kills, crystalsFound, playerLevel, playerXP,
                inventory, achievements, gameTime, playerStats,
                position: player ? { x: player.position.x, y: player.position.y, z: player.position.z } : null,
                timestamp: Date.now()
            };
            localStorage.setItem(`pepequest_slot_${currentSaveSlot}`, JSON.stringify(saveData));
        }

        // Función obsoleta - ahora se usa el sistema de slots
        function loadAutoSave() {
            return false;
        }

        // Sistema de slots de guardado
        function showSaveMenu() {
            updateSaveSlots();
            document.getElementById('save-menu').style.display = 'block';
        }

        function updateSaveSlots() {
            const container = document.getElementById('save-slots');
            container.innerHTML = '<h4>Partidas Guardadas:</h4>';

            for (let i = 0; i < 3; i++) {
                const saved = localStorage.getItem(`pepequest_slot_${i}`);
                const slotDiv = document.createElement('div');
                const isCurrentSlot = i === currentSaveSlot;
                slotDiv.style.cssText = `margin: 10px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 5px; ${isCurrentSlot ? 'border: 2px solid #4CAF50;' : ''}`;

                if (saved) {
                    const data = JSON.parse(saved);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Nivel ${data.playerLevel || 1} ${isCurrentSlot ? '(Actual)' : ''}</div>
                        <div style="font-size: 12px; color: #ccc; margin: 5px 0;">${date}</div>
                        <div style="margin-top: 10px;">
                            <button onclick="loadSlot(${i})" style="margin: 5px; padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Cargar</button>
                            ${gameActive ? `<button onclick="saveSlot(${i})" style="margin: 5px; padding: 8px 15px; background: #2196F3; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Sobrescribir</button>` : ''}
                        </div>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Vacío</div>
                        ${gameActive ? `<button onclick="saveSlot(${i})" style="margin: 10px 5px 5px 0; padding: 8px 15px; background: #2196F3; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Guardar</button>` : ''}
                    `;
                }
                container.appendChild(slotDiv);
            }
        }

        function saveSlot(slot) {
            const saveData = {
                playerHealth, score, kills, crystalsFound, playerLevel, playerXP,
                inventory, achievements, gameTime, playerStats,
                position: player ? { x: player.position.x, y: player.position.y, z: player.position.z } : null,
                timestamp: Date.now()
            };
            localStorage.setItem(`pepequest_slot_${slot}`, JSON.stringify(saveData));
            showNotification(`Guardado en Slot ${slot + 1}`, 2000);
            updateSaveSlots();
        }

        function loadSlot(slot) {
            const saved = localStorage.getItem(`pepequest_slot_${slot}`);
            if (!saved) return;

            try {
                const data = JSON.parse(saved);
                currentSaveSlot = slot;
                playerHealth = data.playerHealth || 100;
                score = data.score || 0;
                kills = data.kills || 0;
                crystalsFound = data.crystalsFound || 0;
                playerLevel = data.playerLevel || 1;
                playerXP = data.playerXP || 0;
                inventory = data.inventory || inventory;
                achievements = data.achievements || [];
                gameTime = data.gameTime || 0;
                playerStats = data.playerStats || playerStats;

                if (!gameStarted) {
                    init();
                    gameStarted = true;
                    setTimeout(() => {
                        if (data.position && player) {
                            player.position.set(data.position.x, data.position.y, data.position.z);
                        }
                    }, 100);
                } else if (data.position && player) {
                    player.position.set(data.position.x, data.position.y, data.position.z);
                }

                gameActive = true;
                gamePaused = false;
                document.getElementById('main-menu').style.display = 'none';
                updateUI();
                updateInventoryUI();
                showNotification(`Cargado Slot ${slot + 1}`, 2000);
                document.getElementById('save-menu').style.display = 'none';
            } catch (e) {
                showNotification('Error al cargar', 2000);
            }
        }

        // Cerrar menú de guardado
        document.getElementById('close-save').addEventListener('click', () => {
            document.getElementById('save-menu').style.display = 'none';
        });

        // Botón de guardado rápido para móvil (se añade después de detectar móvil)
        function addMobileSaveButton() {
            if (!isMobile) return;
            const mobileControls = document.getElementById('mobile-controls');
            if (!mobileControls) return;

            const saveBtn = document.createElement('button');
            saveBtn.innerHTML = '💾';
            saveBtn.style.cssText = 'position: absolute; right: -260px; bottom: 0; width: 50px; height: 50px; background: #673AB7; color: white; border: none; border-radius: 50%; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;';
            saveBtn.addEventListener('touchstart', (e) => {
                if (gameActive) saveSlot(currentSaveSlot || 0);
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });
            saveBtn.addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
            });
            mobileControls.appendChild(saveBtn);
        }

        // Auto-guardado cada 30 segundos
        setInterval(autoSave, 30000);

        // Funciones específicas para Android
        function addAndroidQuickSettings() {
            const quickBtn = document.createElement('button');
            quickBtn.innerHTML = '⚙️';
            quickBtn.style.cssText = 'position: fixed; top: 80px; right: 20px; width: 50px; height: 50px; background: rgba(0,0,0,0.7); color: white; border: 2px solid white; border-radius: 50%; font-size: 20px; z-index: 102; display: none;';
            quickBtn.onclick = () => {
                const menu = document.getElementById('settings-menu');
                menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
            };
            document.body.appendChild(quickBtn);
            
            if (isMobile) quickBtn.style.display = 'block';
        }
        
        function setupAndroidGestures() {
            let swipeStartX = 0, swipeStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    swipeStartX = e.touches[0].clientX;
                    swipeStartY = e.touches[0].clientY;
                }
            });
            
            document.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const deltaX = e.changedTouches[0].clientX - swipeStartX;
                    const deltaY = e.changedTouches[0].clientY - swipeStartY;
                    
                    // Gesto hacia arriba con 2 dedos = inventario
                    if (deltaY < -100 && Math.abs(deltaX) < 50) {
                        toggleInventory();
                    }
                    // Gesto hacia abajo con 2 dedos = pausa
                    else if (deltaY > 100 && Math.abs(deltaX) < 50) {
                        togglePause();
                    }
                }
            });
        }
        
        function setupAndroidNotifications() {
            // Solicitar permisos de notificación
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
        
        function showAndroidNotification(title, message) {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>'
                });
            }
        }
        
        // Configuraciones específicas por plataforma móvil
        function setupIOSSpecific() {
            // Prevenir bounce en iOS
            document.body.style.overscrollBehavior = 'none';
            
            // Configurar viewport para iOS
            const viewport = document.querySelector('meta[name=viewport]');
            if (viewport) {
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            }
            
            // Configuraciones específicas de iOS
            addMobileFeatures('iOS');
        }
        
        function setupWindowsPhoneSpecific() {
            // Configuraciones para Windows Phone
            document.body.style.msContentZooming = 'none';
            document.body.style.msTouchAction = 'manipulation';
            
            addMobileFeatures('Windows Phone');
        }
        
        function setupGenericMobileSpecific() {
            // Configuraciones para otros móviles
            addMobileFeatures('Mobile');
        }
        
        // Mejoras universales para todos los móviles
        function addMobileFeatures(platform = 'Mobile') {
            // Botón de ayuda rápida (universal)
            const helpBtn = document.createElement('button');
            helpBtn.innerHTML = '?';
            helpBtn.style.cssText = 'position: fixed; bottom: 20px; right: 80px; width: 50px; height: 50px; background: #2196F3; color: white; border: none; border-radius: 50%; font-size: 20px; z-index: 102; display: block;';
            helpBtn.onclick = () => {
                const helpText = platform === 'iOS' ? 
                    '📱 Desliza para rotar cámara\n👆 2 dedos arriba = Inventario\n👇 2 dedos abajo = Pausa\n🍎 Optimizado para iOS' :
                    platform === 'Windows Phone' ?
                    '📱 Desliza para rotar cámara\n👆 2 dedos arriba = Inventario\n👇 2 dedos abajo = Pausa\n🪟 Optimizado para Windows Phone' :
                    '📱 Desliza para rotar cámara\n👆 2 dedos arriba = Inventario\n👇 2 dedos abajo = Pausa';
                showNotification(helpText, 4000);
            };
            document.body.appendChild(helpBtn);
            
            // Modo de ahorro de batería (universal)
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    if (battery.level < 0.2) {
                        settings.shadows = 'off';
                        config.playerSpeed *= 0.8;
                        showNotification(`🔋 Modo ahorro activado (${platform})`, 3000);
                    }
                }).catch(() => {
                    // Fallback si no hay API de batería
                    console.log('Battery API no disponible en', platform);
                });
            }
            
            // Configuración de gestos (universal)
            setupMobileGestures();
            
            // Configuración de notificaciones (universal)
            setupMobileNotifications();
        }
        
        // Renombrar funciones para ser universales
        function setupMobileGestures() {
            let swipeStartX = 0, swipeStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    swipeStartX = e.touches[0].clientX;
                    swipeStartY = e.touches[0].clientY;
                }
            });
            
            document.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const deltaX = e.changedTouches[0].clientX - swipeStartX;
                    const deltaY = e.changedTouches[0].clientY - swipeStartY;
                    
                    // Gesto hacia arriba con 2 dedos = inventario
                    if (deltaY < -100 && Math.abs(deltaX) < 50) {
                        toggleInventory();
                        if (navigator.vibrate && mobileSettings.hapticFeedback) navigator.vibrate(50);
                    }
                    // Gesto hacia abajo con 2 dedos = pausa
                    else if (deltaY > 100 && Math.abs(deltaX) < 50) {
                        togglePause();
                        if (navigator.vibrate && mobileSettings.hapticFeedback) navigator.vibrate(100);
                    }
                }
            });
        }
        
        function setupMobileNotifications() {
            // Solicitar permisos de notificación (universal)
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
        
        function showMobileNotification(title, message) {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>'
                });
            }
        }

        // Inicializar cuando la página cargue
        window.addEventListener('load', () => {
            setupMenus();
            detectMobile();
            addMobileSaveButton();
        });
    </script>
</body>

</html>