<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pepe's Adventure - Versi√≥n 1.0</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #menu-container {
            display: flex;
            width: 80%;
            max-width: 900px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        #character-display {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        #character-model {
            width: 300px;
            height: 300px;
            background: rgba(50, 50, 50, 0.5);
            border-radius: 10px;
        }
        #menu-options {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 40px;
        }
        .menu-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: #4CAF50;
            text-align: center;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }
        .menu-btn {
            padding: 15px;
            margin: 10px 0;
            background: rgba(50, 50, 50, 0.7);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .menu-btn:hover {
            background: #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }
        #game-ui {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }
        #objective {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 100;
            border: 1px solid #4CAF50;
        }
        #enemy-counter {
            position: fixed;
            top: 110px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #villager-counter {
            position: fixed;
            top: 150px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        #boss-counter {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 100;
            display: none;
            border: 1px solid #ff3300;
        }
        #health-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            z-index: 100;
            border: 1px solid #333;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #00ff00);
            transition: width 0.3s;
        }
        #boss-health {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 100;
            border: 1px solid #ff3300;
        }
        #boss-health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #ff9900);
            transition: width 0.3s;
        }
        #boss-name {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff3300;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px black;
            display: none;
            z-index: 100;
        }
        #weapon-ui {
            position: fixed;
            bottom: 50px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #camera-selector {
            position: fixed;
            top: 50px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        #settings-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            width: 500px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 300;
        }
        .settings-section {
            margin-bottom: 15px;
        }
        .settings-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4CAF50;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }
        .settings-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
        }
        button, select {
            padding: 8px 12px;
            background: #333;
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #4CAF50;
        }
        input[type="range"] {
            width: 150px;
        }
        #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
            display: none;
        }
        #version-label {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            z-index: 1000;
        }
        #collision-visualizer {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        #loading-progress {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        #loading-bar {
            height: 100%;
            width: 0%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        .key-input {
            background: #444;
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            padding: 5px;
            width: 60px;
            text-align: center;
        }
        #controls-help {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
        #inventory {
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }
        #day-night-cycle {
            position: fixed;
            top: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #minimap {
            position: fixed;
            top: 120px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4CAF50;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        #quest-log {
            position: fixed;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-height: 70vh;
            overflow-y: auto;
            width: 200px;
            display: none;
            z-index: 100;
        }
        #performance-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6600;
            z-index: 1000;
            text-align: center;
            display: none;
        }
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            z-index: 100;
            padding: 10px;
            box-sizing: border-box;
        }
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: absolute;
            touch-action: manipulation;
        }
        #mobile-joystick {
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: manipulation;
        }
        #joystick-handle {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            touch-action: manipulation;
        }
        #mobile-jump {
            right: 20px;
            bottom: 20px;
        }
        #mobile-attack {
            right: 100px;
            bottom: 20px;
        }
        #mobile-block {
            right: 180px;
            bottom: 20px;
        }
        #mobile-menu {
            right: 20px;
            top: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }
        #quick-access {
            position: fixed;
            bottom: 80px;
            left: 10px;
            display: none;
            z-index: 100;
        }
        .quick-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 1px solid #4CAF50;
        }
        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 500;
            text-align: center;
            display: none;
            max-width: 80%;
        }
        #toolbar {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 10px;
            display: none;
        }
        .tool-btn {
            width: 50px;
            height: 50px;
            margin: 0 5px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 1px solid #4CAF50;
        }
        .tool-btn.active {
            background: #4CAF50;
        }
        #compass {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            display: none;
            z-index: 100;
            overflow: hidden;
        }
        #compass-direction {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: red;
            z-index: 101;
        }
        #compass-north {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: bold;
            z-index: 102;
        }
    </style>
</head>
<body>
    <div id="version-label">Pepe's Adventure - Versi√≥n 1.0</div>
    <div id="performance-notification">
        <h3 style="margin: 0; color: #ff6600;">Modo de Bajo Rendimiento Activado</h3>
        <p style="margin: 5px 0 0;">El juego se ha ajustado autom√°ticamente para mejor rendimiento</p>
    </div>

    <!-- Pantalla de carga -->
    <div id="loading-screen">
        <h1>CARGANDO MUNDO...</h1>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
    </div>

    <!-- Men√∫ Principal -->
    <div id="main-menu">
        <div id="menu-container">
            <div id="character-display">
                <div id="character-model"></div>
            </div>
            <div id="menu-options">
                <div class="menu-title">PEPE'S ADVENTURE</div>
                <button id="play-btn" class="menu-btn">JUGAR</button>
                <button id="options-btn" class="menu-btn">OPCIONES</button>
                <button id="exit-btn" class="menu-btn">SALIR</button>
            </div>
        </div>
    </div>

    <!-- UI del Juego (inicialmente oculta) -->
    <div id="game-ui">
        <div>√çtems: <span id="items">0</span></div>
        <div>Puntos: <span id="score">0</span></div>
        <div>Nivel: <span id="level">1</span></div>
    </div>
    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>RAM: <span id="memory">0</span> MB</div>
    </div>
    <div id="objective">
        <h3>OBJETIVO</h3>
        <p>Recoge √≠tems para avanzar</p>
    </div>
    <div id="enemy-counter">
        Zombies: <span id="enemy-count">0</span>
    </div>
    <div id="villager-counter">
        Aldeanos: <span id="villager-count">0</span>
    </div>
    <div id="boss-counter">
        <p>√çtems para pr√≥ximo jefe: <span id="items-to-boss">50</span></p>
    </div>
    <div id="collision-visualizer">
        Colisiones: <span id="collision-status">OFF</span>
    </div>
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    <div id="boss-health">
        <div id="boss-health-fill"></div>
    </div>
    <div id="boss-name"></div>
    <div id="weapon-ui">
        <div>Espada: <span id="sword-power">1</span></div>
        <div>Escudo: <span id="shield-power">1</span></div>
    </div>
    <div id="inventory">
        <h3>INVENTARIO</h3>
        <div id="inventory-items"></div>
    </div>
    <div id="day-night-cycle">
        Hora del d√≠a: <span id="time-display">Mediod√≠a</span>
    </div>
    <div id="minimap"></div>
    <div id="quest-log">
        <h3>MISIONES</h3>
        <div id="quests-list"></div>
    </div>
    <div id="camera-selector">
        <button id="first-person-btn">1¬™ Persona</button>
        <button id="third-person-btn">3¬™ Persona</button>
        <button id="free-camera-btn">C√°mara Libre</button>
    </div>
    <div id="controls-help">
        WASD: Movimiento | Espacio: Saltar | Click Izq: Atacar | Click Der: Bloquear | ESC: Pausa
    </div>
    <div id="pause-screen">
        <h1>JUEGO EN PAUSA</h1>
        <button id="resume-btn" class="menu-btn">Continuar</button>
        <button id="menu-btn" class="menu-btn">Men√∫ Principal</button>
        <button id="settings-btn" class="menu-btn">Configuraci√≥n</button>
    </div>
    <div id="settings-menu">
        <div class="settings-section">
            <div class="settings-title">CONFIGURACI√ìN GR√ÅFICA</div>
            <div class="settings-row">
                <label for="view-distance">Distancia de vista:</label>
                <input type="range" id="view-distance" min="1" max="8" step="1" value="3">
                <span id="view-distance-value">3</span>
            </div>
            <div class="settings-row">
                <label for="shadow-quality">Calidad de sombras:</label>
                <select id="shadow-quality">
                    <option value="low">Baja</option>
                    <option value="medium" selected>Media</option>
                    <option value="high">Alta</option>
                    <option value="ultra">Ultra</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="vegetation-density">Densidad de vegetaci√≥n:</label>
                <input type="range" id="vegetation-density" min="0" max="100" step="5" value="50">
                <span id="vegetation-density-value">50%</span>
            </div>
            <div class="settings-row">
                <label for="mountain-density">Densidad de monta√±as:</label>
                <input type="range" id="mountain-density" min="0" max="100" step="5" value="30">
                <span id="mountain-density-value">30%</span>
            </div>
            <div class="settings-row">
                <label for="show-collision">Mostrar colisiones:</label>
                <input type="checkbox" id="show-collision">
            </div>
            <div class="settings-row">
                <label for="show-minimap">Mostrar minimapa:</label>
                <input type="checkbox" id="show-minimap" checked>
            </div>
            <div class="settings-row">
                <label for="show-compass">Mostrar br√∫jula:</label>
                <input type="checkbox" id="show-compass" checked>
            </div>
        </div>
        <div class="settings-section">
            <div class="settings-title">CONFIGURACI√ìN DE CONTROLES</div>
            <div class="settings-row">
                <label for="mouse-sensitivity">Sensibilidad:</label>
                <input type="range" id="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
                <span id="mouse-sensitivity-value">1.0</span>
            </div>
            <div class="settings-row">
                <label for="move-speed">Velocidad:</label>
                <input type="range" id="move-speed" min="1" max="10" step="0.5" value="5">
                <span id="move-speed-value">5.0</span>
            </div>
            <div class="settings-row">
                <label for="forward-key">Adelante:</label>
                <input type="text" id="forward-key" class="key-input" value="w" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="backward-key">Atr√°s:</label>
                <input type="text" id="backward-key" class="key-input" value="s" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="left-key">Izquierda:</label>
                <input type="text" id="left-key" class="key-input" value="a" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="right-key">Derecha:</label>
                <input type="text" id="right-key" class="key-input" value="d" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="jump-key">Saltar:</label>
                <input type="text" id="jump-key" class="key-input" value=" " maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="sprint-key">Correr:</label>
                <input type="text" id="sprint-key" class="key-input" value="shift" maxlength="5" readonly>
            </div>
            <div class="settings-row">
                <label for="attack-key">Atacar:</label>
                <input type="text" id="attack-key" class="key-input" value="mouse0" maxlength="5" readonly>
            </div>
            <div class="settings-row">
                <label for="block-key">Bloquear:</label>
                <input type="text" id="block-key" class="key-input" value="mouse2" maxlength="5" readonly>
            </div>
            <div class="settings-row">
                <label for="inventory-key">Inventario:</label>
                <input type="text" id="inventory-key" class="key-input" value="i" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="quest-key">Misiones:</label>
                <input type="text" id="quest-key" class="key-input" value="m" maxlength="1" readonly>
            </div>
            <div class="settings-row">
                <label for="mobile-controls">Controles m√≥viles:</label>
                <input type="checkbox" id="mobile-controls-check" checked>
            </div>
        </div>
        <div class="settings-section">
            <div class="settings-title">CONFIGURACI√ìN DEL MUNDO</div>
            <div class="settings-row">
                <label for="world-size">Tama√±o del mundo:</label>
                <select id="world-size">
                    <option value="small">Peque√±o (5x5)</option>
                    <option value="medium" selected>Mediano (9x9)</option>
                    <option value="large">Grande (13x13)</option>
                </select>
            </div>
            <div class="settings-row">
                <label for="villager-count">N√∫mero de aldeanos:</label>
                <input type="range" id="villager-count" min="0" max="20" step="1" value="5">
                <span id="villager-count-value">5</span>
            </div>
            <div class="settings-row">
                <label for="enemy-count">N√∫mero de zombies:</label>
                <input type="range" id="enemy-count" min="1" max="30" step="1" value="10">
                <span id="enemy-count-value">10</span>
            </div>
            <div class="settings-row">
                <label for="random-world">Mundo aleatorio:</label>
                <input type="checkbox" id="random-world" checked>
            </div>
            <div class="settings-row">
                <label for="world-seed">Semilla del mundo:</label>
                <input type="text" id="world-seed" value="0">
                <button id="random-seed-btn">Aleatorio</button>
            </div>
            <div class="settings-row">
                <label for="day-night-cycle">Ciclo d√≠a/noche:</label>
                <input type="checkbox" id="day-night-cycle-check" checked>
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button id="apply-settings" class="menu-btn">Aplicar</button>
            <button id="close-settings" class="menu-btn">Cerrar</button>
            <button id="reset-controls" class="menu-btn">Restaurar Controles</button>
        </div>
    </div>
    <div id="game-over-screen">
        <h1 style="color: #ff0000; font-size: 48px;">GAME OVER</h1>
        <p id="final-score" style="font-size: 24px;">Puntuaci√≥n final: 0</p>
        <button id="restart-btn" class="menu-btn">Reintentar</button>
        <button id="main-menu-btn" class="menu-btn">Men√∫ Principal</button>
    </div>

    <!-- Controles m√≥viles -->
    <div id="mobile-controls">
        <div id="mobile-joystick">
            <div id="joystick-handle"></div>
        </div>
        <div id="mobile-jump" class="mobile-btn">‚Üë</div>
        <div id="mobile-attack" class="mobile-btn">‚öîÔ∏è</div>
        <div id="mobile-block" class="mobile-btn">üõ°Ô∏è</div>
        <div id="mobile-menu" class="mobile-btn">‚ò∞</div>
    </div>

    <!-- Barra de herramientas -->
    <div id="toolbar">
        <div class="tool-btn" id="tool-inventory">üéí</div>
        <div class="tool-btn" id="tool-quests">üìú</div>
        <div class="tool-btn" id="tool-map">üó∫Ô∏è</div>
        <div class="tool-btn" id="tool-camera">üì∑</div>
    </div>

    <!-- Br√∫jula -->
    <div id="compass">
        <div id="compass-direction"></div>
        <div id="compass-north">N</div>
    </div>

    <!-- Notificaci√≥n -->
    <div id="notification"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // Configuraci√≥n del juego
        const CONFIG = {
            CHUNK_SIZE: 32,
            VIEW_DISTANCE: 3,
            WORLD_SIZE: 9,
            PLAYER_SPEED: 5,
            ITEMS_PER_BOSS: 50,
            PLAYER_HEALTH: 100,
            BOSS_HEALTH: 500,
            ITEM_TYPES: [
                { color: 0xff0000, points: 10, size: 0.8, name: "Rub√≠", texture: null },       // Rojo - Alto valor
                { color: 0x00ff00, points: 5, size: 0.6, name: "Esmeralda", texture: null },   // Verde - Medio valor
                { color: 0x0000ff, points: 2, size: 0.4, name: "Zafiro", texture: null },      // Azul - Bajo valor
                { color: 0xffff00, points: 20, size: 1.0, name: "Topacio", texture: null },    // Amarillo - Especial
                { color: 0xff00ff, points: 15, size: 0.7, name: "Amatista", texture: null }    // Magenta - Raro
            ],
            VEGETATION_DENSITY: 50,
            MOUNTAIN_DENSITY: 30,
            ENEMY_COUNT: 10,
            ENEMY_SPEED: 3.5,
            ENEMY_DAMAGE: 5,
            ENEMY_DETECTION_RANGE: 15,
            ENEMY_ATTACK_RANGE: 2,
            VILLAGER_COUNT: 5,
            VILLAGER_SPEED: 1.5,
            JUMP_FORCE: 8,
            GRAVITY: 20,
            COLLISION_OFFSET: 0.5,
            MOUSE_SENSITIVITY: 1.0,
            BLOCK_SIZE: 1, // Tama√±o de los bloques del terreno
            DAY_LENGTH: 300, // Segundos para un ciclo d√≠a/noche completo
            INVENTORY_SIZE: 10,
            QUESTS: [
                { id: 1, name: "Primeros pasos", description: "Recoge 5 √≠tems", goal: 5, reward: 50, completed: false },
                { id: 2, name: "Defensor del pueblo", description: "Derrota 3 zombies", goal: 3, reward: 100, completed: false },
                { id: 3, name: "Coleccionista", description: "Recoge 20 √≠tems", goal: 20, reward: 200, completed: false }
            ],
            TEXTURES: {
                grass: null,
                dirt: null,
                stone: null,
                wood: null,
                leaves: null
            }
        };

        // Variables globales
        let scene, camera, renderer, controls, clock;
        let character, mixer, animations = {};
        let chunks = {}, activeChunks = [];
        let items = [];
        let enemies = [];
        let villagers = [];
        let obstacles = [];
        let mountains = [];
        let trees = [];
        let collectedItems = 0;
        let score = 0;
        let level = 1;
        let currentSpeed = CONFIG.PLAYER_SPEED;
        let isWalking = false;
        let gamePaused = false;
        let gameActive = false;
        let stats = { lastTime: 0, frames: 0, fps: 0, memory: 0 };
        let currentConfig = { ...CONFIG };
        let playerHealth = CONFIG.PLAYER_HEALTH;
        let boss = null;
        let bossHealth = 0;
        let swordPower = 1;
        let shieldPower = 1;
        let cameraMode = 'third-person'; // 'first-person', 'third-person', 'free'
        let characterControls = {
            forward: false, backward: false, left: false, right: false,
            sprint: false, jump: false, attack: false, block: false
        };
        let cameraDistance = 5;
        let cameraAngle = 0;
        let velocityY = 0;
        let isJumping = false;
        let isGrounded = false;
        let isAttacking = false;
        let attackTime = 0;
        let keyBindings = {
            forward: 'w',
            backward: 's',
            left: 'a',
            right: 'd',
            jump: ' ',
            sprint: 'shift',
            attack: 'mouse0',
            block: 'mouse2',
            inventory: 'i',
            quests: 'm'
        };
        let changingKey = null;
        let showCollision = false;
        let showMinimap = true;
        let showCompass = true;
        let randomSeed = Math.floor(Math.random() * 1000000);
        let worldGenerated = false;
        let loadingProgress = 0;
        let loadingTotal = 0;
        let loadingCurrent = 0;
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let dayNightCycleEnabled = true;
        let dayTime = 0; // 0-1, donde 0 es medianoche, 0.5 es mediod√≠a
        let inventory = [];
        let activeQuests = JSON.parse(JSON.stringify(CONFIG.QUESTS));
        let completedQuests = [];
        let enemiesDefeated = 0;
        let isMobile = false;
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickDistance = 0;
        const noise = new SimplexNoise();

        // Texturas precargadas
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // Texturas b√°sicas
            CONFIG.TEXTURES.grass = textureLoader.load('https://threejs.org/examples/textures/terrain/grass.jpg');
            CONFIG.TEXTURES.grass.wrapS = CONFIG.TEXTURES.grass.wrapT = THREE.RepeatWrapping;
            CONFIG.TEXTURES.grass.repeat.set(4, 4);
            
            CONFIG.TEXTURES.dirt = textureLoader.load('https://threejs.org/examples/textures/terrain/dirt.jpg');
            CONFIG.TEXTURES.dirt.wrapS = CONFIG.TEXTURES.dirt.wrapT = THREE.RepeatWrapping;
            CONFIG.TEXTURES.dirt.repeat.set(4, 4);
            
            CONFIG.TEXTURES.stone = textureLoader.load('https://threejs.org/examples/textures/stone.jpg');
            CONFIG.TEXTURES.stone.wrapS = CONFIG.TEXTURES.stone.wrapT = THREE.RepeatWrapping;
            CONFIG.TEXTURES.stone.repeat.set(1, 1);
            
            CONFIG.TEXTURES.wood = textureLoader.load('https://threejs.org/examples/textures/wood.jpg');
            CONFIG.TEXTURES.wood.wrapS = CONFIG.TEXTURES.wood.wrapT = THREE.RepeatWrapping;
            
            CONFIG.TEXTURES.leaves = textureLoader.load('https://threejs.org/examples/textures/leaves.jpg');
            CONFIG.TEXTURES.leaves.wrapS = CONFIG.TEXTURES.leaves.wrapT = THREE.RepeatWrapping;
            
            // Texturas para √≠tems
            CONFIG.ITEM_TYPES[0].texture = textureLoader.load('https://threejs.org/examples/textures/gem/ruby.png');
            CONFIG.ITEM_TYPES[1].texture = textureLoader.load('https://threejs.org/examples/textures/gem/emerald.png');
            CONFIG.ITEM_TYPES[2].texture = textureLoader.load('https://threejs.org/examples/textures/gem/sapphire.png');
            CONFIG.ITEM_TYPES[3].texture = textureLoader.load('https://threejs.org/examples/textures/gem/topaz.png');
            CONFIG.ITEM_TYPES[4].texture = textureLoader.load('https://threejs.org/examples/textures/gem/amethyst.png');
        }

        // Inicializar el juego
        async function init() {
            try {
                // Detectar si es m√≥vil
                isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
                
                setupScene();
                setupCamera();
                setupRenderer();
                loadTextures(); // Cargar texturas antes de crear el mundo
                setupPerformanceMode();
                setupLights();
                await createCharacter();
                setupCameraControls();
                setupUIEvents();
                setupPauseSystem();
                setupMobileControls();
                
                // Mostrar pantalla de carga mientras se genera el mundo
                document.getElementById('loading-screen').style.display = 'flex';
                
                // Generar el mundo
                preloadWorld();
                
                clock = new THREE.Clock();
                stats.lastTime = performance.now();
                animate();
            } catch (error) {
                console.error("Error inicializando el juego:", error);
                showNotification("Error al iniciar el juego. Por favor recarga la p√°gina.");
            }
        }

        // Configurar escena
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
        }

        // Configurar c√°mara
        function setupCamera() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
        }

        // Configurar renderizador optimizado
        function setupRenderer() {
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                logarithmicDepthBuffer: true
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limitar pixel ratio para m√≥viles
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; // Mejorar rendimiento en algunas configuraciones
            document.body.appendChild(renderer.domElement);
        }

        // M√≥dulo de detecci√≥n de hardware y ajuste autom√°tico
        function setupPerformanceMode() {
            const isLowEndDevice = () => {
                try {
                    // M√©todo 1: Usar performance.memory si est√° disponible (Chrome)
                    if (performance.memory) {
                        const totalJSHeapSize = performance.memory.jsHeapSizeLimit;
                        return totalJSHeapSize < 4 * 1024 * 1024 * 1024; // Menos de 4GB
                    }
                    
                    // M√©todo 2: Usar navigator.deviceMemory (disponible en algunos navegadores)
                    if (navigator.deviceMemory !== undefined) {
                        return navigator.deviceMemory < 4; // Menos de 4GB
                    }
                    
                    // M√©todo 3: Detecci√≥n por userAgent (menos preciso)
                    const userAgent = navigator.userAgent.toLowerCase();
                    const isMobile = /mobile|android|iphone|ipad|ipod/i.test(userAgent);
                    const isOldBrowser = /msie|trident|edge\s[0-9]|firefox\s[0-9]|chrome\s[0-9]|safari\s[0-9]/i.test(userAgent);
                    
                    return isMobile || isOldBrowser;
                } catch (e) {
                    console.error("Error detectando hardware:", e);
                    return false; // Por defecto asumir que no es low-end
                }
            };
            
            const applyLowEndSettings = () => {
                console.log("Aplicando configuraci√≥n para PCs de bajos recursos");
                
                // Mostrar notificaci√≥n
                document.getElementById('performance-notification').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('performance-notification').style.display = 'none';
                }, 5000);
                
                // Ajustes gr√°ficos
                document.getElementById('view-distance').value = 2;
                document.getElementById('view-distance-value').textContent = 2;
                document.getElementById('shadow-quality').value = 'low';
                document.getElementById('vegetation-density').value = 20;
                document.getElementById('vegetation-density-value').textContent = '20%';
                document.getElementById('mountain-density').value = 10;
                document.getElementById('mountain-density-value').textContent = '10%';
                document.getElementById('show-collision').checked = false;
                document.getElementById('show-minimap').checked = false;
                document.getElementById('day-night-cycle-check').checked = false;
                document.getElementById('show-compass').checked = false;
                
                // Ajustes de mundo
                document.getElementById('world-size').value = 'small';
                document.getElementById('villager-count').value = 3;
                document.getElementById('villager-count-value').textContent = 3;
                document.getElementById('enemy-count').value = 5;
                document.getElementById('enemy-count-value').textContent = 5;
                
                // Actualizar configuraci√≥n actual
                currentConfig.VIEW_DISTANCE = 2;
                currentConfig.SHADOW_QUALITY = 'low';
                currentConfig.VEGETATION_DENSITY = 20;
                currentConfig.MOUNTAIN_DENSITY = 10;
                currentConfig.WORLD_SIZE = 5;
                currentConfig.VILLAGER_COUNT = 3;
                currentConfig.ENEMY_COUNT = 5;
                currentConfig.DAY_LENGTH = 0; // Desactivar ciclo d√≠a/noche
                showCompass = false;
                
                // Aplicar cambios al renderizador si existe
                if (renderer) {
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    scene.fog.density = 0.001; // Menos niebla para mejor rendimiento
                }
            };
            
            // Verificar si es un dispositivo de bajos recursos
            if (isLowEndDevice()) {
                applyLowEndSettings();
            } else {
                console.log("Dispositivo con recursos suficientes, usando configuraci√≥n est√°ndar");
            }
        }

        // Configurar luces optimizadas
        function setupLights() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Luz direccional (sol) con sombras optimizadas
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            
            // Ajustar calidad de sombras seg√∫n configuraci√≥n
            const shadowQuality = currentConfig.SHADOW_QUALITY || 'medium';
            if (shadowQuality === 'ultra') {
                dirLight.shadow.mapSize.width = 4096;
                dirLight.shadow.mapSize.height = 4096;
            } else if (shadowQuality === 'high') {
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
            } else if (shadowQuality === 'medium') {
                dirLight.shadow.mapSize.width = 1024;
                dirLight.shadow.mapSize.height = 1024;
            } else {
                dirLight.shadow.mapSize.width = 512;
                dirLight.shadow.mapSize.height = 512;
            }
            
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);
            
            // Luz de relleno para reducir contraste
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-50, 50, -50);
            scene.add(fillLight);
        }

        // Crear personaje con mejor apariencia
        async function createCharacter() {
            character = new THREE.Group();
            
            // Cuerpo con textura
            const bodyGeometry = new THREE.BoxGeometry(0.6, 1, 0.3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3366ff,
                map: CONFIG.TEXTURES.wood
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            character.add(body);

            // Cabeza con textura de piel
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffcc99,
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            character.add(head);

            // Brazos con textura de piel
            const armGeometry = new THREE.BoxGeometry(0.15, 0.6, 0.15);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffcc99,
                roughness: 0.7
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.7, 0);
            leftArm.rotation.z = Math.PI / 2; // Posici√≥n inicial para bloqueo
            leftArm.castShadow = true;
            character.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.7, 0);
            rightArm.castShadow = true;
            character.add(rightArm);

            // Piernas con textura
            const legGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3333ff,
                map: CONFIG.TEXTURES.wood
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0, 0);
            leftLeg.castShadow = true;
            character.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0, 0);
            rightLeg.castShadow = true;
            character.add(rightLeg);
            
            // Espada con textura met√°lica
            const swordGeometry = new THREE.BoxGeometry(0.05, 0.8, 0.05);
            const swordMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                metalness: 0.8,
                roughness: 0.2
            });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.position.set(0.5, 0.7, 0);
            sword.rotation.z = Math.PI / 2;
            sword.visible = false;
            character.add(sword);
            
            // Escudo con textura de madera y metal
            const shieldGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16);
            const shieldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                map: CONFIG.TEXTURES.wood,
                metalness: 0.3,
                roughness: 0.7
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.set(-0.5, 0.7, 0);
            shield.rotation.z = Math.PI / 2;
            shield.visible = false;
            character.add(shield);
            
            scene.add(character);
            character.position.set(0, 0, 0);
            character.castShadow = true;

            // Guardar referencias para animaci√≥n
            animations.parts = {
                leftArm, rightArm,
                leftLeg, rightLeg,
                head, sword, shield
            };
        }

        // Configurar controles de c√°mara mejorados
        function setupCameraControls() {
            // Eliminar controles anteriores si existen
            if (controls) {
                controls.dispose();
            }

            // Configurar eventos de rat√≥n para rotaci√≥n
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (event.button === 0 && cameraMode !== 'free') {
                    isDragging = true;
                    previousMouseX = event.clientX;
                    previousMouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isDragging && gameActive && !gamePaused) {
                    const deltaX = event.clientX - previousMouseX;
                    const deltaY = event.clientY - previousMouseY;
                    
                    if (cameraMode === 'third-person') {
                        // Rotaci√≥n horizontal
                        cameraAngle -= deltaX * 0.005 * currentConfig.MOUSE_SENSITIVITY;
                        
                        // Rotaci√≥n vertical (limitada)
                        cameraDistance = Math.max(3, Math.min(10, cameraDistance - deltaY * 0.05));
                    } else if (cameraMode === 'first-person') {
                        // Rotaci√≥n del personaje
                        character.rotation.y -= deltaX * 0.005 * currentConfig.MOUSE_SENSITIVITY;
                        
                        // Inclinar la cabeza (limitado)
                        const head = animations.parts?.head;
                        if (head) {
                            head.rotation.x = THREE.MathUtils.clamp(
                                head.rotation.x - deltaY * 0.002 * currentConfig.MOUSE_SENSITIVITY,
                                -Math.PI/4, Math.PI/4
                            );
                        }
                    }
                    
                    previousMouseX = event.clientX;
                    previousMouseY = event.clientY;
                    updateCameraPosition();
                }
            });

            // Configurar rueda del rat√≥n para zoom
            renderer.domElement.addEventListener('wheel', (event) => {
                if (cameraMode === 'third-person') {
                    cameraDistance = THREE.MathUtils.clamp(
                        cameraDistance - event.deltaY * 0.01,
                        3, 10
                    );
                    updateCameraPosition();
                }
            });
        }

        // Configurar controles m√≥viles
        function setupMobileControls() {
            if (!isMobile) return;
            
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex';
            
            const joystick = document.getElementById('mobile-joystick');
            const handle = document.getElementById('joystick-handle');
            const jumpBtn = document.getElementById('mobile-jump');
            const attackBtn = document.getElementById('mobile-attack');
            const blockBtn = document.getElementById('mobile-block');
            const menuBtn = document.getElementById('mobile-menu');
            
            let touchId = null;
            
            // Joystick t√°ctil
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchId !== null) return;
                
                const touch = e.touches[0];
                touchId = touch.identifier;
                joystickActive = true;
            });
            
            document.addEventListener('touchmove', (e) => {
                if (touchId === null) return;
                
                const touch = Array.from(e.touches).find(t => t.identifier === touchId);
                if (!touch) return;
                
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                joystickDistance = distance / 40;
                
                if (distance > 5) {
                    joystickAngle = Math.atan2(deltaY, deltaX);
                    
                    // Mover el handle visualmente
                    const angle = joystickAngle;
                    const maxDistance = 30;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    
                    handle.style.transform = `translate(${x}px, ${y}px)`;
                    
                    // Actualizar controles del personaje
                    characterControls.forward = false;
                    characterControls.backward = false;
                    characterControls.left = false;
                    characterControls.right = false;
                    
                    if (joystickAngle > -Math.PI/4 && joystickAngle < Math.PI/4) {
                        characterControls.right = true;
                    } else if (joystickAngle > Math.PI/4 && joystickAngle < 3*Math.PI/4) {
                        characterControls.backward = true;
                    } else if (joystickAngle > 3*Math.PI/4 || joystickAngle < -3*Math.PI/4) {
                        characterControls.left = true;
                    } else {
                        characterControls.forward = true;
                    }
                }
            });
            
            document.addEventListener('touchend', (e) => {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
                if (!touch) return;
                
                touchId = null;
                joystickActive = false;
                joystickDistance = 0;
                handle.style.transform = 'translate(0, 0)';
                
                characterControls.forward = false;
                characterControls.backward = false;
                characterControls.left = false;
                characterControls.right = false;
            });
            
            // Botones t√°ctiles
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isGrounded) {
                    characterControls.jump = true;
                    velocityY = currentConfig.JUMP_FORCE;
                    isGrounded = false;
                    isJumping = true;
                }
            });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                characterControls.jump = false;
            });
            
            attackBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                characterControls.attack = true;
            });
            
            attackBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                characterControls.attack = false;
            });
            
            blockBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                characterControls.block = true;
            });
            
            blockBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                characterControls.block = false;
            });
            
            menuBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                togglePause();
            });
            
            // Configurar botones de la barra de herramientas
            document.getElementById('tool-inventory').addEventListener('click', () => {
                document.getElementById('inventory').style.display = 
                    document.getElementById('inventory').style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('tool-quests').addEventListener('click', () => {
                document.getElementById('quest-log').style.display = 
                    document.getElementById('quest-log').style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('tool-map').addEventListener('click', () => {
                document.getElementById('minimap').style.display = 
                    document.getElementById('minimap').style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('tool-camera').addEventListener('click', () => {
                document.getElementById('camera-selector').style.display = 
                    document.getElementById('camera-selector').style.display === 'none' ? 'block' : 'none';
            });
        }

        // Actualizar posici√≥n de la c√°mara
        function updateCameraPosition() {
            if (!character) return;
            
            switch (cameraMode) {
                case 'first-person':
                    camera.position.copy(character.position);
                    camera.position.y += 1.6; // Altura de los ojos
                    camera.rotation.copy(character.rotation);
                    
                    // Aplicar rotaci√≥n de la cabeza
                    const head = animations.parts?.head;
                    if (head) {
                        camera.rotation.x += head.rotation.x;
                    }
                    break;
                    
                case 'third-person':
                    // Calcular posici√≥n orbital
                    const horizontalDistance = cameraDistance * Math.cos(Math.PI/4);
                    const verticalDistance = cameraDistance * Math.sin(Math.PI/4);
                    
                    const offset = new THREE.Vector3(
                        Math.sin(cameraAngle) * horizontalDistance,
                        verticalDistance,
                        Math.cos(cameraAngle) * horizontalDistance
                    );
                    
                    camera.position.copy(character.position).add(offset);
                    camera.lookAt(character.position.x, character.position.y + 1, character.position.z);
                    break;
                    
                case 'free':
                    // C√°mara libre (controlada por OrbitControls)
                    if (!controls) {
                        controls = new THREE.OrbitControls(camera, renderer.domElement);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.screenSpacePanning = false;
                        controls.maxPolarAngle = Math.PI * 0.9;
                        controls.minDistance = 5;
                        controls.maxDistance = 50;
                        controls.target.set(0, 1, 0);
                    }
                    controls.update();
                    break;
            }
            
            // Actualizar br√∫jula
            updateCompass();
        }

        // Actualizar br√∫jula
        function updateCompass() {
            if (!showCompass) return;
            
            const direction = character.rotation.y;
            const compass = document.getElementById('compass-direction');
            compass.style.transform = `translateX(${Math.sin(-direction) * 75}px)`;
            
            document.getElementById('compass-north').style.transform = `translateX(${Math.sin(-direction) * 75}px)`;
        }

        // Precargar el mundo con mejores texturas
        function preloadWorld() {
            try {
                document.getElementById('loading-screen').style.display = 'flex';
                loadingProgress = 0;
                loadingCurrent = 0;

                // Limpieza de objetos previos
                [enemies, villagers, items, obstacles, mountains, trees].forEach(arr => {
                    arr.forEach(obj => {
                        if (obj?.parent) scene.remove(obj);
                    });
                    arr.length = 0;
                });

                // Limpiar chunks
                Object.values(chunks).forEach(chunk => {
                    if (chunk?.parent) scene.remove(chunk);
                });
                chunks = {};
                activeChunks = [];

                // Actualizar configuraci√≥n desde los controles UI
                currentConfig.ENEMY_COUNT = parseInt(document.getElementById('enemy-count').value) || CONFIG.ENEMY_COUNT;
                currentConfig.VILLAGER_COUNT = parseInt(document.getElementById('villager-count').value) || CONFIG.VILLAGER_COUNT;
                currentConfig.VIEW_DISTANCE = parseInt(document.getElementById('view-distance').value) || CONFIG.VIEW_DISTANCE;
                currentConfig.VEGETATION_DENSITY = parseInt(document.getElementById('vegetation-density').value) || CONFIG.VEGETATION_DENSITY;
                currentConfig.MOUNTAIN_DENSITY = parseInt(document.getElementById('mountain-density').value) || CONFIG.MOUNTAIN_DENSITY;
                currentConfig.MOUSE_SENSITIVITY = parseFloat(document.getElementById('mouse-sensitivity').value) || CONFIG.MOUSE_SENSITIVITY;
                currentConfig.PLAYER_SPEED = parseFloat(document.getElementById('move-speed').value) || CONFIG.PLAYER_SPEED;
                showCompass = document.getElementById('show-compass').checked;
                
                // Configurar semilla del mundo
                if (document.getElementById('random-world').checked) {
                    randomSeed = Math.floor(Math.random() * 1000000);
                } else {
                    randomSeed = parseInt(document.getElementById('world-seed').value) || 0;
                }
                document.getElementById('world-seed').value = randomSeed;

                // Configurar tama√±o del mundo
                const worldSize = document.getElementById('world-size').value;
                switch (worldSize) {
                    case 'small': currentConfig.WORLD_SIZE = 5; break;
                    case 'large': currentConfig.WORLD_SIZE = 13; break;
                    default: currentConfig.WORLD_SIZE = 9;
                }

                // Configurar ciclo d√≠a/noche
                dayNightCycleEnabled = document.getElementById('day-night-cycle-check').checked;

                // Generar chunks iniciales
                loadingTotal = currentConfig.WORLD_SIZE * currentConfig.WORLD_SIZE;
                
                // Generar el mundo en chunks
                const halfSize = Math.floor(currentConfig.WORLD_SIZE / 2);
                for (let x = -halfSize; x <= halfSize; x++) {
                    for (let z = -halfSize; z <= halfSize; z++) {
                        loadChunk(x, z).then(() => {
                            // Cuando todos los chunks est√©n cargados, ocultar la barra de carga
                            loadingCurrent++;
                            loadingProgress = Math.floor((loadingCurrent / loadingTotal) * 100);
                            document.getElementById('loading-bar').style.width = `${loadingProgress}%`;
                            
                            if (loadingCurrent >= loadingTotal) {
                                document.getElementById('loading-screen').style.display = 'none';
                                worldGenerated = true;
                                
                                // Generar enemigos y aldeanos despu√©s de que el mundo est√© listo
                                for (let i = 0; i < currentConfig.ENEMY_COUNT; i++) {
                                    createEnemy();
                                }
                                for (let i = 0; i < currentConfig.VILLAGER_COUNT; i++) {
                                    createVillager();
                                }
                                generateItems(30);
                                
                                // Iniciar ciclo d√≠a/noche
                                dayTime = 0.5; // Comenzar al mediod√≠a
                                updateDayNightCycle();
                                
                                // Mostrar br√∫jula si est√° activada
                                document.getElementById('compass').style.display = 
                                    showCompass ? 'block' : 'none';
                            }
                        }).catch(error => {
                            console.error("Error cargando chunk:", error);
                        });
                    }
                }
            } catch (error) {
                console.error("Error generando mundo:", error);
                showNotification("Error al generar el mundo. Intenta otra semilla.");
                document.getElementById('loading-screen').style.display = 'none';
                showMainMenu();
            }
        }

        // Nuevo sistema de generaci√≥n de chunks con mejores texturas
        function loadChunk(x, z) {
            return new Promise((resolve) => {
                const chunkKey = `${x},${z}`;
                if (chunks[chunkKey]) { resolve(); return; }
                
                const chunk = new THREE.Group();
                chunk.position.set(x * currentConfig.CHUNK_SIZE, 0, z * currentConfig.CHUNK_SIZE);
                chunk.userData = { x, z };

                // Generar terreno con bloques y texturas
                const blockSize = currentConfig.BLOCK_SIZE;
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    map: CONFIG.TEXTURES.grass,
                    side: THREE.DoubleSide,
                    roughness: 0.8
                });

                const dirtMaterial = new THREE.MeshStandardMaterial({ 
                    map: CONFIG.TEXTURES.dirt,
                    side: THREE.DoubleSide,
                    roughness: 0.9
                });

                // Crear una base s√≥lida de bloques con diferentes materiales seg√∫n la altura
                for (let bx = 0; bx < currentConfig.CHUNK_SIZE; bx += blockSize) {
                    for (let bz = 0; bz < currentConfig.CHUNK_SIZE; bz += blockSize) {
                        // Usar ruido para determinar la altura
                        const worldX = x * currentConfig.CHUNK_SIZE + bx;
                        const worldZ = z * currentConfig.CHUNK_SIZE + bz;
                        const height = Math.floor(getNoiseHeight(worldX, worldZ));
                        
                        // Crear bloques desde la base hasta la altura determinada
                        for (let y = 0; y <= height; y += blockSize) {
                            const isTop = y === height;
                            const material = isTop ? groundMaterial : dirtMaterial;
                            
                            const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                            const block = new THREE.Mesh(blockGeometry, material);
                            
                            // Variar ligeramente la posici√≥n para un terreno m√°s org√°nico
                            const offsetX = (Math.random() - 0.5) * 0.1;
                            const offsetZ = (Math.random() - 0.5) * 0.1;
                            
                            block.position.set(
                                bx - currentConfig.CHUNK_SIZE/2 + blockSize/2 + offsetX,
                                y + blockSize/2,
                                bz - currentConfig.CHUNK_SIZE/2 + blockSize/2 + offsetZ
                            );
                            
                            // Rotaci√≥n aleatoria para variedad visual
                            block.rotation.y = Math.random() * Math.PI;
                            
                            block.castShadow = true;
                            block.receiveShadow = true;
                            chunk.add(block);
                            
                            // Marcar como obst√°culo si es el bloque superior
                            if (isTop) {
                                obstacles.push(block);
                                
                                // A√±adir vegetaci√≥n ocasionalmente
                                if (Math.random() * 100 < currentConfig.VEGETATION_DENSITY / 2) {
                                    createGrass(block.position.x, block.position.y + blockSize/2, block.position.z, chunk);
                                }
                            }
                        }
                    }
                }

                // A√±adir monta√±as con textura de piedra
                if (Math.random() * 100 < currentConfig.MOUNTAIN_DENSITY) {
                    const mountainHeight = 5 + Math.floor(Math.random() * 10);
                    const mountainRadius = 3 + Math.floor(Math.random() * 3);
                    const centerX = (Math.random() - 0.5) * currentConfig.CHUNK_SIZE * 0.8;
                    const centerZ = (Math.random() - 0.5) * currentConfig.CHUNK_SIZE * 0.8;
                    
                    const stoneMaterial = new THREE.MeshStandardMaterial({ 
                        map: CONFIG.TEXTURES.stone,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    for (let h = 0; h < mountainHeight; h++) {
                        const layerRadius = mountainRadius * (1 - h/mountainHeight);
                        const blocksInLayer = Math.max(1, Math.floor(2 * Math.PI * layerRadius));
                        
                        for (let i = 0; i < blocksInLayer; i++) {
                            const angle = (i / blocksInLayer) * Math.PI * 2;
                            const distance = layerRadius * (0.8 + Math.random() * 0.4);
                            
                            const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                            const block = new THREE.Mesh(blockGeometry, stoneMaterial);
                            
                            block.position.set(
                                centerX + Math.cos(angle) * distance,
                                h * blockSize + blockSize/2,
                                centerZ + Math.sin(angle) * distance
                            );
                            
                            block.castShadow = true;
                            block.receiveShadow = true;
                            chunk.add(block);
                            mountains.push(block);
                            obstacles.push(block);
                        }
                    }
                }

                scene.add(chunk);
                chunks[chunkKey] = chunk;
                resolve();
            });
        }

        // Crear hierba y vegetaci√≥n
        function createGrass(x, y, z, chunk) {
            // Base de hierba
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4CAF50,
                side: THREE.DoubleSide
            });
            
            const grassHeight = 0.3 + Math.random() * 0.5;
            const grassGeometry = new THREE.ConeGeometry(0.2, grassHeight, 4);
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            
            grass.position.set(x, y + grassHeight/2, z);
            grass.rotation.y = Math.random() * Math.PI;
            chunk.add(grass);
            
            // Flores ocasionales
            if (Math.random() > 0.7) {
                const flowerColor = new THREE.Color(
                    Math.random() * 0.5 + 0.5,
                    Math.random() * 0.3,
                    Math.random() * 0.5 + 0.5
                );
                
                const flowerMaterial = new THREE.MeshStandardMaterial({ 
                    color: flowerColor,
                    side: THREE.DoubleSide
                });
                
                const flowerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                
                flower.position.set(
                    x + (Math.random() - 0.5) * 0.3,
                    y + grassHeight + 0.1,
                    z + (Math.random() - 0.5) * 0.3
                );
                
                chunk.add(flower);
            }
            
            // √Årboles ocasionales
            if (Math.random() * 100 < currentConfig.VEGETATION_DENSITY / 10) {
                createTree(x, y, z, chunk);
            }
        }

        // Crear un √°rbol
        function createTree(x, y, z, chunk) {
            const treeGroup = new THREE.Group();
            treeGroup.position.set(x, y, z);
            
            // Tronco
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                map: CONFIG.TEXTURES.wood,
                roughness: 0.8
            });
            
            const trunkHeight = 2 + Math.random() * 1;
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // Hojas
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                map: CONFIG.TEXTURES.leaves,
                color: 0x4CAF50,
                transparent: true,
                alphaTest: 0.5
            });
            
            const leavesSize = 1.5 + Math.random() * 0.5;
            const leavesGeometry = new THREE.SphereGeometry(leavesSize, 8, 8);
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = trunkHeight + leavesSize * 0.7;
            leaves.castShadow = true;
            treeGroup.add(leaves);
            
            chunk.add(treeGroup);
            trees.push(treeGroup);
            obstacles.push(treeGroup);
        }

        // Funci√≥n de ruido para altura del terreno mejorada
        function getNoiseHeight(x, z) {
            let height = 0;
            let frequency = 0.02;
            let amplitude = 3;
            
            for(let i = 0; i < 5; i++) {
                height += noise.noise2D(
                    (x + randomSeed) * frequency,
                    (z + randomSeed) * frequency
                ) * amplitude;
                
                frequency *= 2;
                amplitude *= 0.5;
            }
            
            // Suavizar el terreno
            height = Math.pow(height, 2) * Math.sign(height);
            
            // Asegurar que la altura sea al menos 1 bloque
            return Math.max(1, Math.floor(height));
        }

        // Crear un enemigo (zombie) con mejor apariencia
        function createEnemy(x, z) {
            const enemy = new THREE.Group();
            
            // Cuerpo del enemigo con textura
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.9
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            enemy.add(body);
            
            // Cabeza con textura
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcc0000,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            enemy.add(head);
            
            // Brazos con textura
            const armGeometry = new THREE.BoxGeometry(0.15, 0.7, 0.15);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.9
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.7, 0);
            enemy.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.7, 0);
            enemy.add(rightArm);
            
            // Piernas con textura
            const legGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x660000,
                roughness: 0.9
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0, 0);
            enemy.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0, 0);
            enemy.add(rightLeg);
            
            // Posicionar en un lugar aleatorio si no se especifican coordenadas
            const worldLimit = (currentConfig.WORLD_SIZE * currentConfig.CHUNK_SIZE) / 2 - 5;
            if (x === undefined || z === undefined) {
                x = (Math.random() - 0.5) * worldLimit * 2;
                z = (Math.random() - 0.5) * worldLimit * 2;
            }
            
            enemy.position.set(x, 0, z);
            
            // Configurar propiedades del enemigo
            enemy.userData = {
                health: 30,
                speed: currentConfig.ENEMY_SPEED,
                detectionRange: currentConfig.ENEMY_DETECTION_RANGE,
                attackRange: currentConfig.ENEMY_ATTACK_RANGE,
                damage: currentConfig.ENEMY_DAMAGE,
                attackCooldown: 0,
                direction: new THREE.Vector3(
                    Math.random() * 2 - 1,
                    0,
                    Math.random() * 2 - 1
                ).normalize(),
                changeDirectionTime: 0,
                parts: { leftArm, rightArm, leftLeg, rightLeg, head },
                type: 'enemy'
            };
            
            scene.add(enemy);
            enemies.push(enemy);
            
            return enemy;
        }

        // Crear un aldeano con mejor apariencia
        function createVillager(x, z) {
            const villager = new THREE.Group();
            
            // Cuerpo del aldeano con textura
            const bodyGeometry = new THREE.BoxGeometry(0.7, 1.1, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3366ff,
                map: CONFIG.TEXTURES.wood,
                roughness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.55;
            body.castShadow = true;
            villager.add(body);
            
            // Cabeza con textura de piel
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffcc99,
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.3;
            villager.add(head);
            
            // Brazos con textura de piel
            const armGeometry = new THREE.BoxGeometry(0.12, 0.6, 0.12);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffcc99,
                roughness: 0.7
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.6, 0);
            villager.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.6, 0);
            villager.add(rightArm);
            
            // Piernas con textura
            const legGeometry = new THREE.BoxGeometry(0.18, 0.6, 0.18);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3333ff,
                map: CONFIG.TEXTURES.wood,
                roughness: 0.8
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0, 0);
            villager.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0, 0);
            villager.add(rightLeg);
            
            // Posicionar en un lugar aleatorio si no se especifican coordenadas
            const worldLimit = (currentConfig.WORLD_SIZE * currentConfig.CHUNK_SIZE) / 2 - 5;
            if (x === undefined || z === undefined) {
                x = (Math.random() - 0.5) * worldLimit * 2;
                z = (Math.random() - 0.5) * worldLimit * 2;
            }
            
            villager.position.set(x, 0, z);
            
            // Configurar propiedades del aldeano
            villager.userData = {
                speed: currentConfig.VILLAGER_SPEED,
                direction: new THREE.Vector3(
                    Math.random() * 2 - 1,
                    0,
                    Math.random() * 2 - 1
                ).normalize(),
                changeDirectionTime: 0,
                homePosition: new THREE.Vector3(x, 0, z),
                wanderRange: 10 + Math.random() * 10,
                parts: { leftArm, rightArm, leftLeg, rightLeg, head },
                type: 'villager'
            };
            
            scene.add(villager);
            villagers.push(villager);
            
            return villager;
        }

        // Generar √≠tems en el mundo con texturas
        function generateItems(count) {
            const worldLimit = (currentConfig.WORLD_SIZE * currentConfig.CHUNK_SIZE) / 2 - 5;
            
            for (let i = 0; i < count; i++) {
                const itemType = CONFIG.ITEM_TYPES[Math.floor(Math.random() * CONFIG.ITEM_TYPES.length)];
                
                // Crear √≠tem con textura si est√° disponible
                let itemMaterial;
                if (itemType.texture) {
                    itemMaterial = new THREE.MeshStandardMaterial({
                        map: itemType.texture,
                        color: itemType.color,
                        metalness: 0.5,
                        roughness: 0.3,
                        transparent: true,
                        alphaTest: 0.5
                    });
                } else {
                    itemMaterial = new THREE.MeshStandardMaterial({ 
                        color: itemType.color,
                        metalness: 0.5,
                        roughness: 0.3
                    });
                }
                
                const item = new THREE.Mesh(
                    new THREE.SphereGeometry(itemType.size, 16, 16),
                    itemMaterial
                );
                
                // Posici√≥n aleatoria
                const x = (Math.random() - 0.5) * worldLimit * 2;
                const z = (Math.random() - 0.5) * worldLimit * 2;
                const y = getGroundHeight(x, z) + itemType.size;
                
                item.position.set(x, y, z);
                item.castShadow = true;
                
                // Rotaci√≥n aleatoria para variedad visual
                item.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                // Animaci√≥n de flotaci√≥n
                item.userData.floatOffset = Math.random() * Math.PI * 2;
                item.userData.floatSpeed = 0.5 + Math.random() * 0.5;
                
                // Propiedades del √≠tem
                item.userData = {
                    points: itemType.points,
                    type: 'item',
                    name: itemType.name,
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5
                };
                
                scene.add(item);
                items.push(item);
            }
        }

        // Actualizar animaci√≥n de √≠tems
        function updateItems(delta) {
            const time = Date.now() * 0.001;
            
            items.forEach(item => {
                if (!item) return;
                
                // Animaci√≥n de flotaci√≥n
                item.position.y = getGroundHeight(item.position.x, item.position.z) + 
                    item.userData.size + 
                    Math.sin(time * item.userData.floatSpeed + item.userData.floatOffset) * 0.2;
                
                // Rotaci√≥n lenta
                item.rotation.y += delta * 0.5;
            });
        }

        // Verificar colisiones con √≠tems
        function checkItemCollisions() {
            const playerBox = new THREE.Box3().setFromObject(character);
            playerBox.expandByScalar(1.5); // Aumentar el rango de recolecci√≥n
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (!item) continue;
                
                const itemBox = new THREE.Box3().setFromObject(item);
                if (playerBox.intersectsBox(itemBox)) {
                    // Recolectar el √≠tem
                    collectedItems++;
                    score += item.userData.points;
                    
                    // A√±adir al inventario si hay espacio
                    if (inventory.length < CONFIG.INVENTORY_SIZE) {
                        inventory.push({
                            name: item.userData.name,
                            points: item.userData.points,
                            color: item.material.color.getHex()
                        });
                        updateInventoryUI();
                    }
                    
                    // Verificar si se ha recolectado suficiente para un jefe
                    if (collectedItems % currentConfig.ITEMS_PER_BOSS === 0) {
                        spawnBoss();
                    }
                    
                    // Verificar misiones
                    checkQuests();
                    
                    // Eliminar el √≠tem de la escena
                    scene.remove(item);
                    items.splice(i, 1);
                    
                    // Mostrar notificaci√≥n
                    showNotification(`¬°Recogido: ${item.userData.name} (+${item.userData.points} puntos)!`);
                    
                    // Actualizar UI
                    updateUI();
                }
            }
        }

        // Mostrar notificaci√≥n
        function showNotification(message, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        // Verificar colisiones con el jefe
        function checkBossCollisions() {
            if (!boss) return;
            
            const playerBox = new THREE.Box3().setFromObject(character);
            playerBox.expandByScalar(1.2);
            
            const bossBox = new THREE.Box3().setFromObject(boss);
            if (playerBox.intersectsBox(bossBox)) {
                // Da√±o al jugador
                if (!characterControls.block) {
                    playerHealth -= 10;
                    updateUI();
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Generar un jefe con mejor apariencia
        function spawnBoss() {
            if (boss) return;
            
            boss = new THREE.Group();
            
            // Cuerpo del jefe con textura
            const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.9,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            boss.add(body);
            
            // Cabeza con textura
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcc0000,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5;
            boss.add(head);
            
            // Brazos con textura
            const armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.9
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.8, 1.5, 0);
            boss.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8, 1.5, 0);
            boss.add(rightArm);
            
            // Piernas con textura
            const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x660000,
                roughness: 0.9
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3, 0, 0);
            boss.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3, 0, 0);
            boss.add(rightLeg);
            
            // Posicionar cerca del jugador
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetZ = (Math.random() - 0.5) * 10;
            boss.position.set(
                character.position.x + offsetX,
                0,
                character.position.z + offsetZ
            );
            
            // Configurar propiedades del jefe
            boss.userData = {
                health: currentConfig.BOSS_HEALTH,
                speed: currentConfig.ENEMY_SPEED * 0.8,
                damage: currentConfig.ENEMY_DAMAGE * 3,
                attackRange: currentConfig.ENEMY_ATTACK_RANGE * 1.5,
                attackCooldown: 0,
                parts: { leftArm, rightArm, leftLeg, rightLeg, head },
                type: 'boss'
            };
            
            scene.add(boss);
            
            // Mostrar UI del jefe
            document.getElementById('boss-name').textContent = "JEFE ZOMBIE";
            document.getElementById('boss-name').style.display = 'block';
            document.getElementById('boss-health').style.display = 'block';
            document.getElementById('boss-health-fill').style.width = '100%';
            document.getElementById('boss-counter').style.display = 'block';
            
            // Mostrar notificaci√≥n
            showNotification("¬°Jefe aparecido! ¬°Prep√°rate para la batalla!", 5000);
        }

        // Actualizar jefe
        function updateBoss(delta) {
            if (!boss || gamePaused || !gameActive) return;
            
            const data = boss.userData;
            
            // Perseguir al jugador
            const direction = new THREE.Vector3().subVectors(character.position, boss.position).normalize();
            const newPosition = boss.position.clone().add(direction.multiplyScalar(data.speed * delta));
            
            if (!checkObstacleCollision(boss, newPosition)) {
                boss.position.copy(newPosition);
            }
            
            boss.lookAt(character.position);
            
            // Atacar si est√° cerca
            const distanceToPlayer = boss.position.distanceTo(character.position);
            if (distanceToPlayer < data.attackRange && data.attackCooldown <= 0) {
                if (!characterControls.block) {
                    playerHealth -= data.damage;
                    updateUI();
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
                data.attackCooldown = 1.5;
            }
            
            if (data.attackCooldown > 0) data.attackCooldown -= delta;
            
            // Animaci√≥n de caminar
            const time = Date.now() * 0.001 * 2;
            data.parts.leftLeg.rotation.x = Math.sin(time) * 0.4;
            data.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.4;
            data.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.4;
            data.parts.rightArm.rotation.x = Math.sin(time) * 0.4;
            
            // Actualizar barra de salud del jefe
            document.getElementById('boss-health-fill').style.width = `${(data.health / currentConfig.BOSS_HEALTH) * 100}%`;
        }

        // Atacar al jefe
        function attackBoss() {
            if (!boss || !isAttacking) return;
            
            const bossBox = new THREE.Box3().setFromObject(boss);
            const swordBox = new THREE.Box3().setFromObject(animations.parts.sword);
            
            if (bossBox.intersectsBox(swordBox)) {
                boss.userData.health -= 10 * swordPower;
                
                if (boss.userData.health <= 0) {
                    // Jefe derrotado
                    score += 500;
                    scene.remove(boss);
                    boss = null;
                    document.getElementById('boss-name').style.display = 'none';
                    document.getElementById('boss-health').style.display = 'none';
                    document.getElementById('boss-counter').style.display = 'none';
                    
                    // Recompensa
                    swordPower++;
                    shieldPower++;
                    updateUI();
                    
                    // Mostrar notificaci√≥n
                    showNotification("¬°Jefe derrotado! +500 puntos. Armas mejoradas.", 5000);
                }
            }
        }

        // Actualizar enemigos optimizado
        function updateEnemies(delta) {
            if (gamePaused || !gameActive) return;
            
            enemies.forEach(enemy => {
                if (!enemy) return;
                
                const data = enemy.userData;
                const distanceToPlayer = enemy.position.distanceTo(character.position);

                // Mejor persecuci√≥n y patrulla
                if (distanceToPlayer < data.detectionRange) {
                    let direction = new THREE.Vector3().subVectors(character.position, enemy.position).normalize();
                    // Evita obst√°culos
                    let newPosition = enemy.position.clone().add(direction.multiplyScalar(data.speed * delta));
                    if (!checkObstacleCollision(enemy, newPosition)) {
                        enemy.position.copy(newPosition);
                    }
                    enemy.lookAt(character.position);
                    // Ataca si est√° cerca
                    if (distanceToPlayer < data.attackRange && data.attackCooldown <= 0) {
                        attackPlayer(enemy);
                        data.attackCooldown = 0.7 + Math.random() * 0.5;
                    }
                } else {
                    // Patrulla inteligente
                    data.changeDirectionTime -= delta;
                    if (data.changeDirectionTime <= 0) {
                        data.direction.set(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize();
                        data.changeDirectionTime = 1.5 + Math.random() * 2;
                    }
                    let newPosition = enemy.position.clone().add(data.direction.clone().multiplyScalar(data.speed * delta * 0.5));
                    if (!checkObstacleCollision(enemy, newPosition)) {
                        enemy.position.copy(newPosition);
                    }
                    enemy.lookAt(enemy.position.clone().add(data.direction));
                }
                if (data.attackCooldown > 0) data.attackCooldown -= delta;

                // Animaci√≥n de caminar
                const time = Date.now() * 0.001 * 3;
                data.parts.leftLeg.rotation.x = Math.sin(time) * 0.3;
                data.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.3;
                data.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                data.parts.rightArm.rotation.x = Math.sin(time) * 0.3;
            });
            
            document.getElementById('enemy-count').textContent = enemies.length;
        }

        // Atacar al jugador
        function attackPlayer(enemy) {
            if (characterControls.block) {
                // Bloqueo reduce el da√±o
                playerHealth -= enemy.userData.damage * 0.3 * (1 - shieldPower * 0.1);
            } else {
                playerHealth -= enemy.userData.damage;
            }
            
            updateUI();
            
            if (playerHealth <= 0) {
                gameOver();
            }
        }

        // Actualizar aldeanos optimizado
        function updateVillagers(delta) {
            if (gamePaused || !gameActive) return;
            
            villagers.forEach(villager => {
                if (!villager) return;
                
                const data = villager.userData;
                // Evita enemigos cercanos
                let nearestEnemy = enemies.reduce((nearest, enemy) => {
                    if (!enemy) return nearest;
                    let dist = villager.position.distanceTo(enemy.position);
                    return dist < (nearest?.dist ?? Infinity) ? { enemy, dist } : nearest;
                }, null);

                if (nearestEnemy && nearestEnemy.dist < 8) {
                    // Corre en direcci√≥n opuesta al enemigo
                    data.direction = new THREE.Vector3().subVectors(villager.position, nearestEnemy.enemy.position).normalize();
                    data.changeDirectionTime = 1 + Math.random();
                } else {
                    data.changeDirectionTime -= delta;
                    if (data.changeDirectionTime <= 0) {
                        if (Math.random() > 0.7) {
                            data.direction = new THREE.Vector3().subVectors(data.homePosition, villager.position).normalize();
                        } else {
                            data.direction.set(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize();
                        }
                        data.changeDirectionTime = 2 + Math.random() * 3;
                    }
                }
                // Limita rango de movimiento
                const distanceFromHome = villager.position.distanceTo(data.homePosition);
                if (distanceFromHome > data.wanderRange) {
                    data.direction = new THREE.Vector3().subVectors(data.homePosition, villager.position).normalize();
                    data.changeDirectionTime = 2 + Math.random() * 3;
                }
                let newPosition = villager.position.clone().add(data.direction.clone().multiplyScalar(data.speed * delta));
                if (!checkObstacleCollision(villager, newPosition)) {
                    villager.position.copy(newPosition);
                }
                villager.lookAt(villager.position.clone().add(data.direction));
                // Animaci√≥n de caminar
                const time = Date.now() * 0.001 * 2;
                data.parts.leftLeg.rotation.x = Math.sin(time) * 0.2;
                data.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.2;
                data.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.2;
                data.parts.rightArm.rotation.x = Math.sin(time) * 0.2;
            });
            
            document.getElementById('villager-count').textContent = villagers.length;
        }

        // Actualizar chunks activos optimizado
        function updateActiveChunks() {
            if (!character) return;
            
            const playerChunkX = Math.floor(character.position.x / currentConfig.CHUNK_SIZE);
            const playerChunkZ = Math.floor(character.position.z / currentConfig.CHUNK_SIZE);
            
            // Ocultar chunks lejanos
            activeChunks.forEach(chunk => {
                if (!chunk) return;
                const dx = Math.abs(chunk.userData.x - playerChunkX);
                const dz = Math.abs(chunk.userData.z - playerChunkZ);
                if (dx > currentConfig.VIEW_DISTANCE || dz > currentConfig.VIEW_DISTANCE) {
                    chunk.visible = false;
                }
            });
            
            // Mostrar chunks cercanos
            activeChunks = [];
            for (let x = playerChunkX - currentConfig.VIEW_DISTANCE; x <= playerChunkX + currentConfig.VIEW_DISTANCE; x++) {
                for (let z = playerChunkZ - currentConfig.VIEW_DISTANCE; z <= playerChunkZ + currentConfig.VIEW_DISTANCE; z++) {
                    const chunkKey = `${x},${z}`;
                    if (chunks[chunkKey]) {
                        chunks[chunkKey].visible = true;
                        activeChunks.push(chunks[chunkKey]);
                    } else {
                        // Cargar chunk si no existe (solo si el mundo es din√°mico)
                        loadChunk(x, z).catch(console.error);
                    }
                }
            }
        }

        // Obtener altura del terreno en una posici√≥n
        function getGroundHeight(x, z) {
            const chunkX = Math.floor(x / currentConfig.CHUNK_SIZE);
            const chunkZ = Math.floor(z / currentConfig.CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // Si el chunk existe, usar su altura, sino usar altura base
            if (chunks[chunkKey]) {
                return getNoiseHeight(x, z) * currentConfig.BLOCK_SIZE;
            }
            
            // Altura m√≠nima por defecto (1 bloque)
            return currentConfig.BLOCK_SIZE;
        }

        // Verificar colisi√≥n con obst√°culos optimizado
        function checkObstacleCollision(object, newPosition) {
            if (!object) return false;
            
            const objectBox = new THREE.Box3().setFromObject(object);
            objectBox.expandByScalar(0.5); // Reducir el √°rea de colisi√≥n para mejor rendimiento
            objectBox.translate(new THREE.Vector3().subVectors(newPosition, object.position));
            
            // Verificar colisi√≥n con obst√°culos cercanos primero
            const nearbyObstacles = obstacles.filter(obstacle => {
                if (!obstacle || obstacle === object) return false;
                const distance = obstacle.position.distanceTo(object.position);
                return distance < 5; // Solo verificar obst√°culos cercanos
            });
            
            for (const obstacle of nearbyObstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (objectBox.intersectsBox(obstacleBox)) {
                    return true;
                }
            }
            
            return false;
        }

        // Verificar colisiones con obst√°culos para el jugador optimizado
        function checkPlayerObstacleCollisions(newPosition) {
            const playerBox = new THREE.Box3().setFromObject(character);
            playerBox.expandByScalar(currentConfig.COLLISION_OFFSET);
            playerBox.translate(new THREE.Vector3().subVectors(newPosition, character.position));
            
            // Verificar colisi√≥n con obst√°culos cercanos primero
            const nearbyObstacles = obstacles.filter(obstacle => {
                if (!obstacle || obstacle === character) return false;
                const distance = obstacle.position.distanceTo(character.position);
                return distance < 5; // Solo verificar obst√°culos cercanos
            });
            
            for (const obstacle of nearbyObstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    return true;
                }
            }
            
            return false;
        }

        // Actualizar ciclo d√≠a/noche
        function updateDayNightCycle() {
            if (!dayNightCycleEnabled) return;
            
            dayTime += 0.0001; // Ajustar velocidad del ciclo
            
            if (dayTime >= 1) dayTime = 0;
            
            // Actualizar iluminaci√≥n
            const ambientIntensity = 0.3 + Math.abs(Math.sin(dayTime * Math.PI)) * 0.7;
            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.intensity = ambientIntensity;
                }
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = 0.5 + Math.abs(Math.sin(dayTime * Math.PI)) * 0.5;
                    
                    // Mover "sol"
                    const angle = dayTime * Math.PI * 2;
                    child.position.set(
                        Math.cos(angle) * 100,
                        Math.sin(angle) * 100,
                        50
                    );
                }
            });
            
            // Actualizar texto de hora del d√≠a
            let timeText = "";
            if (dayTime < 0.25) timeText = "Noche";
            else if (dayTime < 0.5) timeText = "Amanecer";
            else if (dayTime < 0.75) timeText = "D√≠a";
            else timeText = "Atardecer";
            
            document.getElementById('time-display').textContent = timeText;
            
            // Ajustar niebla seg√∫n la hora del d√≠a
            if (dayTime < 0.25 || dayTime > 0.75) { // Noche
                scene.fog.color.setHSL(0.6, 0.1, 0.05);
            } else if (dayTime < 0.3 || dayTime > 0.7) { // Amanecer/Atardecer
                scene.fog.color.setHSL(0.1, 0.5, 0.7);
            } else { // D√≠a
                scene.fog.color.setHSL(0.6, 0.6, 0.8);
            }
        }

        // Actualizar inventario UI
        function updateInventoryUI() {
            const inventoryElement = document.getElementById('inventory-items');
            inventoryElement.innerHTML = '';
            
            inventory.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.style.color = `#${item.color.toString(16).padStart(6, '0')}`;
                itemElement.textContent = `${index + 1}. ${item.name} (+${item.points})`;
                inventoryElement.appendChild(itemElement);
            });
        }

        // Actualizar misiones UI
        function updateQuestsUI() {
            const questsElement = document.getElementById('quests-list');
            questsElement.innerHTML = '';
            
            activeQuests.forEach(quest => {
                const questElement = document.createElement('div');
                questElement.style.marginBottom = '10px';
                questElement.innerHTML = `
                    <h4 style="margin: 5px 0; color: #4CAF50;">${quest.name}</h4>
                    <p style="margin: 5px 0;">${quest.description}</p>
                    <p style="margin: 5px 0; font-size: 12px;">Progreso: ${quest.completed ? 'Completada' : `${getQuestProgress(quest)}/${quest.goal}`}</p>
                `;
                questsElement.appendChild(questElement);
            });
            
            if (completedQuests.length > 0) {
                const completedHeader = document.createElement('h4');
                completedHeader.textContent = "Misiones Completadas";
                completedHeader.style.color = "#4CAF50";
                completedHeader.style.margin = "15px 0 5px";
                questsElement.appendChild(completedHeader);
                
                completedQuests.forEach(quest => {
                    const questElement = document.createElement('div');
                    questElement.style.marginBottom = '10px';
                    questElement.innerHTML = `
                        <h4 style="margin: 5px 0;">${quest.name}</h4>
                        <p style="margin: 5px 0; font-size: 12px;">Recompensa: ${quest.reward} puntos</p>
                    `;
                    questsElement.appendChild(questElement);
                });
            }
        }

        // Obtener progreso de misi√≥n
        function getQuestProgress(quest) {
            switch (quest.id) {
                case 1: return collectedItems;
                case 2: return enemiesDefeated;
                case 3: return collectedItems;
                default: return 0;
            }
        }

        // Verificar misiones
        function checkQuests() {
            for (let i = activeQuests.length - 1; i >= 0; i--) {
                const quest = activeQuests[i];
                const progress = getQuestProgress(quest);
                
                if (progress >= quest.goal) {
                    // Misi√≥n completada
                    score += quest.reward;
                    quest.completed = true;
                    completedQuests.push(quest);
                    activeQuests.splice(i, 1);
                    
                    // Mostrar notificaci√≥n
                    showNotification(`¬°Misi√≥n completada: ${quest.name}! +${quest.reward} puntos`, 5000);
                }
            }
            
            updateQuestsUI();
            updateUI();
        }

        // Actualizar UI
        function updateUI() {
            document.getElementById('items').textContent = collectedItems;
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('health-fill').style.width = `${playerHealth}%`;
            document.getElementById('sword-power').textContent = swordPower;
            document.getElementById('shield-power').textContent = shieldPower;
            document.getElementById('items-to-boss').textContent = 
                currentConfig.ITEMS_PER_BOSS - (collectedItems % currentConfig.ITEMS_PER_BOSS);
        }

        // Actualizar armas UI
        function updateWeaponsUI() {
            animations.parts.sword.visible = isAttacking || characterControls.attack;
            animations.parts.shield.visible = characterControls.block;
            
            if (isAttacking || characterControls.block) {
                document.getElementById('weapon-ui').style.display = 'block';
            } else {
                document.getElementById('weapon-ui').style.display = 'none';
            }
        }

        // Configurar eventos de UI mejorados
        function setupUIEvents() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Men√∫ principal
            document.getElementById('play-btn').addEventListener('click', startNewGame);
            document.getElementById('options-btn').addEventListener('click', showSettings);
            document.getElementById('exit-btn').addEventListener('click', () => {
                if (confirm('¬øEst√°s seguro de que quieres salir del juego?')) {
                    window.close();
                }
            });
            
            // Pausa
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('menu-btn').addEventListener('click', () => {
                togglePause();
                showMainMenu();
            });
            document.getElementById('settings-btn').addEventListener('click', showSettings);
            
            // Game over
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            document.getElementById('main-menu-btn').addEventListener('click', showMainMenu);
            
            // Configuraci√≥n
            document.getElementById('close-settings').addEventListener('click', hideSettings);
            document.getElementById('apply-settings').addEventListener('click', applySettings);
            document.getElementById('reset-controls').addEventListener('click', resetControls);
            document.getElementById('random-seed-btn').addEventListener('click', () => {
                randomSeed = Math.floor(Math.random() * 1000000);
                document.getElementById('world-seed').value = randomSeed;
            });
            
            // Selector de c√°mara
            document.getElementById('first-person-btn').addEventListener('click', () => {
                cameraMode = 'first-person';
                document.getElementById('camera-selector').style.display = 'none';
                updateCameraPosition();
            });
            document.getElementById('third-person-btn').addEventListener('click', () => {
                cameraMode = 'third-person';
                document.getElementById('camera-selector').style.display = 'none';
                updateCameraPosition();
            });
            document.getElementById('free-camera-btn').addEventListener('click', () => {
                cameraMode = 'free';
                document.getElementById('camera-selector').style.display = 'none';
                updateCameraPosition();
            });
            
            // Actualizar valores de los sliders
            document.getElementById('view-distance').addEventListener('input', function() {
                document.getElementById('view-distance-value').textContent = this.value;
            });
            
            document.getElementById('mouse-sensitivity').addEventListener('input', function() {
                document.getElementById('mouse-sensitivity-value').textContent = this.value;
            });
            
            document.getElementById('move-speed').addEventListener('input', function() {
                document.getElementById('move-speed-value').textContent = this.value;
            });
            
            document.getElementById('vegetation-density').addEventListener('input', function() {
                document.getElementById('vegetation-density-value').textContent = this.value + '%';
            });
            
            document.getElementById('mountain-density').addEventListener('input', function() {
                document.getElementById('mountain-density-value').textContent = this.value + '%';
            });
            
            document.getElementById('villager-count').addEventListener('input', function() {
                document.getElementById('villager-count-value').textContent = this.value;
            });
            
            document.getElementById('enemy-count').addEventListener('input', function() {
                document.getElementById('enemy-count-value').textContent = this.value;
            });
            
            document.getElementById('show-collision').addEventListener('change', function() {
                showCollision = this.checked;
                if (gameActive) {
                    document.getElementById('collision-visualizer').style.display = 
                        showCollision ? 'block' : 'none';
                    document.getElementById('collision-status').textContent = 
                        showCollision ? 'ON' : 'OFF';
                }
            });
            
            document.getElementById('show-minimap').addEventListener('change', function() {
                showMinimap = this.checked;
                document.getElementById('minimap').style.display = 
                    showMinimap ? 'block' : 'none';
            });
            
            document.getElementById('show-compass').addEventListener('change', function() {
                showCompass = this.checked;
                document.getElementById('compass').style.display = 
                    showCompass ? 'block' : 'none';
            });
            
            document.getElementById('mobile-controls-check').addEventListener('change', function() {
                if (isMobile) {
                    document.getElementById('mobile-controls').style.display = 
                        this.checked ? 'block' : 'none';
                }
            });
            
            // Configurar eventos para cambiar controles
            const keyInputs = document.querySelectorAll('.key-input');
            keyInputs.forEach(input => {
                input.addEventListener('click', function() {
                    changingKey = this.id.replace('-key', '');
                    this.value = '...';
                });
            });
        }

        // Configurar sistema de pausa
        function setupPauseSystem() {
            // Pausar al perder foco
            window.addEventListener('blur', () => {
                if (!gamePaused && gameActive) {
                    togglePause();
                }
            });
        }

        // Mostrar men√∫ principal
        function showMainMenu() {
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('controls-help').style.display = 'none';
            document.getElementById('collision-visualizer').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('settings-menu').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('compass').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            
            gameActive = false;
        }

        // Iniciar nuevo juego
        function startNewGame() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('controls-help').style.display = 'block';
            document.getElementById('collision-visualizer').style.display = 
                showCollision ? 'block' : 'none';
            document.getElementById('minimap').style.display = 
                showMinimap ? 'block' : 'none';
            document.getElementById('compass').style.display = 
                showCompass ? 'block' : 'none';
            document.getElementById('toolbar').style.display = 
                isMobile ? 'flex' : 'none';
            
            // Reiniciar estad√≠sticas
            collectedItems = 0;
            score = 0;
            level = 1;
            playerHealth = currentConfig.PLAYER_HEALTH;
            swordPower = 1;
            shieldPower = 1;
            inventory = [];
            activeQuests = JSON.parse(JSON.stringify(CONFIG.QUESTS));
            completedQuests = [];
            enemiesDefeated = 0;
            
            // Actualizar UI
            updateUI();
            updateInventoryUI();
            updateQuestsUI();
            
            // Posicionar al jugador en el centro
            character.position.set(0, 0, 0);
            
            // Activar el juego
            gameActive = true;
            gamePaused = false;
            
            // Mostrar mensaje de objetivo inicial
            document.getElementById('objective').querySelector('p').textContent = 
                'Recoge √≠tems para avanzar';
            
            // Actualizar contador de jefe
            document.getElementById('items-to-boss').textContent = currentConfig.ITEMS_PER_BOSS;
        }

        // Reiniciar juego
        function resetGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            startNewGame();
        }

        // Mostrar men√∫ de configuraci√≥n
        function showSettings() {
            document.getElementById('settings-menu').style.display = 'block';
            if (gameActive) {
                document.getElementById('pause-screen').style.display = 'none';
            } else {
                document.getElementById('main-menu').style.display = 'none';
            }
        }

        // Ocultar men√∫ de configuraci√≥n
        function hideSettings() {
            document.getElementById('settings-menu').style.display = 'none';
            if (gameActive) {
                document.getElementById('pause-screen').style.display = 'flex';
            } else {
                document.getElementById('main-menu').style.display = 'flex';
            }
        }

        // Restaurar controles por defecto
        function resetControls() {
            keyBindings = {
                forward: 'w',
                backward: 's',
                left: 'a',
                right: 'd',
                jump: ' ',
                sprint: 'shift',
                attack: 'mouse0',
                block: 'mouse2',
                inventory: 'i',
                quests: 'm'
            };
            
            document.getElementById('forward-key').value = 'w';
            document.getElementById('backward-key').value = 's';
            document.getElementById('left-key').value = 'a';
            document.getElementById('right-key').value = 'd';
            document.getElementById('jump-key').value = ' ';
            document.getElementById('sprint-key').value = 'shift';
            document.getElementById('attack-key').value = 'mouse0';
            document.getElementById('block-key').value = 'mouse2';
            document.getElementById('inventory-key').value = 'i';
            document.getElementById('quest-key').value = 'm';
        }

        // Aplicar configuraci√≥n
        function applySettings() {
            currentConfig.VIEW_DISTANCE = parseInt(document.getElementById('view-distance').value) || CONFIG.VIEW_DISTANCE;
            currentConfig.SHADOW_QUALITY = document.getElementById('shadow-quality').value;
            currentConfig.MOUSE_SENSITIVITY = parseFloat(document.getElementById('mouse-sensitivity').value) || CONFIG.MOUSE_SENSITIVITY;
            currentConfig.PLAYER_SPEED = parseFloat(document.getElementById('move-speed').value) || CONFIG.PLAYER_SPEED;
            currentConfig.VEGETATION_DENSITY = parseInt(document.getElementById('vegetation-density').value) || CONFIG.VEGETATION_DENSITY;
            currentConfig.MOUNTAIN_DENSITY = parseInt(document.getElementById('mountain-density').value) || CONFIG.MOUNTAIN_DENSITY;
            showCollision = document.getElementById('show-collision').checked;
            showMinimap = document.getElementById('show-minimap').checked;
            showCompass = document.getElementById('show-compass').checked;
            dayNightCycleEnabled = document.getElementById('day-night-cycle-check').checked;
            
            // Actualizar controles
            keyBindings.forward = document.getElementById('forward-key').value.toLowerCase();
            keyBindings.backward = document.getElementById('backward-key').value.toLowerCase();
            keyBindings.left = document.getElementById('left-key').value.toLowerCase();
            keyBindings.right = document.getElementById('right-key').value.toLowerCase();
            keyBindings.jump = document.getElementById('jump-key').value.toLowerCase();
            keyBindings.sprint = document.getElementById('sprint-key').value.toLowerCase();
            keyBindings.attack = document.getElementById('attack-key').value.toLowerCase();
            keyBindings.block = document.getElementById('block-key').value.toLowerCase();
            keyBindings.inventory = document.getElementById('inventory-key').value.toLowerCase();
            keyBindings.quests = document.getElementById('quest-key').value.toLowerCase();
            
            // Aplicar cambios al renderizador
            if (currentConfig.SHADOW_QUALITY === 'ultra') {
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.shadowMap.autoUpdate = true;
                renderer.shadowMap.needsUpdate = true;
            } else if (currentConfig.SHADOW_QUALITY === 'high') {
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            } else if (currentConfig.SHADOW_QUALITY === 'medium') {
                renderer.shadowMap.type = THREE.PCFShadowMap;
            } else {
                renderer.shadowMap.type = THREE.BasicShadowMap;
            }
            
            // Actualizar visualizaci√≥n de colisiones
            if (gameActive) {
                document.getElementById('collision-visualizer').style.display = 
                    showCollision ? 'block' : 'none';
                document.getElementById('collision-status').textContent = 
                    showCollision ? 'ON' : 'OFF';
                
                document.getElementById('minimap').style.display = 
                    showMinimap ? 'block' : 'none';
                
                document.getElementById('compass').style.display = 
                    showCompass ? 'block' : 'none';
            }
            
            // Actualizar controles m√≥viles
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 
                    document.getElementById('mobile-controls-check').checked ? 'block' : 'none';
            }
            
            // Recargar mundo si es necesario
            if (gameActive && worldGenerated) {
                preloadWorld();
            }
            
            hideSettings();
        }

        // Alternar pausa
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').style.display = gamePaused ? 'flex' : 'none';
        }

        // Manejar teclas presionadas
        function onKeyDown(event) {
            if (changingKey) {
                const key = event.key.toLowerCase();
                document.getElementById(`${changingKey}-key`).value = key === ' ' ? 'Space' : key;
                keyBindings[changingKey] = key;
                changingKey = null;
                return;
            }
            
            if (gamePaused || !gameActive) return;
            
            const key = event.key.toLowerCase();
            
            if (key === keyBindings.forward) characterControls.forward = true;
            if (key === keyBindings.backward) characterControls.backward = true;
            if (key === keyBindings.left) characterControls.left = true;
            if (key === keyBindings.right) characterControls.right = true;
            if (key === keyBindings.sprint) characterControls.sprint = true;
            if (key === keyBindings.jump && isGrounded) {
                characterControls.jump = true;
                velocityY = currentConfig.JUMP_FORCE;
                isGrounded = false;
                isJumping = true;
            }
            if (key === 'escape') togglePause();
            if (key === keyBindings.inventory) {
                document.getElementById('inventory').style.display = 
                    document.getElementById('inventory').style.display === 'none' ? 'block' : 'none';
            }
            if (key === keyBindings.quests) {
                document.getElementById('quest-log').style.display = 
                    document.getElementById('quest-log').style.display === 'none' ? 'block' : 'none';
            }
            
            isWalking = characterControls.forward || characterControls.backward || 
                       characterControls.left || characterControls.right;
        }

        // Manejar teclas liberadas
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            
            if (key === keyBindings.forward) characterControls.forward = false;
            if (key === keyBindings.backward) characterControls.backward = false;
            if (key === keyBindings.left) characterControls.left = false;
            if (key === keyBindings.right) characterControls.right = false;
            if (key === keyBindings.sprint) characterControls.sprint = false;
            if (key === keyBindings.jump) characterControls.jump = false;
            
            isWalking = characterControls.forward || characterControls.backward || 
                       characterControls.left || characterControls.right;
        }

        // Manejar clics del mouse
        function onMouseDown(event) {
            if (gamePaused || !gameActive) return;
            
            if (event.button === 0 && keyBindings.attack === 'mouse0') {
                characterControls.attack = true;
            }
            if (event.button === 2 && keyBindings.block === 'mouse2') {
                characterControls.block = true;
            }
        }

        // Manejar liberaci√≥n de clics del mouse
        function onMouseUp(event) {
            if (event.button === 0 && keyBindings.attack === 'mouse0') {
                characterControls.attack = false;
            }
            if (event.button === 2 && keyBindings.block === 'mouse2') {
                characterControls.block = false;
            }
        }

        // Animaci√≥n de caminar/ataque/salto mejorada
        function updateAnimations(delta) {
            if (gamePaused || !gameActive) return;
            
            // Animaci√≥n de caminar
            if (isWalking && isGrounded) {
                const speed = characterControls.sprint ? 8 : 5;
                const time = Date.now() * 0.001 * speed;
                
                // Piernas
                animations.parts.leftLeg.rotation.x = Math.sin(time) * 0.3;
                animations.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.3;
                
                // Brazos
                animations.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                animations.parts.rightArm.rotation.x = Math.sin(time) * 0.3;
                
                // Cabeza (ligero movimiento al caminar)
                animations.parts.head.rotation.z = Math.sin(time * 2) * 0.05;
            } else if (isJumping) {
                // Animaci√≥n de salto
                animations.parts.leftLeg.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.leftLeg.rotation.x, -0.5, delta * 5
                );
                animations.parts.rightLeg.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.rightLeg.rotation.x, -0.5, delta * 5
                );
                animations.parts.leftArm.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.leftArm.rotation.x, 0.5, delta * 5
                );
                animations.parts.rightArm.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.rightArm.rotation.x, 0.5, delta * 5
                );
            } else {
                // Volver a posici√≥n neutral
                animations.parts.leftLeg.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.leftLeg.rotation.x, 0, delta * 5
                );
                animations.parts.rightLeg.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.rightLeg.rotation.x, 0, delta * 5
                );
                animations.parts.leftArm.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.leftArm.rotation.x, 0, delta * 5
                );
                animations.parts.rightArm.rotation.x = THREE.MathUtils.lerp(
                    animations.parts.rightArm.rotation.x, 0, delta * 5
                );
                animations.parts.head.rotation.z = THREE.MathUtils.lerp(
                    animations.parts.head.rotation.z, 0, delta * 5
                );
            }
            
            // Animaci√≥n de ataque
            if (characterControls.attack && !isAttacking) {
                isAttacking = true;
                attackTime = 0;
            }
            
            if (isAttacking) {
                attackTime += delta;
                
                if (attackTime < 0.2) {
                    // Movimiento hacia adelante
                    animations.parts.rightArm.rotation.z = Math.PI / 2 + attackTime * 5;
                } else if (attackTime < 0.4) {
                    // Movimiento de ataque
                    animations.parts.rightArm.rotation.z = Math.PI / 2 + (0.4 - attackTime) * 5;
                    
                    // Verificar si golpe√≥ al jefe
                    if (attackTime > 0.3) {
                        attackBoss();
                    }
                } else {
                    // Terminar ataque
                    isAttacking = false;
                }
            }
            
            // Animaci√≥n de bloqueo
            if (characterControls.block) {
                animations.parts.leftArm.rotation.z = Math.PI / 2 + 0.5;
            } else {
                animations.parts.leftArm.rotation.z = Math.PI / 2;
            }
            
            // Actualizar visibilidad de armas
            updateWeaponsUI();
        }

        // Actualizar f√≠sica del personaje (gravedad y salto)
        function updatePhysics(delta) {
            if (gamePaused || !gameActive) return;
            
            // Aplicar gravedad
            velocityY -= currentConfig.GRAVITY * delta;
            character.position.y += velocityY * delta;
            
            // Verificar si est√° en el suelo
            const groundHeight = getGroundHeight(character.position.x, character.position.z);
            if (character.position.y <= groundHeight) {
                character.position.y = groundHeight;
                velocityY = 0;
                isGrounded = true;
                isJumping = false;
            } else {
                isGrounded = false;
            }
        }

        // Actualizar posici√≥n del personaje optimizado
        function updateCharacter(delta) {
            if (gamePaused || !gameActive) return;
            
            // Calcular velocidad basada en controles m√≥viles si est√° activo
            let speedMultiplier = 1;
            if (isMobile && joystickActive) {
                speedMultiplier = joystickDistance;
            }
            
            const speed = currentConfig.PLAYER_SPEED * delta * 
                         (characterControls.sprint ? 1.5 : 1) * 
                         speedMultiplier;
            
            const rotationSpeed = 3 * delta * currentConfig.MOUSE_SENSITIVITY;
            
            // Calcular nueva posici√≥n
            const newPosition = character.position.clone();
            const forward = new THREE.Vector3();
            const side = new THREE.Vector3();
            
            character.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            side.crossVectors(new THREE.Vector3(0, 1, 0), forward);
            side.normalize();
            
            // Movimiento hacia adelante/atr√°s
            if (characterControls.forward) {
                newPosition.add(forward.multiplyScalar(-speed)); // W es adelante
            }
            if (characterControls.backward) {
                newPosition.add(forward.multiplyScalar(speed)); // S es atr√°s
            }
            
            // Movimiento izquierda/derecha
            if (characterControls.left) {
                newPosition.add(side.multiplyScalar(-speed)); // A es izquierda
            }
            if (characterControls.right) {
                newPosition.add(side.multiplyScalar(speed)); // D es derecha
            }
            
            // Rotaci√≥n con mouse en primera persona o joystick en m√≥vil
            if (cameraMode === 'first-person') {
                if (characterControls.left) {
                    character.rotateY(rotationSpeed);
                }
                if (characterControls.right) {
                    character.rotateY(-rotationSpeed);
                }
            } else if (isMobile && joystickActive) {
                // Rotaci√≥n con joystick
                character.rotation.y = -joystickAngle + Math.PI/2;
            }
            
            // Verificar colisi√≥n con obst√°culos antes de moverse
            if (!checkPlayerObstacleCollisions(newPosition)) {
                character.position.copy(newPosition);
            }
            
            // Limitar al √°rea del mundo
            const worldLimit = (currentConfig.WORLD_SIZE * currentConfig.CHUNK_SIZE) / 2;
            character.position.x = Math.max(-worldLimit, Math.min(worldLimit, character.position.x));
            character.position.z = Math.max(-worldLimit, Math.min(worldLimit, character.position.z));
            
            // Actualizar chunks activos
            updateActiveChunks();
            
            // Verificar colisiones
            checkItemCollisions();
            checkBossCollisions();
            
            // Actualizar c√°mara
            updateCameraPosition();
        }

        // Actualizar estad√≠sticas de rendimiento optimizado
        function updateStats() {
            stats.frames++;
            
            const now = performance.now();
            const delta = now - stats.lastTime;
            
            if (delta >= 1000) {
                stats.fps = Math.round((stats.frames * 1000) / delta);
                
                // Memoria solo si est√° disponible
                try {
                    stats.memory = performance.memory ? 
                        Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)) : 0;
                } catch (e) {
                    stats.memory = 0;
                }
                
                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('memory').textContent = stats.memory;
                
                stats.frames = 0;
                stats.lastTime = now;
                
                // Ajuste din√°mico de calidad si los FPS son bajos
                if (stats.fps < 30 && !document.getElementById('performance-notification').style.display === 'block') {
                    // Reducir distancia de vista
                    const currentViewDistance = parseInt(document.getElementById('view-distance').value);
                    if (currentViewDistance > 2) {
                        document.getElementById('view-distance').value = currentViewDistance - 1;
                        document.getElementById('view-distance-value').textContent = currentViewDistance - 1;
                        showNotification("Ajustando calidad para mejor rendimiento", 3000);
                        applySettings();
                    }
                }
            }
        }

        // Ajustar tama√±o de ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Game over
        function gameOver() {
            gameActive = false;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').textContent = `Puntuaci√≥n final: ${score}`;
        }

        // Bucle de animaci√≥n optimizado
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1); // Limitar delta para evitar problemas
            
            if (!gamePaused && gameActive) {
                updatePhysics(delta);
                updateAnimations(delta);
                updateCharacter(delta);
                updateEnemies(delta);
                updateVillagers(delta);
                updateItems(delta);
                if (boss) updateBoss(delta);
                updateDayNightCycle();
                
                if (cameraMode === 'free') {
                    controls.update();
                }
            }
            
            updateStats();
            renderer.render(scene, camera);
        }

        // Inicializar el juego
        init();
    </script>
</body>
</html>