<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pepe's Quest: El Guardián de Aethermoor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
        }

        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }

        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }

        #objective {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #4CAF50;
        }

        #health-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }

        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #00ff00);
            transition: width 0.3s;
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #4CAF50;
        }
        
        @keyframes damageFlash {
            0% { opacity: 0.6; }
            100% { opacity: 0; }
        }
        
        @keyframes healFlash {
            0% { opacity: 0.4; }
            100% { opacity: 0; }
        }
        
        @keyframes miniFlash {
            0% { opacity: 0.15; }
            100% { opacity: 0; }
        }
    </style>
</head>

<body>
    <div id="ui">
        <div>Salud: <span id="health">100</span>/100</div>
        <div>Puntos: <span id="score">0</span></div>
        <div>Enemigos derrotados: <span id="kills">0</span></div>
        <div>Cristales: <span id="crystals">0</span>/4</div>
    </div>

    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Objetos: <span id="objects">0</span></div>
    </div>

    <!-- Panel de Misión Colapsable -->
    <div id="mission-panel" style="position: fixed; top: 50%; right: -280px; width: 300px; background: rgba(0,0,0,0.9); color: white; border-radius: 10px 0 0 10px; z-index: 100; transition: right 0.3s ease;">
        <div id="mission-toggle" style="position: absolute; left: -30px; top: 50%; transform: translateY(-50%); width: 30px; height: 60px; background: rgba(0,0,0,0.9); border-radius: 10px 0 0 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-size: 18px;">▶</div>
        <div style="padding: 20px;">
            <h3 style="margin: 0 0 15px 0; color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 5px;">MISIÓN ACTUAL</h3>
            <p id="mission-text" style="margin: 0; line-height: 1.4;">Explora Aethermoor y encuentra los 4 cristales de poder para derrotar al Señor Oscuro</p>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <h4 style="margin: 0 0 10px 0; color: #FF9800;">Progreso:</h4>
                <div id="mission-progress" style="font-size: 12px; color: #ccc;"></div>
            </div>
        </div>
    </div>

    <!-- Barra de Vida Mejorada -->
    <div id="health-bar" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 250px; height: 25px; background: rgba(0,0,0,0.8); border: 2px solid #fff; border-radius: 15px; overflow: hidden; z-index: 100;">
        <div id="health-fill" style="height: 100%; width: 100%; background: linear-gradient(to right, #ff4444, #ffaa00, #44ff44); transition: width 1s ease-out, background-color 0.5s ease;"></div>
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold; font-size: 12px; text-shadow: 1px 1px 2px #000; z-index: 1;"><span id="health-text">100/100</span></div>
    </div>

    <!-- Panel de Botones -->
    <div id="button-panel" style="position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; z-index: 100;">
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
            <button id="btn-inventory" style="padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Inventario (I)</button>
            <button id="btn-minimap" style="padding: 8px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Minimapa (M)</button>
            <button id="btn-camera" style="padding: 8px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Cámara (C)</button>
            <button id="btn-potion" style="padding: 8px; background: #E91E63; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Poción (P)</button>
            <button id="btn-interact" style="padding: 8px; background: #9C27B0; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Hablar (Q)</button>
            <button id="btn-pause" style="padding: 8px; background: #607D8B; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">Pausa (ESC)</button>
        </div>
        <div style="font-size: 10px; color: #ccc; text-align: center;">WASD: Mover | Espacio: Saltar | Click: Atacar | R: Correr</div>
    </div>

    <div id="notification"></div>

    <!-- Menú Principal -->
    <div id="main-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h1 style="font-size: 3em; margin-bottom: 30px; text-shadow: 2px 2px 4px #000;">PEPE'S QUEST</h1>
        <h2 style="margin-bottom: 50px; color: #4CAF50;">El Guardián de Aethermoor</h2>
        <button id="start-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nueva
            Aventura</button>
        <button id="load-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #9C27B0; color: white; border: none; border-radius: 5px; cursor: pointer;">Cargar
            Partida</button>
        <button id="tutorial-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #FF5722; color: white; border: none; border-radius: 5px; cursor: pointer;">Tutorial</button>
        <button id="settings-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuración</button>
        <button id="controls-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer;">Controles</button>
    </div>

    <!-- Menú de Pausa -->
    <div id="pause-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h2 style="margin-bottom: 30px;">JUEGO PAUSADO</h2>
        <button id="resume-game"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Continuar</button>
        <button id="pause-settings"
            style="padding: 10px 20px; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuración</button>
        <button id="main-menu-btn"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Menú
            Principal</button>
    </div>

    <!-- Configuración -->
    <div id="settings-menu"
        style="position: fixed; top: 50px; left: 50px; width: 400px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1001; display: none;">
        <h3>Configuración</h3>
        <div style="margin: 10px 0;">Calidad Gráfica: <select id="graphics-quality">
                <option value="low">Baja</option>
                <option value="medium">Media</option>
                <option value="high">Alta</option>
                <option value="ultra">Ultra</option>
            </select></div>
        <div style="margin: 10px 0;">Calidad de Sombras: <select id="shadow-quality">
                <option value="off">Desactivadas</option>
                <option value="low">Bajas</option>
                <option value="high">Altas</option>
            </select></div>
        <div style="margin: 10px 0;">Modo de Cámara: <select id="camera-mode">
                <option value="third">3ª Persona</option>
                <option value="first">1ª Persona</option>
                <option value="free">Libre</option>
            </select></div>
        <div style="margin: 10px 0;">Mostrar Minimapa: <input type="checkbox" id="show-minimap" checked></div>
        <div style="margin: 10px 0;">Mostrar Brújula: <input type="checkbox" id="show-compass" checked></div>
        <div style="margin: 10px 0;">Ciclo Día/Noche: <input type="checkbox" id="day-night-cycle"></div>
        <div style="margin: 10px 0;">Volumen: <input type="range" id="volume-slider" min="0" max="100" value="50"></div>
        <div style="margin: 10px 0;">Distancia de Visión: <input type="range" id="view-distance" min="50" max="300" value="200"></div>
        <button id="close-settings"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Minimapa -->
    <div id="minimap"
        style="position: fixed; top: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 10px; z-index: 100;">
    </div>

    <!-- Brújula -->
    <div id="compass"
        style="position: fixed; top: 180px; right: 20px; width: 80px; height: 80px; background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 50%; z-index: 100; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">
        N</div>

    <!-- Inventario -->
    <div id="inventory"
        style="position: fixed; bottom: 100px; left: 20px; width: 350px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Inventario</h4>
        <div id="inventory-items"></div>
        <div id="player-stats" style="margin-top: 10px; font-size: 12px; color: #ccc;"></div>
    </div>

    <!-- Logros -->
    <div id="achievements"
        style="position: fixed; top: 50%; right: 20px; width: 250px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Logros Desbloqueados</h4>
        <div id="achievement-list"></div>
    </div>

    <!-- Clima -->
    <div id="weather-info"
        style="position: fixed; top: 200px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; z-index: 100; font-size: 12px;">
    </div>

    <!-- Tienda -->
    <div id="shop"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1002; display: none;">
        <h3>Tienda del Mercader</h3>
        <div id="shop-items"></div>
        <button id="close-shop"
            style="padding: 10px 20px; margin-top: 20px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Misiones -->
    <div id="quest-panel"
        style="position: fixed; top: 20px; left: 200px; width: 300px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Misiones Activas</h4>
        <div id="quest-list"></div>
    </div>

    <!-- Guardado -->
    <div id="save-menu"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1003; display: none;">
        <h3>Guardar/Cargar Partida</h3>
        <div id="save-slots"></div>
        <button id="close-save"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Tutorial -->
    <div id="tutorial"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1004; display: none; text-align: center;">
        <h2>Tutorial - Pepe's Quest</h2>
        <div id="tutorial-content"></div>
        <button id="tutorial-next"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Siguiente</button>
        <button id="tutorial-skip"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Saltar</button>
    </div>

    <!-- Controles Móviles -->
    <div id="mobile-controls" style="position: fixed; bottom: 20px; left: 20px; z-index: 100; display: none;">
        <div id="joystick"
            style="width: 100px; height: 100px; background: rgba(255,255,255,0.3); border-radius: 50%; position: relative;">
            <div id="joystick-knob"
                style="width: 40px; height: 40px; background: rgba(255,255,255,0.8); border-radius: 50%; position: absolute; top: 30px; left: 30px;">
            </div>
        </div>
        <button id="mobile-attack"
            style="position: absolute; right: -120px; bottom: 0; width: 60px; height: 60px; background: #f44336; color: white; border: none; border-radius: 50%; font-size: 20px;">⚔</button>
        <button id="mobile-jump"
            style="position: absolute; right: -120px; bottom: 70px; width: 60px; height: 60px; background: #4CAF50; color: white; border: none; border-radius: 50%; font-size: 20px;">↑</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales
        let scene, camera, renderer, clock;
        let player, enemies = [], items = [], crystals = [], villagers = [], bosses = [];
        let keys = {}, gameActive = false, gamePaused = false, gameStarted = false;
        let playerHealth = 100, score = 0, kills = 0, crystalsFound = 0, playerLevel = 1, playerXP = 0;
        
        // Inicializar score correctamente
        function initializeGame() {
            score = 0;
            playerHealth = 100;
            kills = 0;
            crystalsFound = 0;
            playerLevel = 1;
            playerXP = 0;
        }
        let stats = { fps: 0, lastTime: 0, frames: 0 };
        let cameraMode = 'third', dayTime = 0.5, isMobile = false;
        let inventory = { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
        let currentQuest = { name: 'Encuentra los Cristales', progress: 0, total: 4 };
        let settings = { shadows: 'low', minimap: true, compass: true, dayNight: false, audio: true };
        let weather = { type: 'clear', intensity: 0, particles: [] };
        let achievements = [];
        let gameTime = 0;
        let playerStats = { totalDistance: 0, totalJumps: 0, totalAttacks: 0 };
        let merchants = [], quests = [], particles = [];
        let audioContext, sounds = {};
        let saveSlots = [null, null, null];
        let currentSaveSlot = 0;

        // Configuración
        const config = {
            playerSpeed: 8,
            jumpForce: 12,
            gravity: -30,
            attackRange: 4,
            worldSize: 300
        };

        // Detectar dispositivo móvil
        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                setupMobileControls();
            }
        }

        // Configurar menús
        function setupMenus() {
            const startBtn = document.getElementById('start-game');
            const loadBtn = document.getElementById('load-game');
            const tutorialBtn = document.getElementById('tutorial-btn');
            const settingsBtn = document.getElementById('settings-btn');
            const controlsBtn = document.getElementById('controls-btn');
            const closeSettingsBtn = document.getElementById('close-settings');
            const resumeBtn = document.getElementById('resume-game');
            const pauseSettingsBtn = document.getElementById('pause-settings');
            const mainMenuBtn = document.getElementById('main-menu-btn');

            if (startBtn) startBtn.addEventListener('click', () => {
                document.getElementById('save-menu').style.display = 'block';
                loadNewGameSlots();
            });
            if (loadBtn) loadBtn.addEventListener('click', () => {
                document.getElementById('save-menu').style.display = 'block';
                loadSaveSlots();
            });
            if (tutorialBtn) tutorialBtn.addEventListener('click', showTutorial);
            if (settingsBtn) settingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (controlsBtn) controlsBtn.addEventListener('click', showControls);
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'none';
            });
            if (resumeBtn) resumeBtn.addEventListener('click', resumeGame);
            if (pauseSettingsBtn) pauseSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (mainMenuBtn) mainMenuBtn.addEventListener('click', () => {
                gameActive = false;
                gamePaused = false;
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
            });

            // Configuración
            const shadowQuality = document.getElementById('shadow-quality');
            const cameraSelect = document.getElementById('camera-mode');
            const minimapCheck = document.getElementById('show-minimap');
            const compassCheck = document.getElementById('show-compass');
            const dayNightCheck = document.getElementById('day-night-cycle');

            if (shadowQuality) shadowQuality.addEventListener('change', (e) => {
                settings.shadows = e.target.value;
                updateGraphics();
            });
            if (cameraSelect) cameraSelect.addEventListener('change', (e) => {
                cameraMode = e.target.value;
            });
            if (minimapCheck) minimapCheck.addEventListener('change', (e) => {
                settings.minimap = e.target.checked;
                document.getElementById('minimap').style.display = e.target.checked ? 'block' : 'none';
            });
            if (compassCheck) compassCheck.addEventListener('change', (e) => {
                settings.compass = e.target.checked;
                document.getElementById('compass').style.display = e.target.checked ? 'block' : 'none';
            });
            if (dayNightCheck) dayNightCheck.addEventListener('change', (e) => {
                settings.dayNight = e.target.checked;
            });
            
            // Nuevas configuraciones
            const graphicsQuality = document.getElementById('graphics-quality');
            const volumeSlider = document.getElementById('volume-slider');
            const viewDistance = document.getElementById('view-distance');
            
            if (graphicsQuality) graphicsQuality.addEventListener('change', (e) => {
                settings.graphics = e.target.value;
                updateGraphicsQuality();
            });
            if (volumeSlider) volumeSlider.addEventListener('input', (e) => {
                settings.volume = e.target.value / 100;
            });
            if (viewDistance) viewDistance.addEventListener('input', (e) => {
                camera.far = parseInt(e.target.value);
                camera.updateProjectionMatrix();
                scene.fog.far = parseInt(e.target.value);
            });
            
            // Configurar botones del panel
            setupButtonPanel();
        }
        
        function setupButtonPanel() {
            const btnInventory = document.getElementById('btn-inventory');
            const btnMinimap = document.getElementById('btn-minimap');
            const btnCamera = document.getElementById('btn-camera');
            const btnPotion = document.getElementById('btn-potion');
            const btnInteract = document.getElementById('btn-interact');
            const btnPause = document.getElementById('btn-pause');
            
            if (btnInventory) btnInventory.addEventListener('click', toggleInventory);
            if (btnMinimap) btnMinimap.addEventListener('click', toggleMinimap);
            if (btnCamera) btnCamera.addEventListener('click', cycleCameraMode);
            if (btnPotion) btnPotion.addEventListener('click', usePotion);
            if (btnInteract) btnInteract.addEventListener('click', interactWithNearbyNPC);
            if (btnPause) btnPause.addEventListener('click', togglePause);
            
            // Configurar panel de misión
            setupMissionPanel();
        }
        
        function setupMissionPanel() {
            const missionPanel = document.getElementById('mission-panel');
            const missionToggle = document.getElementById('mission-toggle');
            let isOpen = false;
            
            if (missionToggle) {
                missionToggle.addEventListener('click', () => {
                    isOpen = !isOpen;
                    if (isOpen) {
                        missionPanel.style.right = '0px';
                        missionToggle.innerHTML = '◀';
                    } else {
                        missionPanel.style.right = '-280px';
                        missionToggle.innerHTML = '▶';
                    }
                });
            }
        }

        function showControls() {
            showNotification(`CONTROLES:\n\nWASD: Mover\nEspacio: Saltar\nClick: Atacar\nR: Correr\nP: Usar poción\nQ: Hablar con NPCs\nI: Inventario\nM: Minimapa\nC: Cambiar cámara\nESC: Pausar`, 8000);
        }

        // Iniciar juego
        function startGame() {
            document.getElementById('main-menu').style.display = 'none';
            if (!gameStarted) {
                init();
                gameStarted = true;
            }
            gameActive = true;
            gamePaused = false;
        }

        // Pausar/Reanudar juego
        function togglePause() {
            if (!gameActive) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-menu').style.display = gamePaused ? 'flex' : 'none';
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-menu').style.display = 'none';
        }

        // Inicializar juego
        function init() {
            // Inicializar variables del juego
            initializeGame();
            
            // Guardar automáticamente al iniciar si hay slot seleccionado
            if (currentSaveSlot !== undefined) {
                setTimeout(() => {
                    saveGame(currentSaveSlot);
                }, 1000);
            }
            
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // Crear cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Crear renderizador
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.body.appendChild(renderer.domElement);

            // Crear luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Crear mundo
            createWorld();
            createPlayer();
            spawnEnemies();
            spawnVillagers();
            spawnItems();
            spawnCrystals();
            spawnBosses();
            spawnTreasureChests();
            initWeatherSystem();
            initAchievements();

            // Configurar eventos
            setupControls();
            setupMenus();
            detectMobile();

            // Iniciar reloj
            clock = new THREE.Clock();
            stats.lastTime = performance.now();

            // Configurar rendimiento automático
            setupPerformanceOptimization();

            // Mostrar lore inicial
            showNotification("¡Bienvenido a Aethermoor, Pepe!\n\nLos 4 reinos han caído en la oscuridad.\nEncuentra los cristales de poder para restaurar la paz.", 5000);

            // Actualizar UI inicial
            updateUI();
            updateInventoryUI();

            // Iniciar bucle de juego
            animate();
            
            // Iniciar limpieza de memoria
            startMemoryCleanup();
        }

        // Crear mundo
        function createWorld() {
            // Terreno base
            const groundGeometry = new THREE.PlaneGeometry(config.worldSize, config.worldSize);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Reino Central (spawn)
            createKingdom(0, 0, 0x4CAF50, "Reino Central");

            // Reinos elementales
            createKingdom(-80, -80, 0xff4444, "Reino del Fuego");
            createKingdom(80, -80, 0x4444ff, "Reino del Agua");
            createKingdom(80, 80, 0xffff44, "Reino del Aire");
            createKingdom(-80, 80, 0x8B4513, "Reino de la Tierra");

            // Mazmorras
            createDungeon(0, -120, 0x444444);
            createDungeon(120, 0, 0x444444);
            createDungeon(0, 120, 0x444444);
            createDungeon(-120, 0, 0x444444);
        }

        // Crear reino
        function createKingdom(x, z, color, name) {
            const kingdom = new THREE.Group();

            // Castillo principal
            const castleGeometry = new THREE.BoxGeometry(10, 15, 10);
            const castleMaterial = new THREE.MeshLambertMaterial({ color });
            const castle = new THREE.Mesh(castleGeometry, castleMaterial);
            castle.position.y = 7.5;
            castle.castShadow = true;
            kingdom.add(castle);

            // Torres
            for (let i = 0; i < 4; i++) {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 18, 8),
                    castleMaterial
                );
                const angle = (i * Math.PI) / 2;
                tower.position.set(Math.cos(angle) * 8, 9, Math.sin(angle) * 8);
                tower.castShadow = true;
                kingdom.add(tower);
            }

            // Casas
            for (let i = 0; i < 8; i++) {
                const house = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                const angle = (i * Math.PI) / 4;
                house.position.set(Math.cos(angle) * 20, 3, Math.sin(angle) * 20);
                house.castShadow = true;
                kingdom.add(house);
            }

            kingdom.position.set(x, 0, z);
            scene.add(kingdom);
        }

        // Crear mazmorra
        function createDungeon(x, z, color) {
            const dungeon = new THREE.Group();

            // Entrada
            const entrance = new THREE.Mesh(
                new THREE.BoxGeometry(8, 4, 8),
                new THREE.MeshLambertMaterial({ color })
            );
            entrance.position.y = 2;
            entrance.castShadow = true;
            dungeon.add(entrance);

            // Pilares
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1, 10, 6),
                    new THREE.MeshLambertMaterial({ color })
                );
                const angle = (i * Math.PI) / 2;
                pillar.position.set(Math.cos(angle) * 6, 5, Math.sin(angle) * 6);
                pillar.castShadow = true;
                dungeon.add(pillar);
            }

            dungeon.position.set(x, 0, z);
            scene.add(dungeon);
        }

        // Crear jugador
        function createPlayer() {
            player = new THREE.Group();

            // Cuerpo
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 0.5),
                new THREE.MeshLambertMaterial({ color: 0x3366ff })
            );
            body.position.y = 1;
            body.castShadow = true;
            player.add(body);

            // Cabeza
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 2.4;
            head.castShadow = true;
            player.add(head);

            // Brazos
            const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.65, 1.4, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.65, 1.4, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // Piernas
            const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x3333ff });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.6, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.6, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            // Espada
            const sword = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 2, 0.1),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            sword.position.set(1, 1.5, 0);
            sword.visible = false;
            player.add(sword);

            player.position.set(0, 0, 0);
            player.userData = {
                velocity: new THREE.Vector3(),
                isGrounded: true,
                isAttacking: false,
                attackTime: 0,
                parts: { body, head, leftArm, rightArm, leftLeg, rightLeg, sword }
            };

            scene.add(player);

            // Posicionar cámara
            camera.position.set(0, 8, 12);
            camera.lookAt(player.position);
        }

        // Generar enemigos - MUCHOS MÁS
        function spawnEnemies() {
            // Enemigos básicos (30)
            for (let i = 0; i < 30; i++) {
                createEnemy('basic');
            }
            // Enemigos fuertes (15)
            for (let i = 0; i < 15; i++) {
                createEnemy('strong');
            }
            // Enemigos élite (8)
            for (let i = 0; i < 8; i++) {
                createEnemy('elite');
            }
        }

        // Crear enemigo con tipos
        function createEnemy(type = 'basic') {
            const enemy = new THREE.Group();

            let color, health, speed, damage, size, xpReward, scoreReward;

            switch (type) {
                case 'strong':
                    color = 0x660000;
                    health = 60;
                    speed = 2.5;
                    damage = 15;
                    size = 1.2;
                    xpReward = 40;
                    scoreReward = 150;
                    break;
                case 'elite':
                    color = 0x330000;
                    health = 100;
                    speed = 4;
                    damage = 25;
                    size = 1.5;
                    xpReward = 75;
                    scoreReward = 250;
                    break;
                default: // basic
                    color = 0x990000;
                    health = 30;
                    speed = 3;
                    damage = 10;
                    size = 1;
                    xpReward = 25;
                    scoreReward = 100;
            }

            // Cuerpo
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8 * size, 1.6 * size, 0.4 * size),
                new THREE.MeshLambertMaterial({ color })
            );
            body.position.y = 0.8 * size;
            body.castShadow = true;
            enemy.add(body);

            // Cabeza
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.6 * size, 0.6 * size, 0.6 * size),
                new THREE.MeshLambertMaterial({ color })
            );
            head.position.y = 1.9 * size;
            head.castShadow = true;
            enemy.add(head);

            // Posición aleatoria
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 120;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            enemy.userData = {
                type,
                health,
                maxHealth: health,
                speed,
                damage,
                attackRange: 2,
                attackCooldown: 0,
                xpReward,
                scoreReward,
                parts: { body, head }
            };

            enemies.push(enemy);
            scene.add(enemy);
        }

        // Generar ítems - MUCHOS MÁS
        function spawnItems() {
            // Monedas (50)
            for (let i = 0; i < 50; i++) {
                const item = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xffff00 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 140;
                item.position.set(
                    Math.cos(angle) * distance,
                    0.5,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 10, type: 'coin', coins: 5 };
                items.push(item);
                scene.add(item);
            }

            // Pociones (25)
            for (let i = 0; i < 25; i++) {
                const item = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xff0080 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 120;
                item.position.set(
                    Math.cos(angle) * distance,
                    0.8,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 25, type: 'potion' };
                items.push(item);
                scene.add(item);
            }

            // Armas mejoradas (10)
            for (let i = 0; i < 10; i++) {
                const item = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1.5, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 100;
                item.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );

                item.userData = { points: 100, type: 'weapon' };
                items.push(item);
                scene.add(item);
            }
        }

        // Generar cristales - MUCHOS MÁS
        function spawnCrystals() {
            // Cristales principales (4)
            const mainPositions = [[-80, -80], [80, -80], [80, 80], [-80, 80]];
            const mainColors = [0xff0000, 0x0000ff, 0xffff00, 0x8B4513];

            for (let i = 0; i < 4; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 4, 6),
                    new THREE.MeshLambertMaterial({ color: mainColors[i] })
                );
                crystal.position.set(mainPositions[i][0], 3, mainPositions[i][1]);
                crystal.userData = { type: 'main_crystal', id: i, power: 100 };
                crystals.push(crystal);
                scene.add(crystal);
            }

            // Cristales menores (20)
            for (let i = 0; i < 20; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.5, 1.5, 6),
                    new THREE.MeshLambertMaterial({ color: 0x00ffff })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 100;
                crystal.position.set(
                    Math.cos(angle) * distance,
                    1.5,
                    Math.sin(angle) * distance
                );
                crystal.userData = { type: 'minor_crystal', power: 25 };
                crystals.push(crystal);
                scene.add(crystal);
            }
        }

        // Configurar controles
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (!gameActive && e.code !== 'Escape') return;

                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape') togglePause();
                if (e.code === 'KeyI' && gameActive && !gamePaused) toggleInventory();
                if (e.code === 'KeyM' && gameActive && !gamePaused) toggleMinimap();
                if (e.code === 'KeyC' && gameActive && !gamePaused) cycleCameraMode();
                if (e.code === 'KeyP' && gameActive && !gamePaused) usePotion();
                if (e.code === 'KeyQ' && gameActive && !gamePaused) interactWithNearbyNPC();
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameActive && !gamePaused) attack();
                if (e.button === 2 && gameActive && !gamePaused) block();
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Controles de mouse para cámara libre
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (e) => {
                if (!gameActive || gamePaused) return;
                
                const deltaX = e.movementX || e.webkitMovementX || 0;
                const deltaY = e.movementY || e.webkitMovementY || 0;
                
                if (cameraMode === 'free' && camera.userData.freeMode) {
                    camera.userData.yaw -= deltaX * 0.002;
                    camera.userData.pitch -= deltaY * 0.002;
                    camera.userData.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.userData.pitch));
                }
            });
            
            // Zoom para cámara libre
            document.addEventListener('wheel', (e) => {
                if (!gameActive || gamePaused || cameraMode !== 'free') return;
                
                e.preventDefault();
                camera.userData.distance += e.deltaY * 0.01;
                camera.userData.distance = Math.max(5, Math.min(30, camera.userData.distance));
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Controles móviles
        function setupMobileControls() {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystick-knob');
            let isDragging = false;

            joystick.addEventListener('touchstart', (e) => {
                isDragging = true;
                e.preventDefault();
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const distance = Math.min(30, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                knob.style.left = (30 + Math.cos(angle) * distance) + 'px';
                knob.style.top = (30 + Math.sin(angle) * distance) + 'px';

                // Simular teclas
                keys['KeyW'] = deltaY < -10;
                keys['KeyS'] = deltaY > 10;
                keys['KeyA'] = deltaX < -10;
                keys['KeyD'] = deltaX > 10;

                e.preventDefault();
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
                knob.style.left = '30px';
                knob.style.top = '30px';
                keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = false;
            });

            document.getElementById('mobile-attack').addEventListener('touchstart', (e) => {
                attack();
                e.preventDefault();
            });

            document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
                keys['Space'] = true;
                e.preventDefault();
            });

            document.getElementById('mobile-jump').addEventListener('touchend', (e) => {
                keys['Space'] = false;
                e.preventDefault();
            });
        }

        // Actualizar jugador
        function updatePlayer(delta) {
            const userData = player.userData;
            const speed = keys['KeyR'] ? config.playerSpeed * 1.5 : config.playerSpeed;

            // Movimiento
            const moveVector = new THREE.Vector3();
            if (keys['KeyW']) moveVector.z -= 1;
            if (keys['KeyS']) moveVector.z += 1;
            if (keys['KeyA']) moveVector.x -= 1;
            if (keys['KeyD']) moveVector.x += 1;

            if (moveVector.length() > 0) {
                moveVector.normalize();
                const oldPos = player.position.clone();
                player.position.x += moveVector.x * speed * delta;
                player.position.z += moveVector.z * speed * delta;
                playerStats.totalDistance += oldPos.distanceTo(player.position);

                // Rotar hacia dirección de movimiento
                const targetRotation = Math.atan2(moveVector.x, moveVector.z);
                player.rotation.y = targetRotation;
            }

            // Salto
            if (keys['Space'] && userData.isGrounded) {
                userData.velocity.y = config.jumpForce;
                userData.isGrounded = false;
                playerStats.totalJumps++;
                checkAchievement('jumper');
            }

            // Gravedad
            userData.velocity.y += config.gravity * delta;
            player.position.y += userData.velocity.y * delta;

            // Colisión con suelo
            if (player.position.y <= 0) {
                player.position.y = 0;
                userData.velocity.y = 0;
                userData.isGrounded = true;
            }

            // Actualizar cámara según modo
            switch (cameraMode) {
                case 'first':
                    // Primera persona mejorada
                    camera.position.copy(player.position);
                    camera.position.y += 1.8;
                    
                    // Usar rotación del jugador para la cámara
                    const lookDirection = new THREE.Vector3(0, 0, -1);
                    lookDirection.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
                    const lookTarget = player.position.clone().add(lookDirection.multiplyScalar(10));
                    camera.lookAt(lookTarget);
                    break;
                    
                case 'free':
                    // Cámara libre mejorada con controles de mouse
                    if (!camera.userData.freeMode) {
                        camera.userData.freeMode = true;
                        camera.userData.yaw = 0;
                        camera.userData.pitch = 0;
                        camera.userData.distance = 15;
                    }
                    
                    // Orbitar alrededor del jugador
                    const spherical = new THREE.Spherical(
                        camera.userData.distance,
                        Math.PI / 2 - camera.userData.pitch,
                        camera.userData.yaw
                    );
                    
                    const freeCameraPos = new THREE.Vector3();
                    freeCameraPos.setFromSpherical(spherical);
                    freeCameraPos.add(player.position);
                    
                    camera.position.lerp(freeCameraPos, delta * 8);
                    camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
                    break;
                    
                default: // third person
                    camera.userData.freeMode = false;
                    const cameraOffset = new THREE.Vector3(0, 8, 12);
                    const desiredPosition = player.position.clone().add(cameraOffset);
                    camera.position.lerp(desiredPosition, delta * 5);
                    camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
            }

            // Animación de ataque
            if (userData.isAttacking) {
                userData.attackTime += delta;
                userData.parts.sword.visible = true;

                if (userData.attackTime > 0.5) {
                    userData.isAttacking = false;
                    userData.attackTime = 0;
                    userData.parts.sword.visible = false;
                }
            }

            // Animación de caminar
            if (moveVector.length() > 0 && userData.isGrounded) {
                const time = Date.now() * 0.005;
                userData.parts.leftLeg.rotation.x = Math.sin(time) * 0.5;
                userData.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.5;
                userData.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                userData.parts.rightArm.rotation.x = Math.sin(time) * 0.3;
            }
        }

        // Atacar
        function attack() {
            if (player.userData.isAttacking) return;

            player.userData.isAttacking = true;
            player.userData.attackTime = 0;
            playerStats.totalAttacks++;
            checkAchievement('warrior');

            // Buscar enemigos en rango
            enemies.forEach((enemy, index) => {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < config.attackRange) {
                    enemy.userData.health -= 20 * inventory.sword;

                    if (enemy.userData.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                        score += enemy.userData.scoreReward;
                        kills++;
                        playerXP += enemy.userData.xpReward;
                        inventory.coins += Math.floor(Math.random() * 20) + 5;
                        checkLevelUp();
                        checkAchievement('first_kill');
                        updateUI();
                        updateInventoryUI();
                        showNotification(`+${enemy.userData.scoreReward} puntos! +${enemy.userData.xpReward} XP`, 1000);
                    }
                }
            });

            // Atacar jefes
            bosses.forEach((boss, index) => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < config.attackRange) {
                    boss.userData.health -= 30 * inventory.sword;

                    if (boss.userData.health <= 0) {
                        scene.remove(boss);
                        bosses.splice(index, 1);
                        score += 500;
                        playerXP += 100;
                        inventory.sword++;
                        checkLevelUp();
                        checkAchievement('boss_slayer');
                        updateUI();
                        updateInventoryUI();
                        showNotification("¡Jefe derrotado! +500 puntos! Espada mejorada!", 3000);

                        // Verificar victoria total
                        if (crystalsFound >= 4 && bosses.length === 0) {
                            setTimeout(() => {
                                showNotification("¡VICTORIA TOTAL!\n¡Has derrotado a todos los jefes y encontrado todos los cristales!\n¡Aethermoor está a salvo!", 5000);
                                setTimeout(() => gameOver(), 5000);
                            }, 3000);
                        }
                    }
                }
            });
        }

        // Sistema de niveles
        function checkLevelUp() {
            const xpNeeded = playerLevel * 100;
            if (playerXP >= xpNeeded) {
                playerXP -= xpNeeded;
                playerLevel++;
                healPlayer(20);
                inventory.potions++;
                showNotification(`¡Nivel ${playerLevel}! +20 HP, +1 Poción`, 3000);
                updateInventoryUI();
            }
        }

        // Sistema de daño simple
        function takeDamage(amount) {
            playerHealth = Math.max(0, playerHealth - amount);
            updateUI();
            
            // Efecto de pantalla roja
            const damageOverlay = document.createElement('div');
            damageOverlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(255, 0, 0, 0.3); z-index: 50; pointer-events: none;
                animation: damageFlash 0.5s ease-out;
            `;
            document.body.appendChild(damageOverlay);
            setTimeout(() => {
                if (document.body.contains(damageOverlay)) {
                    document.body.removeChild(damageOverlay);
                }
            }, 500);
            
            if (playerHealth <= 0) {
                gameOver();
            }
        }
        
        // Sistema de curación simple
        function healPlayer(amount) {
            playerHealth = Math.min(100, playerHealth + amount);
            updateUI();
            
            // Efecto de pantalla verde
            const healOverlay = document.createElement('div');
            healOverlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 255, 0, 0.2); z-index: 50; pointer-events: none;
                animation: healFlash 0.8s ease-out;
            `;
            document.body.appendChild(healOverlay);
            setTimeout(() => {
                if (document.body.contains(healOverlay)) {
                    document.body.removeChild(healOverlay);
                }
            }, 800);
        }
        
        // Usar poción
        function usePotion() {
            if (inventory.potions > 0 && playerHealth < 100) {
                inventory.potions--;
                healPlayer(50);
                updateInventoryUI();
                showNotification("+50 HP", 1500);
            }
        }

        // Actualizar enemigos
        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                const userData = enemy.userData;
                const distance = player.position.distanceTo(enemy.position);

                if (distance < 15) {
                    // Perseguir jugador
                    const direction = new THREE.Vector3()
                        .subVectors(player.position, enemy.position)
                        .normalize();

                    enemy.position.add(direction.multiplyScalar(userData.speed * delta));
                    enemy.lookAt(player.position);

                    // Atacar si está cerca
                    if (distance < userData.attackRange && userData.attackCooldown <= 0) {
                        takeDamage(userData.damage);
                        userData.attackCooldown = 1.5;
                        showNotification(`-${userData.damage} HP`, 800);
                    }
                }

                if (userData.attackCooldown > 0) {
                    userData.attackCooldown -= delta;
                }

                // Animación simple
                const time = Date.now() * 0.003;
                userData.parts.body.rotation.z = Math.sin(time) * 0.1;
            });
        }

        // Actualizar ítems
        function updateItems(delta) {
            items.forEach((item, index) => {
                // Rotación
                item.rotation.y += delta * 2;

                // Colisión con jugador
                const distance = player.position.distanceTo(item.position);
                if (distance < 2) {
                    scene.remove(item);
                    items.splice(index, 1);
                    score += item.userData.points;

                    switch (item.userData.type) {
                        case 'coin':
                            inventory.coins += item.userData.coins || 5;
                            showNotification(`+${item.userData.coins || 5} monedas!`, 800);
                            break;
                        case 'potion':
                            inventory.potions++;
                            showNotification(`+1 Poción de Salud!`, 1000);
                            break;
                        case 'weapon':
                            inventory.sword++;
                            showNotification(`¡Espada mejorada! Nivel ${inventory.sword}`, 2000);
                            break;
                    }

                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Actualizar cristales
        function updateCrystals(delta) {
            crystals.forEach((crystal, index) => {
                // Rotación y flotación
                crystal.rotation.y += delta;
                crystal.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.5;

                // Colisión con jugador
                const distance = player.position.distanceTo(crystal.position);
                if (distance < 3) {
                    scene.remove(crystal);
                    crystals.splice(index, 1);

                    if (crystal.userData.type === 'main_crystal') {
                        crystalsFound++;
                        score += 1000;
                        playerXP += 200;
                        inventory.artifacts++;
                        showNotification(`¡Cristal Principal! +1000 puntos +200 XP`, 3000);

                        if (crystalsFound >= 4 && bosses.length === 0) {
                            checkAchievement('savior');
                            showNotification("¡Misión completada!\n¡Aethermoor ha sido salvado!", 5000);
                            setTimeout(() => gameOver(), 5000);
                        } else if (crystalsFound >= 4) {
                            showNotification("¡Todos los cristales principales encontrados!\nAhora debes derrotar a todos los jefes!", 5000);
                        }
                    } else {
                        score += 200;
                        playerXP += 50;
                        inventory.coins += 25;
                        showNotification(`Cristal Menor: +200 puntos +50 XP`, 1500);
                    }

                    checkAchievement('crystal_collector');
                    checkLevelUp();
                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Actualizar UI
        function updateUI() {
            
            const healthPercent = Math.max(0, playerHealth);
            document.getElementById('health').textContent = Math.floor(healthPercent);
            document.getElementById('health-text').textContent = `${Math.floor(playerHealth)}/100`;
            document.getElementById('score').textContent = score || 0;
            document.getElementById('kills').textContent = kills;
            document.getElementById('crystals').textContent = crystalsFound;
            
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = healthPercent + '%';
            
            // Cambiar color según la salud
            if (healthPercent > 60) {
                healthFill.style.background = 'linear-gradient(to right, #44ff44, #88ff44)';
            } else if (healthPercent > 30) {
                healthFill.style.background = 'linear-gradient(to right, #ffaa00, #ffcc44)';
            } else {
                healthFill.style.background = 'linear-gradient(to right, #ff4444, #ff6666)';
            }

            // Actualizar misión
            const minorCrystalsCollected = Math.max(0, 20 - (crystals.length - 4));
            document.getElementById('mission-text').textContent = 'Encuentra todos los cristales de poder y derrota a los jefes de las mazmorras para salvar Aethermoor.';
            
            const progressEl = document.getElementById('mission-progress');
            if (progressEl) {
                progressEl.innerHTML = `
                    <div style="margin: 5px 0;">• Cristales Principales: ${crystalsFound}/4</div>
                    <div style="margin: 5px 0;">• Cristales Menores: ${minorCrystalsCollected}/20</div>
                    <div style="margin: 5px 0;">• Jefes Derrotados: ${4 - bosses.length}/4</div>
                    <div style="margin: 5px 0;">• Enemigos Eliminados: ${kills}</div>
                    <div style="margin: 5px 0;">• Cofres Abiertos: ${20 - items.filter(i => i.userData.type === 'chest' && !i.userData.opened).length}/20</div>
                `;
            }
        }

        // Mostrar notificación
        function showNotification(text, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        // Game Over
        function gameOver() {
            gameActive = false;
            gamePaused = true;

            const totalCrystalsCollected = 24 - crystals.length; // 4 main + 20 minor
            const isVictory = crystalsFound >= 4 && bosses.length === 0;

            const finalStats = `
                ${isVictory ? '¡VICTORIA TOTAL!' : '¡GAME OVER!'}
                
                Puntuación final: ${score || 0}
                Nivel alcanzado: ${playerLevel}
                Enemigos derrotados: ${kills}
                Cristales Principales: ${crystalsFound}/4
                Cristales Totales: ${totalCrystalsCollected}/24
                Jefes derrotados: ${4 - bosses.length}/4
                Cofres abiertos: ${20 - items.filter(i => i.userData.type === 'chest' && !i.userData.opened).length}/20
                Tiempo jugado: ${Math.floor(gameTime / 60)}m ${Math.floor(gameTime % 60)}s
                
                ${isVictory ? '¡FELICIDADES! Has salvado completamente Aethermoor!' : 'Aethermoor aún necesita tu ayuda...'}
            `;

            showNotification(finalStats, 20000);

            setTimeout(() => {
                document.getElementById('main-menu').style.display = 'flex';
            }, 20000);
        }

        // Actualizar estadísticas
        function updateStats() {
            stats.frames++;
            const now = performance.now();

            if (now - stats.lastTime >= 1000) {
                stats.fps = Math.round((stats.frames * 1000) / (now - stats.lastTime));
                stats.frames = 0;
                stats.lastTime = now;

                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('objects').textContent = scene.children.length;
            }
        }

        // Funciones adicionales
        function toggleInventory() {
            const inv = document.getElementById('inventory');
            inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
        }

        function toggleMinimap() {
            settings.minimap = !settings.minimap;
            document.getElementById('minimap').style.display = settings.minimap ? 'block' : 'none';
        }

        function cycleCameraMode() {
            const modes = ['third', 'first', 'free'];
            const currentIndex = modes.indexOf(cameraMode);
            cameraMode = modes[(currentIndex + 1) % modes.length];
            
            // Resetear configuración de cámara libre
            if (cameraMode === 'free') {
                camera.userData.freeMode = false; // Se activará en el próximo frame
                showNotification('Modo Cámara Libre: Mueve el mouse para rotar, scroll para zoom', 3000);
            } else {
                const modeNames = {
                    'third': '3ª Persona',
                    'first': '1ª Persona (Sigue al jugador)',
                    'free': 'Libre'
                };
                showNotification(`Modo de cámara: ${modeNames[cameraMode]}`, 1500);
            }
        }

        function block() {
            if (inventory.shield > 0) {
                showNotification('Bloqueando...', 500);
            }
        }

        function updateInventoryUI() {
            const items = document.getElementById('inventory-items');
            items.innerHTML = `
                <div>Espada: Nivel ${inventory.sword}</div>
                <div>Escudo: Nivel ${inventory.shield}</div>
                <div>Pociones: ${inventory.potions} (P para usar)</div>
                <div>Llaves: ${inventory.keys}</div>
                <div>Monedas: ${inventory.coins}</div>
                <div>Artefactos: ${inventory.artifacts}</div>
                <div>Nivel: ${playerLevel} (XP: ${playerXP}/${playerLevel * 100})</div>
            `;

            const stats = document.getElementById('player-stats');
            const hours = Math.floor(gameTime / 3600);
            const minutes = Math.floor((gameTime % 3600) / 60);
            stats.innerHTML = `
                <div>Tiempo jugado: ${hours}h ${minutes}m</div>
                <div>Distancia recorrida: ${Math.floor(playerStats.totalDistance)}m</div>
                <div>Saltos realizados: ${playerStats.totalJumps}</div>
                <div>Ataques realizados: ${playerStats.totalAttacks}</div>
            `;
        }

        // Interactuar con NPCs
        function interactWithNearbyNPC() {
            let interacted = false;
            villagers.forEach(villager => {
                if (villager.userData.canInteract && !interacted) {
                    const dialogue = villager.userData.dialogue[villager.userData.currentDialogue];
                    showNotification(`${villager.userData.name || 'Aldeano'}: "${dialogue}"`, 3000);
                    villager.userData.currentDialogue = (villager.userData.currentDialogue + 1) % villager.userData.dialogue.length;
                    interacted = true;
                }
            });
            
            if (!interacted) {
                showNotification("No hay nadie cerca para hablar", 1500);
            }
        }

        // Limpieza de memoria mejorada
        function cleanupMemory() {
            if (window.gc) window.gc();

            // Limpiar objetos eliminados
            scene.traverse((object) => {
                if (object.geometry && object.userData.disposed) {
                    object.geometry.dispose();
                }
                if (object.material && object.userData.disposed) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
            });
        }

        // Auto-limpieza cada 30 segundos (solo si scene existe)
        function startMemoryCleanup() {
            setInterval(() => {
                if (scene) cleanupMemory();
            }, 30000);
        }

        function updateGraphics() {
            if (!renderer) return;

            switch (settings.shadows) {
                case 'off':
                    renderer.shadowMap.enabled = false;
                    break;
                case 'low':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    break;
                case 'high':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    break;
            }
        }

        function setupPerformanceOptimization() {
            setInterval(() => {
                if (stats.fps < 30 && settings.shadows !== 'off') {
                    settings.shadows = 'off';
                    updateGraphics();
                    showNotification('Optimizando rendimiento...', 2000);
                }
            }, 5000);
        }

        // Generar aldeanos
        function spawnVillagers() {
            for (let i = 0; i < 6; i++) {
                const villager = createVillager();
                villagers.push(villager);
                scene.add(villager);
            }
        }

        function createVillager() {
            const villager = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.6, 0.4),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            body.position.y = 0.8;
            villager.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 1.8;
            villager.add(head);

            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 60;
            villager.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            villager.userData = {
                type: 'villager',
                name: ['Aldeano Tom', 'Aldeana Ana', 'Mercader Luis', 'Granjero Pedro', 'Herrera María', 'Mago Sabio'][Math.floor(Math.random() * 6)],
                dialogue: [
                    'Hola Pepe! ¿Cómo va tu aventura?', 
                    'Los cristales están en los reinos elementales', 
                    'Ten cuidado con los enemigos, son más fuertes de noche',
                    'He oído que hay tesoros escondidos por todo Aethermoor',
                    'Los jefes de las mazmorras son muy poderosos, prepárate bien'
                ],
                currentDialogue: 0,
                canInteract: false,
                indicator: null
            };

            return villager;
        }

        // Generar jefes
        function spawnBosses() {
            const bossPositions = [[0, -120], [120, 0], [0, 120], [-120, 0]];

            bossPositions.forEach((pos, i) => {
                const boss = createBoss(pos[0], pos[1], i);
                bosses.push(boss);
                scene.add(boss);
            });
        }

        function createBoss(x, z, type) {
            const boss = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 1),
                new THREE.MeshLambertMaterial({ color: 0x330000 })
            );
            body.position.y = 2;
            body.castShadow = true;
            boss.add(body);

            const head = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.5, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x660000 })
            );
            head.position.y = 4.5;
            head.castShadow = true;
            boss.add(head);

            boss.position.set(x, 0, z);
            boss.userData = {
                type: 'boss',
                health: 200,
                maxHealth: 200,
                damage: 25,
                speed: 2,
                attackRange: 5,
                attackCooldown: 0,
                bossType: type
            };

            return boss;
        }

        // Bucle principal
        function animate() {
            requestAnimationFrame(animate);

            if (!gameActive || gamePaused) {
                renderer.render(scene, camera);
                return;
            }

            const delta = Math.min(clock.getDelta(), 0.033);
            gameTime += delta;

            updatePlayer(delta);
            updateEnemies(delta);
            updateVillagers(delta);
            updateBosses(delta);
            updateItems(delta);
            updateCrystals(delta);
            updateTreasureChests(delta);
            updateWeather(delta);
            updateDayNight(delta);
            updateMinimap();
            updateCompass();
            updateAchievements();
            updateStats();

            renderer.render(scene, camera);
        }

        function updateVillagers(delta) {
            // Solo mostrar indicador de interacción, no diálogo automático
            villagers.forEach(villager => {
                const distance = player.position.distanceTo(villager.position);
                if (distance < 4) {
                    villager.userData.canInteract = true;
                    // Mostrar indicador visual sobre el NPC
                    if (!villager.userData.indicator) {
                        const indicator = new THREE.Mesh(
                            new THREE.RingGeometry(0.5, 0.7, 8),
                            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 })
                        );
                        indicator.position.y = 3;
                        indicator.rotation.x = -Math.PI / 2;
                        villager.add(indicator);
                        villager.userData.indicator = indicator;
                    }
                } else {
                    villager.userData.canInteract = false;
                    if (villager.userData.indicator) {
                        villager.remove(villager.userData.indicator);
                        villager.userData.indicator = null;
                    }
                }
            });
        }

        function updateBosses(delta) {
            bosses.forEach(boss => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < 20) {
                    const direction = new THREE.Vector3()
                        .subVectors(player.position, boss.position)
                        .normalize();

                    boss.position.add(direction.multiplyScalar(boss.userData.speed * delta));
                    boss.lookAt(player.position);

                    if (distance < boss.userData.attackRange && boss.userData.attackCooldown <= 0) {
                        takeDamage(boss.userData.damage);
                        boss.userData.attackCooldown = 2;
                        showNotification(`¡Jefe te ataca! -${boss.userData.damage} HP`, 1500);
                    }
                }

                if (boss.userData.attackCooldown > 0) {
                    boss.userData.attackCooldown -= delta;
                }
            });
        }

        function updateDayNight(delta) {
            if (!settings.dayNight) return;

            // Ciclo más lento y realista (10 minutos = 1 día completo)
            dayTime += delta * 0.00167; // 1/600 para 10 minutos
            if (dayTime > 1) dayTime = 0;

            // Calcular hora del día (0-24)
            const hour = dayTime * 24;
            
            // Intensidad de luz más realista
            let lightIntensity, skyColor, fogColor;
            
            if (hour >= 6 && hour < 8) { // Amanecer
                const t = (hour - 6) / 2;
                lightIntensity = 0.2 + t * 0.6;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x191970), // Azul noche
                    new THREE.Color(0xFF6B35), // Naranja amanecer
                    t
                );
            } else if (hour >= 8 && hour < 18) { // Día
                lightIntensity = 0.8;
                skyColor = new THREE.Color(0x87CEEB); // Azul cielo
            } else if (hour >= 18 && hour < 20) { // Atardecer
                const t = (hour - 18) / 2;
                lightIntensity = 0.8 - t * 0.5;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB), // Azul día
                    new THREE.Color(0xFF4500), // Naranja atardecer
                    t
                );
            } else { // Noche
                lightIntensity = 0.15;
                skyColor = new THREE.Color(0x191970); // Azul noche
            }
            
            // Aplicar cambios
            scene.background = skyColor;
            scene.fog.color = skyColor;
            
            scene.children.forEach(child => {
                if (child.type === 'DirectionalLight') {
                    child.intensity = lightIntensity;
                    // Cambiar color de luz según hora
                    if (hour >= 6 && hour < 8 || hour >= 18 && hour < 20) {
                        child.color.setHex(0xFFB347); // Luz cálida amanecer/atardecer
                    } else if (hour >= 8 && hour < 18) {
                        child.color.setHex(0xFFFFFF); // Luz blanca día
                    } else {
                        child.color.setHex(0x6495ED); // Luz azulada noche
                    }
                }
            });
            
            // Mostrar hora actual
            const timeString = `${Math.floor(hour).toString().padStart(2, '0')}:${Math.floor((hour % 1) * 60).toString().padStart(2, '0')}`;
            document.getElementById('weather-info').innerHTML = `${document.getElementById('weather-info').textContent.split(' | ')[0]} | ${timeString}`;
        }

        function updateMinimap() {
            if (!settings.minimap) return;

            const minimap = document.getElementById('minimap');
            if (!minimap) return;

            // Crear canvas para minimapa si no existe
            let canvas = minimap.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                minimap.appendChild(canvas);
            }

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 150);

            // Fondo
            ctx.fillStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.fillRect(0, 0, 150, 150);

            // Jugador (centro)
            ctx.fillStyle = 'blue';
            ctx.fillRect(72, 72, 6, 6);

            // Enemigos
            ctx.fillStyle = 'red';
            enemies.forEach(enemy => {
                const dx = enemy.position.x - player.position.x;
                const dz = enemy.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 3, 3);
                }
            });

            // Cristales
            ctx.fillStyle = 'yellow';
            crystals.forEach(crystal => {
                const dx = crystal.position.x - player.position.x;
                const dz = crystal.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 4, 4);
                }
            });
        }

        function updateCompass() {
            if (!settings.compass) return;
            const compass = document.getElementById('compass');
            if (!compass) return;

            const rotation = player.rotation.y * (180 / Math.PI);
            compass.style.transform = `rotate(${-rotation}deg)`;

            // Mostrar dirección al cristal más cercano
            if (crystals.length > 0) {
                let closestCrystal = crystals[0];
                let minDistance = player.position.distanceTo(closestCrystal.position);

                crystals.forEach(crystal => {
                    const distance = player.position.distanceTo(crystal.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCrystal = crystal;
                    }
                });

                const direction = new THREE.Vector3()
                    .subVectors(closestCrystal.position, player.position)
                    .normalize();
                const angle = Math.atan2(direction.x, direction.z) * (180 / Math.PI);

                compass.innerHTML = `N<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${angle}deg);">→</div>`;
            } else {
                compass.innerHTML = 'N';
            }
        }

        // Sistemas adicionales - MÁS COFRES
        function spawnTreasureChests() {
            for (let i = 0; i < 20; i++) {
                const chest = new THREE.Group();

                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 1.5),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                box.position.y = 0.5;
                chest.add(box);

                const lid = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.2, 1.6),
                    new THREE.MeshLambertMaterial({ color: 0xA0522D })
                );
                lid.position.y = 1.1;
                chest.add(lid);

                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 80;
                chest.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );

                chest.userData = {
                    type: 'chest',
                    opened: false,
                    contents: {
                        coins: 100 + Math.floor(Math.random() * 200),
                        potions: 1 + Math.floor(Math.random() * 4),
                        artifacts: Math.random() > 0.5 ? 1 : 0,
                        weaponUpgrade: Math.random() > 0.8 ? 1 : 0
                    }
                };

                scene.add(chest);
                items.push(chest);
            }
        }

        function updateTreasureChests(delta) {
            items.forEach((item, index) => {
                if (item.userData.type === 'chest' && !item.userData.opened) {
                    const distance = player.position.distanceTo(item.position);
                    if (distance < 2) {
                        item.userData.opened = true;
                        const contents = item.userData.contents;

                        inventory.coins += contents.coins;
                        inventory.potions += contents.potions;
                        inventory.artifacts += contents.artifacts;
                        if (contents.weaponUpgrade) inventory.sword++;

                        score += contents.coins;
                        updateUI();
                        updateInventoryUI();

                        let message = `Cofre abierto!\n+${contents.coins} monedas\n+${contents.potions} pociones`;
                        if (contents.artifacts) message += `\n+${contents.artifacts} artefactos`;
                        if (contents.weaponUpgrade) message += `\n¡Espada mejorada!`;
                        showNotification(message, 3000);

                        // Cambiar color del cofre
                        item.children[0].material.color.setHex(0x666666);

                        checkAchievement('treasure_hunter');
                    }
                }
            });
        }

        function initWeatherSystem() {
            weather.type = ['clear', 'rain', 'snow', 'fog'][Math.floor(Math.random() * 4)];
            updateWeatherDisplay();
        }

        function updateWeather(delta) {
            // Cambiar clima cada 2 minutos
            if (Math.floor(gameTime) % 120 === 0 && Math.floor(gameTime) > 0) {
                weather.type = ['clear', 'rain', 'snow', 'fog'][Math.floor(Math.random() * 4)];
                updateWeatherDisplay();
            }

            // Efectos visuales del clima
            switch (weather.type) {
                case 'fog':
                    scene.fog.density = 0.02;
                    break;
                case 'rain':
                    scene.fog.density = 0.01;
                    break;
                default:
                    scene.fog.density = 0.005;
            }
        }

        function updateWeatherDisplay() {
            const weatherNames = {
                clear: 'Despejado ☀️',
                rain: 'Lluvia 🌧️',
                snow: 'Nieve ❄️',
                fog: 'Niebla 🌫️'
            };
            const currentTime = document.getElementById('weather-info').textContent.includes('|') ? 
                document.getElementById('weather-info').textContent.split(' | ')[1] : '12:00';
            document.getElementById('weather-info').textContent = `${weatherNames[weather.type]} | ${currentTime}`;
        }

        function initAchievements() {
            const achievementDefs = {
                first_kill: { name: 'Primer Enemigo', desc: 'Derrota tu primer enemigo' },
                treasure_hunter: { name: 'Cazatesoros', desc: 'Abre tu primer cofre' },
                crystal_collector: { name: 'Coleccionista', desc: 'Encuentra tu primer cristal' },
                level_up: { name: 'Crecimiento', desc: 'Alcanza el nivel 2' },
                boss_slayer: { name: 'Matajefes', desc: 'Derrota tu primer jefe' },
                explorer: { name: 'Explorador', desc: 'Recorre 1000 metros' },
                jumper: { name: 'Saltarín', desc: 'Realiza 100 saltos' },
                warrior: { name: 'Guerrero', desc: 'Realiza 50 ataques' },
                savior: { name: 'Salvador de Aethermoor', desc: 'Encuentra todos los cristales' }
            };

            window.achievementDefs = achievementDefs;
        }

        function checkAchievement(id) {
            if (achievements.includes(id)) return;

            let unlocked = false;

            switch (id) {
                case 'first_kill':
                    unlocked = kills >= 1;
                    break;
                case 'treasure_hunter':
                    unlocked = true; // Se llama cuando se abre un cofre
                    break;
                case 'crystal_collector':
                    unlocked = crystalsFound >= 1;
                    break;
                case 'level_up':
                    unlocked = playerLevel >= 2;
                    break;
                case 'boss_slayer':
                    unlocked = bosses.length < 4;
                    break;
                case 'explorer':
                    unlocked = playerStats.totalDistance >= 1000;
                    break;
                case 'jumper':
                    unlocked = playerStats.totalJumps >= 100;
                    break;
                case 'warrior':
                    unlocked = playerStats.totalAttacks >= 50;
                    break;
                case 'savior':
                    unlocked = crystalsFound >= 4;
                    break;
            }

            if (unlocked) {
                achievements.push(id);
                const def = window.achievementDefs[id];
                showNotification(`🏆 LOGRO DESBLOQUEADO!\n${def.name}\n${def.desc}`, 4000);
                updateAchievementsUI();
            }
        }

        function updateAchievements() {
            checkAchievement('first_kill');
            checkAchievement('crystal_collector');
            checkAchievement('level_up');
            checkAchievement('boss_slayer');
            checkAchievement('explorer');
            checkAchievement('jumper');
            checkAchievement('warrior');
            checkAchievement('savior');
        }

        function updateAchievementsUI() {
            const list = document.getElementById('achievement-list');
            list.innerHTML = achievements.map(id => {
                const def = window.achievementDefs[id];
                return `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">🏆 ${def.name}</div>`;
            }).join('');

            if (achievements.length > 0) {
                document.getElementById('achievements').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('achievements').style.display = 'none';
                }, 5000);
            }
        }

        // Sistema de guardado
        function saveGame(slot) {
            if (!gameStarted) {
                // Si no hay juego iniciado, iniciar nuevo juego en este slot
                currentSaveSlot = slot;
                document.getElementById('save-menu').style.display = 'none';
                startGame();
                return;
            }
            
            const saveData = {
                playerHealth: playerHealth || 100,
                score: score || 0,
                kills: kills || 0,
                crystalsFound: crystalsFound || 0,
                playerLevel: playerLevel || 1,
                playerXP: playerXP || 0,
                inventory: inventory || { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 },
                achievements: achievements || [],
                gameTime: gameTime || 0,
                playerStats: playerStats || { totalDistance: 0, totalJumps: 0, totalAttacks: 0 },
                playerPosition: player ? { x: player.position.x, y: player.position.y, z: player.position.z } : { x: 0, y: 0, z: 0 },
                timestamp: Date.now()
            };
            
            localStorage.setItem(`pepeQuest_save_${slot}`, JSON.stringify(saveData));
            showNotification(`Partida guardada en slot ${slot + 1}`, 2000);
            
            // Actualizar la interfaz de slots si está abierta
            setTimeout(() => {
                if (document.getElementById('save-menu').style.display === 'block') {
                    const currentTitle = document.getElementById('save-slots').innerHTML.includes('Nueva Partida') ? 'new' : 'load';
                    if (currentTitle === 'new') {
                        loadNewGameSlots();
                    } else {
                        loadSaveSlots();
                    }
                }
            }, 100);
        }
        
        function loadGame(slot) {
            const saveData = localStorage.getItem(`pepeQuest_save_${slot}`);
            if (!saveData) {
                showNotification('No hay partida guardada en este slot', 2000);
                return false;
            }
            
            const data = JSON.parse(saveData);
            
            // Cargar datos del juego
            playerHealth = data.playerHealth || 100;
            score = data.score || 0;
            kills = data.kills || 0;
            crystalsFound = data.crystalsFound || 0;
            playerLevel = data.playerLevel || 1;
            playerXP = data.playerXP || 0;
            inventory = data.inventory || { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
            achievements = data.achievements || [];
            gameTime = data.gameTime || 0;
            playerStats = data.playerStats || { totalDistance: 0, totalJumps: 0, totalAttacks: 0 };
            
            // Si el juego ya está iniciado, actualizar posición del jugador
            if (player && data.playerPosition) {
                player.position.set(data.playerPosition.x, data.playerPosition.y, data.playerPosition.z);
            }
            
            // Actualizar UI
            if (gameStarted) {
                updateUI();
                updateInventoryUI();
            }
            
            showNotification('Partida cargada correctamente', 2000);
            document.getElementById('save-menu').style.display = 'none';
            return true;
        }
        
        function loadSaveSlots() {
            const slotsContainer = document.getElementById('save-slots');
            slotsContainer.innerHTML = '<h4>Cargar Partida</h4>';
            
            for (let i = 0; i < 3; i++) {
                const saveData = localStorage.getItem(`pepeQuest_save_${i}`);
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                
                if (saveData) {
                    const data = JSON.parse(saveData);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div>Slot ${i + 1} - Nivel ${data.playerLevel}</div>
                        <div style="font-size: 12px; color: #ccc;">${date}</div>
                        <button onclick="loadAndStart(${i})" style="margin: 5px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Cargar</button>
                        <button onclick="saveGame(${i})" style="margin: 5px; padding: 5px 10px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;">Sobrescribir</button>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div>Slot ${i + 1} - Vacío</div>
                        <button onclick="saveGame(${i})" style="margin: 5px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Guardar</button>
                    `;
                }
                
                slotsContainer.appendChild(slotDiv);
            }
        }
        
        function loadNewGameSlots() {
            const slotsContainer = document.getElementById('save-slots');
            slotsContainer.innerHTML = '<h4>Nueva Partida - Selecciona Slot</h4>';
            
            for (let i = 0; i < 3; i++) {
                const saveData = localStorage.getItem(`pepeQuest_save_${i}`);
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                
                if (saveData) {
                    const data = JSON.parse(saveData);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div>Slot ${i + 1} - Nivel ${data.playerLevel}</div>
                        <div style="font-size: 12px; color: #ccc;">${date}</div>
                        <button onclick="startNewGame(${i})" style="margin: 5px; padding: 5px 10px; background: #FF5722; color: white; border: none; border-radius: 3px; cursor: pointer;">Sobrescribir</button>
                        <button onclick="loadAndStart(${i})" style="margin: 5px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Continuar</button>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div>Slot ${i + 1} - Vacío</div>
                        <button onclick="startNewGame(${i})" style="margin: 5px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Nueva Partida</button>
                    `;
                }
                
                slotsContainer.appendChild(slotDiv);
            }
        }
        
        function startNewGame(slot) {
            currentSaveSlot = slot;
            
            // Guardar partida inicial inmediatamente
            const initialSave = {
                playerHealth: 100,
                score: 0,
                kills: 0,
                crystalsFound: 0,
                playerLevel: 1,
                playerXP: 0,
                inventory: { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 },
                achievements: [],
                gameTime: 0,
                playerStats: { totalDistance: 0, totalJumps: 0, totalAttacks: 0 },
                playerPosition: { x: 0, y: 0, z: 0 },
                timestamp: Date.now()
            };
            
            localStorage.setItem(`pepeQuest_save_${slot}`, JSON.stringify(initialSave));
            
            document.getElementById('save-menu').style.display = 'none';
            startGame();
        }
        
        function loadAndStart(slot) {
            const loaded = loadGame(slot);
            if (loaded) {
                if (!gameStarted) {
                    startGame();
                } else {
                    // Si el juego ya está corriendo, solo cerrar el menú
                    document.getElementById('main-menu').style.display = 'none';
                    gameActive = true;
                    gamePaused = false;
                }
            }
        }
        
        // Sistema de tutorial
        let tutorialStep = 0;
        const tutorialSteps = [
            {
                title: "¡Bienvenido a Pepe's Quest!",
                content: "Eres Pepe, el héroe destinado a salvar el reino de Aethermoor. Los cristales de poder han sido dispersados y debes encontrarlos."
            },
            {
                title: "Controles Básicos",
                content: "• WASD: Mover\n• Espacio: Saltar\n• Click: Atacar\n• R: Correr\n• ESC: Pausar"
            },
            {
                title: "Interfaz del Juego",
                content: "• Barra de vida: Arriba al centro\n• Minimapa: Esquina superior derecha\n• Botones de acción: Esquina inferior izquierda\n• Panel de misión: Lado derecho (click en la flecha)"
            },
            {
                title: "Tu Misión",
                content: "1. Encuentra los 4 cristales principales en los reinos elementales\n2. Derrota a los 4 jefes de las mazmorras\n3. Recolecta cristales menores para ganar XP\n4. Abre cofres para obtener mejoras"
            },
            {
                title: "Consejos",
                content: "• Habla con NPCs (Q) para obtener información\n• Usa pociones (P) para curarte\n• Mejora tu equipo derrotando enemigos\n• El minimapa te ayuda a navegar"
            }
        ];
        
        function showTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial').style.display = 'block';
            updateTutorial();
        }
        
        function updateTutorial() {
            const step = tutorialSteps[tutorialStep];
            document.getElementById('tutorial-content').innerHTML = `
                <h3>${step.title}</h3>
                <p style="text-align: left; white-space: pre-line; margin: 20px 0;">${step.content}</p>
                <div style="margin: 20px 0; color: #ccc;">Paso ${tutorialStep + 1} de ${tutorialSteps.length}</div>
            `;
            
            const nextBtn = document.getElementById('tutorial-next');
            nextBtn.textContent = tutorialStep === tutorialSteps.length - 1 ? 'Finalizar' : 'Siguiente';
        }
        
        function updateGraphicsQuality() {
            if (!renderer) return;
            
            switch(settings.graphics) {
                case 'low':
                    renderer.setPixelRatio(0.5);
                    settings.shadows = 'off';
                    break;
                case 'medium':
                    renderer.setPixelRatio(0.75);
                    settings.shadows = 'low';
                    break;
                case 'high':
                    renderer.setPixelRatio(1);
                    settings.shadows = 'high';
                    break;
                case 'ultra':
                    renderer.setPixelRatio(window.devicePixelRatio);
                    settings.shadows = 'high';
                    break;
            }
            updateGraphics();
        }
        
        // Event listeners para tutorial
        document.addEventListener('DOMContentLoaded', () => {
            const tutorialNext = document.getElementById('tutorial-next');
            const tutorialSkip = document.getElementById('tutorial-skip');
            const closeSave = document.getElementById('close-save');
            
            if (tutorialNext) tutorialNext.addEventListener('click', () => {
                if (tutorialStep < tutorialSteps.length - 1) {
                    tutorialStep++;
                    updateTutorial();
                } else {
                    document.getElementById('tutorial').style.display = 'none';
                }
            });
            
            if (tutorialSkip) tutorialSkip.addEventListener('click', () => {
                document.getElementById('tutorial').style.display = 'none';
            });
            
            if (closeSave) closeSave.addEventListener('click', () => {
                document.getElementById('save-menu').style.display = 'none';
            });
        });
        
        // Inicializar cuando la página cargue
        window.addEventListener('load', () => {
            setupMenus();
            detectMobile();
        });
    </script>
</body>

</html>