<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pepe's Quest: El Guardi√°n de Aethermoor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
        }

        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 60, 0.9));
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #FFD700;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), inset 0 2px 10px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        #ui .stat-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 5px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #4CAF50;
            transition: all 0.3s ease;
        }

        #ui .stat-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        #ui .stat-icon {
            font-size: 16px;
            margin-right: 8px;
            width: 20px;
            text-align: center;
        }

        #ui .stat-label {
            font-weight: bold;
            color: #FFD700;
            margin-right: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #ui .stat-value {
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }

        #objective {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #4CAF50;
        }

        #health-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 280px;
            height: 80px;
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 60, 0.9));
            border: 3px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), inset 0 2px 10px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        #player-portrait {
            position: absolute;
            left: 5px;
            top: 5px;
            width: 70px;
            height: 70px;
            background-image: url('assets/images/player.png');
            background-size: cover;
            background-position: center;
            border: 2px solid #FFD700;
            border-radius: 10px;
            box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.2);
        }

        #health-info {
            position: absolute;
            left: 85px;
            top: 8px;
            right: 10px;
            height: 64px;
        }

        #health-label {
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #health-bar-container {
            width: 100%;
            height: 18px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #666;
            border-radius: 9px;
            overflow: hidden;
            margin-bottom: 4px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #44ff44 100%);
            transition: width 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
        }

        #health-text {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            line-height: 18px;
            position: absolute;
            width: 100%;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #level-info {
            color: #FFD700;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            max-width: 300px;
            transition: opacity 0.3s, transform 0.3s;
            cursor: pointer;
        }

        #controls.collapsed {
            opacity: 0.3;
            transform: translateX(-250px);
        }

        #controls:hover {
            opacity: 1 !important;
            transform: translateX(0) !important;
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #4CAF50;
        }

        #back-to-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            padding: 8px 15px;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(244,67,54,0.3);
            transition: all 0.3s ease;
        }

        #back-to-menu:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(244,67,54,0.4);
        }
    </style>
</head>

<body>
    <div id="ui">
        <div class="stat-item">
            <span class="stat-icon">üèÜ</span>
            <span class="stat-label">Puntos:</span>
            <span class="stat-value" id="score">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-icon">‚öîÔ∏è</span>
            <span class="stat-label">Enemigos:</span>
            <span class="stat-value" id="kills">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-icon">üíé</span>
            <span class="stat-label">Cristales:</span>
            <span class="stat-value"><span id="crystals">0</span>/4</span>
        </div>
    </div>

    <div id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Objetos: <span id="objects">0</span></div>
    </div>

    <!-- Bot√≥n volver al men√∫ -->
    <button id="back-to-menu" onclick="window.location.href='index.html'">
        ‚Üê Men√∫
    </button>

    <!-- Panel de misi√≥n -->
    <div id="objective"
        style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; z-index: 100; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 2px solid #4CAF50; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: inline-block; min-width: 250px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <span style="color: #4CAF50; font-size: 14px; font-weight: bold;">üéØ OBJETIVOS</span>
            <button id="toggle-objectives" style="background: none; border: none; color: white; font-size: 12px; cursor: pointer;">‚ûñ</button>
        </div>
        <div id="mission-text" style="font-size: 12px; line-height: 1.4; color: rgba(255,255,255,0.95); word-wrap: break-word;">Cristales: 0/4</div>
    </div>

    <div id="health-bar">
        <div id="player-portrait"></div>
        <div id="health-info">
            <div id="health-label">‚ù§Ô∏è VIDA</div>
            <div id="health-bar-container">
                <div id="health-fill"></div>
                <div id="health-text">100/100</div>
            </div>
            <div id="level-info">‚≠ê Nivel 1 | üí∞ 0</div>
        </div>
    </div>

    <div id="controls">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <span style="font-weight: bold; color: #4CAF50;">üéÆ CONTROLES</span>
            <button id="toggle-controls"
                style="background: none; border: none; color: white; font-size: 12px; cursor: pointer;">‚ûñ</button>
        </div>
        <div id="controls-content" style="font-size: 11px; line-height: 1.3;">
            WASD: Mover | Espacio: Saltar | Click: Atacar<br>
            R: Correr | P: Poci√≥n | Q: Hablar | I: Inventario<br>
            M: Minimapa | C: C√°mara | ESC: Pausa<br>
            F5: Guardar | F6: Men√∫ Guardar | F9: Cargar
        </div>
    </div>

    <div id="notification"></div>



    <!-- Advertencia de Rendimiento Moderna -->
    <div id="performance-warning"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,40,0.95)); backdrop-filter: blur(15px); z-index: 1002; display: flex; justify-content: center; align-items: flex-start; padding-top: 10vh; color: white; padding: 20px; animation: fadeIn 0.5s ease-out;">
        <div
            style="max-width: 400px; background: linear-gradient(145deg, rgba(30,30,50,0.95), rgba(50,50,80,0.95)); border: 1px solid rgba(255,255,255,0.1); border-radius: 20px; padding: 25px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); text-align: center; position: relative; overflow: hidden;">
            <!-- Efecto de brillo -->
            <div
                style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: radial-gradient(circle, rgba(255,100,100,0.1) 0%, transparent 70%); pointer-events: none;">
            </div>

            <div style="position: relative; z-index: 1;">
                <div style="font-size: 3em; margin-bottom: 15px; animation: pulse 2s infinite;">‚ö†Ô∏è</div>
                <h2
                    style="background: linear-gradient(45deg, #ff6b6b, #ffa500); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; color: transparent; margin-bottom: 15px; font-size: 1.5em; font-weight: bold;">
                    ADVERTENCIA DE RENDIMIENTO</h2>

                <div
                    style="background: rgba(255,107,107,0.1); border-left: 3px solid #ff6b6b; padding: 12px; border-radius: 8px; margin: 12px 0; text-align: left;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 1.2em; margin-right: 8px;">üî•</span>
                        <strong style="color: #ff6b6b; font-size: 13px;">RIESGO DE CALENTAMIENTO</strong>
                    </div>
                    <p style="margin: 0; font-size: 12px; line-height: 1.4;">Dispositivos con <strong>2GB-4GB RAM</strong> pueden experimentar calentamiento</p>
                </div>

                <div
                    style="background: rgba(255,165,0,0.1); border-left: 3px solid #ffa500; padding: 12px; border-radius: 8px; margin: 12px 0; text-align: left;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 1.2em; margin-right: 8px;">üì±</span>
                        <strong style="color: #ffa500; font-size: 13px;">RECOMENDACIONES</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 16px; font-size: 11px; line-height: 1.3;">
                        <li>Desactivar part√≠culas de clima</li>
                        <li>Reducir calidad de sombras</li>
                        <li>Sesiones de 15-20 minutos</li>
                        <li>Cerrar otras aplicaciones</li>
                    </ul>
                </div>

                <div
                    style="background: rgba(76,175,80,0.1); border-left: 4px solid #4CAF50; padding: 15px; border-radius: 10px; margin: 20px 0;">
                    <p style="margin: 0; font-size: 13px; color: #4CAF50;">‚ö° Optimizaci√≥n autom√°tica activada</p>
                </div>

                <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; text-align: left;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px;">
                        <input type="checkbox" id="dont-show-warning" style="margin-right: 10px; transform: scale(1.2);">
                        <span>No volver a mostrar esta advertencia</span>
                    </label>
                </div>

                <div style="display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center;">
                    <button id="accept-warning"
                        style="flex: 1; min-width: 140px; padding: 15px 20px; font-size: 1em; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: bold; transition: all 0.3s; box-shadow: 0 4px 15px rgba(76,175,80,0.3);">‚úì
                        Continuar</button>
                    <button id="mobile-settings"
                        style="flex: 1; min-width: 140px; padding: 15px 20px; font-size: 1em; background: linear-gradient(45deg, #FF9800, #f57c00); color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: bold; transition: all 0.3s; box-shadow: 0 4px 15px rgba(255,152,0,0.3);" onclick="
                            const dontShow = document.getElementById('dont-show-warning');
                            if (dontShow && dontShow.checked) {
                                localStorage.setItem('pepequest_show_warning', 'false');
                            }
                            document.getElementById('performance-warning').style.display = 'none';
                        ">üì± Optimizar</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        #performance-warning button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        #performance-warning button:active {
            transform: translateY(0);
        }
    </style>

    <!-- Men√∫ Principal -->
    <div id="main-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h1 style="font-size: 3em; margin-bottom: 30px; text-shadow: 2px 2px 4px #000;">PEPE'S QUEST</h1>
        <h2 style="margin-bottom: 50px; color: #4CAF50;">El Guardi√°n de Aethermoor</h2>
        <button id="start-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nueva
            Aventura</button>
        <button id="load-game"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #9C27B0; color: white; border: none; border-radius: 5px; cursor: pointer;">Cargar
            Partida</button>
        <button id="settings-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuraci√≥n</button>
        <button id="tutorial-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #FF5722; color: white; border: none; border-radius: 5px; cursor: pointer;">Tutorial</button>
        <button id="mobile-exclusive-btn"
            style="padding: 15px 30px; font-size: 1.2em; margin: 10px; background: #607D8B; color: white; border: none; border-radius: 5px; cursor: pointer;">üì±
            Zona M√≥vil</button>
    </div>

    <!-- Men√∫ de Pausa -->
    <div id="pause-menu"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; color: white;">
        <h2 style="margin-bottom: 30px;">JUEGO PAUSADO</h2>
        <button id="resume-game"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Continuar</button>
        <button id="pause-settings"
            style="padding: 10px 20px; margin: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Configuraci√≥n</button>
        <button id="main-menu-btn"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Men√∫
            Principal</button>
    </div>

    <!-- Configuraci√≥n Moderna -->
    <div id="settings-menu"
        style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 600px; max-height: 90vh; background: linear-gradient(135deg, rgba(20,20,30,0.95), rgba(40,40,60,0.95)); backdrop-filter: blur(10px); color: white; border-radius: 20px; z-index: 1001; display: none; overflow-y: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1);">
        <div style="padding: 30px;">
            <div
                style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid rgba(255,255,255,0.1); padding-bottom: 20px;">
                <h2
                    style="margin: 0; font-size: 28px; background: linear-gradient(45deg, #4CAF50, #2196F3); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; color: transparent; text-shadow: 0 2px 10px rgba(76,175,80,0.3);">
                    ‚öôÔ∏è CONFIGURACI√ìN</h2>
            </div>

            <!-- Tabs -->
            <div
                style="display: flex; margin-bottom: 25px; background: rgba(0,0,0,0.3); border-radius: 15px; padding: 5px;">
                <button class="settings-tab" data-tab="graphics"
                    style="flex: 1; padding: 12px; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s;">üéÆ
                    Gr√°ficos</button>
                <button class="settings-tab" data-tab="controls"
                    style="flex: 1; padding: 12px; background: transparent; color: rgba(255,255,255,0.7); border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; margin-left: 5px;">üéØ
                    Controles</button>
                <button class="settings-tab" data-tab="audio"
                    style="flex: 1; padding: 12px; background: transparent; color: rgba(255,255,255,0.7); border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; margin-left: 5px;">üîä
                    Audio</button>
                <button class="settings-tab" data-tab="dev"
                    style="flex: 1; padding: 12px; background: transparent; color: rgba(255,255,255,0.7); border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; margin-left: 5px;">üõ†Ô∏è
                    Dev</button>
                <button class="settings-tab" data-tab="mobile"
                    style="flex: 1; padding: 12px; background: transparent; color: rgba(255,255,255,0.7); border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; margin-left: 5px;">üì±
                    M√≥vil</button>
            </div>

            <!-- Tab Content -->
            <div id="tab-graphics" class="tab-content">
                <div class="setting-group">
                    <label class="setting-label">üåü Calidad de Sombras</label>
                    <select id="shadow-quality" class="modern-select">
                        <option value="off">Desactivadas</option>
                        <option value="low">Bajas</option>
                        <option value="high">Altas</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üì∑ Modo de C√°mara</label>
                    <select id="camera-mode" class="modern-select">
                        <option value="third">3¬™ Persona</option>
                        <option value="first">1¬™ Persona</option>
                        <option value="free">Libre</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üó∫Ô∏è Mostrar Minimapa</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="show-minimap" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üß≠ Mostrar Br√∫jula</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="show-compass" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üåô Ciclo D√≠a/Noche</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="day-night-cycle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üåßÔ∏è Part√≠culas de Clima</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="weather-particles" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">‚ö° Dificultad</label>
                    <select id="difficulty-select" class="modern-select">
                        <option value="easy">F√°cil</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Dif√≠cil</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üíæ Auto-Guardar</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="auto-save" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üñ•Ô∏è Pantalla Completa</label>
                    <button id="fullscreen-btn" class="modern-button">Activar</button>
                </div>
            </div>

            <div id="tab-controls" class="tab-content" style="display: none;">
                <div id="key-bindings">
                    <div class="setting-group">
                        <label class="setting-label">‚¨ÜÔ∏è Mover Adelante</label>
                        <input type="text" id="key-forward" value="W" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">‚¨áÔ∏è Mover Atr√°s</label>
                        <input type="text" id="key-backward" value="S" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">‚¨ÖÔ∏è Mover Izquierda</label>
                        <input type="text" id="key-left" value="A" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">‚û°Ô∏è Mover Derecha</label>
                        <input type="text" id="key-right" value="D" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üèÉ Correr</label>
                        <input type="text" id="key-run" value="R" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üß™ Usar Poci√≥n</label>
                        <input type="text" id="key-potion" value="P" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üéí Inventario</label>
                        <input type="text" id="key-inventory" value="I" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üí¨ Hablar</label>
                        <input type="text" id="key-interact" value="Q" maxlength="1" class="key-input">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üöÄ Saltar</label>
                        <span class="key-display">ESPACIO</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">‚öîÔ∏è Atacar</label>
                        <span class="key-display">CLICK IZQ</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üõ°Ô∏è Bloquear</label>
                        <span class="key-display">CLICK DER</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üì∑ Rotar C√°mara</label>
                        <span class="key-display">SHIFT + CLICK IZQ</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üó∫Ô∏è Minimapa</label>
                        <span class="key-display">M</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üì∑ Cambiar C√°mara</label>
                        <span class="key-display">C</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">‚è∏Ô∏è Pausa</label>
                        <span class="key-display">ESC</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üíæ Guardar R√°pido</label>
                        <span class="key-display">F5</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üìÅ Men√∫ Guardar</label>
                        <span class="key-display">F6</span>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üìÇ Cargar Partida</label>
                        <span class="key-display">F9</span>
                    </div>
                </div>

                <!-- Controles M√≥viles -->
                <div id="mobile-settings"
                    style="margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); display: none;">
                    <h4 style="color: #4CAF50; margin-bottom: 15px;">üì± Controles T√°ctiles</h4>
                    <div class="setting-group">
                        <label class="setting-label">üïπÔ∏è Tama√±o Joystick</label>
                        <div class="slider-container">
                            <input type="range" id="joystick-size" min="80" max="140" value="100" class="modern-slider">
                            <span id="joystick-size-display" class="slider-value">100px</span>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üîò Tama√±o Botones</label>
                        <div class="slider-container">
                            <input type="range" id="button-size" min="40" max="80" value="60" class="modern-slider">
                            <span id="button-size-display" class="slider-value">60px</span>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üëª Opacidad</label>
                        <div class="slider-container">
                            <input type="range" id="controls-opacity" min="30" max="100" value="80"
                                class="modern-slider">
                            <span id="opacity-display" class="slider-value">80%</span>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">üì≥ Vibraci√≥n</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="haptic-feedback" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div id="tab-audio" class="tab-content" style="display: none;">
                <div class="setting-group">
                    <label class="setting-label">üîä Volumen General</label>
                    <div class="slider-container">
                        <input type="range" id="volume-slider" min="0" max="100" value="50" class="modern-slider">
                        <span id="volume-display" class="slider-value">50%</span>
                    </div>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üéµ M√∫sica</label>
                    <div class="slider-container">
                        <input type="range" id="music-volume" min="0" max="100" value="70" class="modern-slider">
                        <span id="music-display" class="slider-value">70%</span>
                    </div>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üîä Efectos de Sonido</label>
                    <div class="slider-container">
                        <input type="range" id="sfx-volume" min="0" max="100" value="80" class="modern-slider">
                        <span id="sfx-display" class="slider-value">80%</span>
                    </div>
                </div>
            </div>

            <div id="tab-dev" class="tab-content" style="display: none;">
                <div class="setting-group">
                    <label class="setting-label">üîç Modo Inspector</label>
                    <button id="inspector-btn" class="modern-button">Activar</button>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üì± Controles Android</label>
                    <button id="dev-controls-btn" class="modern-button">Mostrar</button>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üìä Mostrar FPS</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="show-fps" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">üêõ Modo Debug</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="debug-mode">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">‚ö†Ô∏è Advertencia de Rendimiento</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="show-performance-warning" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div id="tab-mobile" class="tab-content" style="display: none;">
                <div
                    style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255,152,0,0.1); border: 2px solid #FF9800; border-radius: 10px;">
                    <h3 style="color: #FF9800; margin: 0;">üì± CONFIGURACI√ìN OPTIMIZADA PARA M√ìVILES</h3>
                    <p style="font-size: 12px; margin: 10px 0 0 0;">Configuraciones recomendadas para mejor rendimiento
                    </p>
                </div>

                <div class="setting-group">
                    <label class="setting-label">üî• Modo Ahorro de Bater√≠a</label>
                    <button id="battery-saver-btn" class="modern-button">Activar</button>
                </div>

                <div class="setting-group">
                    <label class="setting-label">‚ùÑÔ∏è Desactivar Part√≠culas</label>
                    <button id="disable-particles-btn" class="modern-button">Desactivar Todo</button>
                </div>

                <div class="setting-group">
                    <label class="setting-label">üåÜ Modo Ultra Bajo</label>
                    <button id="ultra-low-btn" class="modern-button">Aplicar</button>
                </div>

                <div class="setting-group">
                    <label class="setting-label">üìä Monitor de Temperatura</label>
                    <div id="temp-monitor" style="color: #4CAF50; font-weight: bold;">Normal üü¢</div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">üì± RAM Detectada</label>
                    <div id="ram-info" style="color: #2196F3; font-weight: bold;">Detectando...</div>
                </div>

                <div id="mobile-ram-details">
                    <!-- Se llenar√° din√°micamente -->
                </div>

                <div id="device-details">
                    <!-- Se llenar√° din√°micamente -->
                </div>

                <div id="auto-opt-info">
                    <!-- Se llenar√° din√°micamente -->
                </div>

                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; margin-top: 20px;">
                    <h4 style="color: #4CAF50; margin-top: 0;">üìù Consejos de Rendimiento:</h4>
                    <ul style="font-size: 12px; line-height: 1.4; margin: 0; padding-left: 20px;">
                        <li>Cierra otras apps antes de jugar</li>
                        <li>Juega en sesiones de 15-20 minutos</li>
                        <li>Usa modo avi√≥n si no necesitas internet</li>
                        <li>Baja el brillo de pantalla</li>
                        <li>Quita la funda si se calienta mucho</li>
                    </ul>
                </div>
            </div>

            <!-- Botones de Acci√≥n -->
            <div
                style="display: flex; gap: 15px; margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button id="controls-btn" class="action-button"
                    style="background: linear-gradient(45deg, #FF9800, #F57C00);">üéÆ Ver Controles</button>
                <button id="tutorial-btn-settings" class="action-button"
                    style="background: linear-gradient(45deg, #FF5722, #D84315);">üìö Tutorial</button>
                <button id="close-settings" class="action-button"
                    style="background: linear-gradient(45deg, #4CAF50, #45a049); margin-left: auto;">‚úÖ Cerrar</button>
            </div>
        </div>
    </div>

    <style>
        .setting-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .setting-group:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
        }

        .setting-label {
            font-weight: bold;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .modern-select {
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            min-width: 120px;
        }

        .modern-button {
            padding: 8px 20px;
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .modern-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }

        .action-button {
            padding: 12px 20px;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            flex: 1;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .key-input {
            width: 40px;
            height: 40px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.2);
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked+.toggle-slider {
            background: #4CAF50;
        }

        input:checked+.toggle-slider:before {
            transform: translateX(26px);
        }

        .modern-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #4CAF50;
        }

        .key-display {
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #4CAF50;
            font-weight: bold;
            font-size: 12px;
            min-width: 80px;
            text-align: center;
        }

        .settings-tab:hover {
            background: linear-gradient(45deg, #4CAF50, #45a049) !important;
            color: white !important;
        }
    </style>

    <!-- Minimapa -->
    <div id="minimap"
        style="position: fixed; top: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 10px; z-index: 100;">
    </div>



    <!-- Inventario Interactivo -->
    <div id="inventory" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 450px; height: 400px; background: linear-gradient(135deg, rgba(20,20,30,0.95), rgba(40,40,60,0.9)); color: white; border-radius: 15px; z-index: 1000; display: none; border: 2px solid #FFD700; box-shadow: 0 20px 40px rgba(0,0,0,0.5);">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);">
            <h3 style="margin: 0; color: #FFD700;">üéí Inventario</h3>
            <button id="close-inventory" style="background: #f44336; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer;">‚úï</button>
        </div>
        <div style="display: flex; height: calc(100% - 60px);">
            <div id="inventory-grid" style="flex: 1; padding: 15px; overflow-y: auto; max-height: 300px;">
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px;" id="item-grid"></div>
            </div>
            <div style="width: 150px; padding: 15px; border-left: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);">
                <h4 style="margin-top: 0; color: #4CAF50;">üìä Stats</h4>
                <div id="player-stats" style="font-size: 11px; line-height: 1.4;"></div>
            </div>
        </div>
    </div>

    <!-- Logros -->
    <div id="achievements"
        style="position: fixed; top: 50%; right: 20px; width: 250px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Logros Desbloqueados</h4>
        <div id="achievement-list"></div>
    </div>

    <!-- Clima -->
    <div id="weather-info"
        style="position: fixed; top: 200px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; z-index: 100; font-size: 12px;">
    </div>

    <!-- Tienda -->
    <div id="shop"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1002; display: none;">
        <h3>Tienda del Mercader</h3>
        <div id="shop-items"></div>
        <button id="close-shop"
            style="padding: 10px 20px; margin-top: 20px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Misiones -->
    <div id="quest-panel"
        style="position: fixed; top: 20px; left: 200px; width: 300px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 100; display: none;">
        <h4>Misiones Activas</h4>
        <div id="quest-list"></div>
    </div>

    <!-- Guardado -->
    <div id="save-menu"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; z-index: 1003; display: none;">
        <h3>Guardar/Cargar Partida</h3>
        <div id="save-slots"></div>
        <button id="close-save"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Tutorial -->
    <div id="tutorial"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1005; display: none; text-align: center;">
        <h2>Tutorial - Pepe's Quest</h2>
        <div id="tutorial-content"></div>
        <button id="tutorial-next"
            style="padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Siguiente</button>
        <button id="tutorial-skip"
            style="padding: 10px 20px; margin: 10px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Saltar</button>
    </div>

    <!-- Panel de Controles -->
    <div id="controls-panel"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; max-height: 80vh; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1006; display: none; overflow-y: auto;">
        <h2>Controles del Juego</h2>
        <div id="controls-content"></div>
        <button id="controls-close"
            style="padding: 10px 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>

    <!-- Sistema de Di√°logos RPG -->
    <div id="dialogue-system"
        style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40%; background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0.8)); z-index: 1008; display: none; color: white;">
        <div style="display: flex; height: 100%; padding: 20px;">
            <div id="npc-portrait"
                style="width: 200px; height: 200px; background: rgba(255,255,255,0.1); border-radius: 15px; margin-right: 20px; display: flex; align-items: center; justify-content: center; font-size: 4em;">
                üë§</div>
            <div style="flex: 1; display: flex; flex-direction: column;">
                <div id="npc-name" style="font-size: 1.5em; color: #4CAF50; margin-bottom: 10px; font-weight: bold;">NPC
                </div>
                <div id="dialogue-text"
                    style="flex: 1; font-size: 1.1em; line-height: 1.4; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; margin-bottom: 15px; overflow-y: auto;">
                    Texto del di√°logo...</div>
                <div id="dialogue-options" style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <!-- Opciones se llenar√°n din√°micamente -->
                </div>
            </div>
        </div>
    </div>

    <!-- Sistema de Misiones Detallado -->
    <div id="quest-detail"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1009; display: none; border: 2px solid #4CAF50;">
        <h3 style="color: #4CAF50; margin-top: 0;">üìã MISI√ìN DETALLADA</h3>
        <div id="quest-detail-content"></div>
        <button id="close-quest-detail"
            style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">Cerrar</button>
    </div>

    <!-- Sistema de Habilidades -->
    <div id="skills-panel"
        style="position: fixed; top: 50%; right: 20px; width: 80px; background: rgba(0,0,0,0.8); border-radius: 10px; padding: 10px; z-index: 100; display: none;">
        <div style="color: white; font-size: 12px; text-align: center; margin-bottom: 10px;">HABILIDADES</div>
        <div id="skill-slots"></div>
    </div>

    <!-- Tabla de Puntuaciones -->
    <div id="leaderboard"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 1010; display: none; border: 2px solid #FF9800;">
        <h3 style="color: #FF9800; margin-top: 0;">üèÜ MEJORES PUNTUACIONES</h3>
        <div id="leaderboard-content"></div>
        <button id="close-leaderboard"
            style="padding: 10px 20px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">Cerrar</button>
    </div>

    <!-- Zona Exclusiva M√≥vil -->
    <div id="mobile-zone"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 1007; display: none; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; padding: 20px;">
        <div id="mobile-content"
            style="max-width: 600px; background: rgba(33,150,243,0.1); border: 2px solid #2196F3; border-radius: 15px; padding: 30px;">
            <h2 style="color: #2196F3; margin-bottom: 20px;">üì± ZONA EXCLUSIVA M√ìVIL</h2>
            <div id="mobile-zone-content">
                <!-- Contenido se llenar√° din√°micamente -->
            </div>
            <button id="close-mobile-zone"
                style="padding: 15px 30px; font-size: 1.2em; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 20px;">Cerrar</button>
        </div>
    </div>

    <!-- MEJORADO: Controles Ultra-Responsivos -->
    <div id="mobile-controls" style="position: fixed; bottom: 20px; left: 20px; z-index: 100; display: none;">
        <div id="joystick"
            style="width: 110px; height: 110px; background: rgba(255,255,255,0.3); border: 3px solid rgba(255,255,255,0.6); border-radius: 50%; position: relative; box-shadow: 0 0 15px rgba(0,0,0,0.4);">
            <div id="joystick-knob"
                style="width: 45px; height: 45px; background: rgba(255,255,255,0.9); border: 2px solid rgba(255,255,255,1); border-radius: 50%; position: absolute; top: 32.5px; left: 32.5px; box-shadow: 0 3px 8px rgba(0,0,0,0.4);">
            </div>
        </div>
    </div>

    <button id="mobile-attack"
        style="position: fixed; right: 20px; bottom: 20px; width: 70px; height: 70px; background: linear-gradient(145deg, #f44336, #d32f2f); color: white; border: none; border-radius: 50%; font-size: 24px; font-weight: bold; box-shadow: 0 5px 12px rgba(244,67,54,0.4); z-index: 100; display: none;">‚öîÔ∏è</button>
    <button id="mobile-jump"
        style="position: fixed; right: 20px; bottom: 100px; width: 70px; height: 70px; background: linear-gradient(145deg, #4CAF50, #388e3c); color: white; border: none; border-radius: 50%; font-size: 24px; font-weight: bold; box-shadow: 0 5px 12px rgba(76,175,80,0.4); z-index: 100; display: none;">üöÄ</button>
    <button id="mobile-potion"
        style="position: fixed; right: 110px; bottom: 20px; width: 60px; height: 60px; background: linear-gradient(145deg, #9C27B0, #7b1fa2); color: white; border: none; border-radius: 50%; font-size: 20px; box-shadow: 0 4px 10px rgba(156,39,176,0.4); z-index: 100; display: none;">üß™</button>
    <button id="mobile-inventory"
        style="position: fixed; right: 110px; bottom: 90px; width: 60px; height: 60px; background: linear-gradient(145deg, #FF9800, #f57c00); color: white; border: none; border-radius: 50%; font-size: 20px; box-shadow: 0 4px 10px rgba(255,152,0,0.4); z-index: 100; display: none;">üéí</button>
    <button id="mobile-camera"
        style="position: fixed; right: 110px; bottom: 160px; width: 60px; height: 60px; background: linear-gradient(145deg, #2196F3, #1976d2); color: white; border: none; border-radius: 50%; font-size: 20px; box-shadow: 0 4px 10px rgba(33,150,243,0.4); z-index: 100; display: none;">üì∑</button>

    <!-- Indicador de c√°mara t√°ctil -->
    <div id="camera-hint"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 200; display: none; text-align: center;">
        üì± Desliza la pantalla para rotar la c√°mara
    </div>

    <!-- Bot√≥n de pausa para m√≥vil -->
    <div id="mobile-pause" style="position: fixed; top: 20px; right: 20px; z-index: 101; display: none;">
        <button onclick="togglePause()"
            style="width: 50px; height: 50px; background: rgba(0,0,0,0.7); color: white; border: 2px solid white; border-radius: 50%; font-size: 16px; cursor: pointer;">‚è∏</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables para animaci√≥n de salto
        let jumpAnimation = {
            isJumping: false,
            startTime: 0,
            duration: 800 // 0.8 segundos
        };
        // Variables globales
        let scene, camera, renderer, clock;
        let player, enemies = [], items = [], crystals = [], villagers = [], bosses = [];
        let keys = {}, gameActive = false, gamePaused = false, gameStarted = false;
        let playerHealth = 100, score = 0, kills = 0, crystalsFound = 0, playerLevel = 1, playerXP = 0;
        // Asegurar que score siempre sea un n√∫mero v√°lido
        score = Number(score) || 0;
        let stats = { fps: 0, lastTime: 0, frames: 0 };
        let cameraMode = 'third', dayTime = 0.5, isMobile = false;
        let inventory = { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
        let currentQuest = { name: 'Encuentra los Cristales', progress: 0, total: 4 };
        let settings = { shadows: 'low', minimap: true, compass: true, dayNight: false, audio: true, volume: 0.5, autoSave: true, difficulty: 'normal' };
        let keyBindings = { forward: 'KeyW', backward: 'KeyS', left: 'KeyA', right: 'KeyD', run: 'KeyR', potion: 'KeyP', inventory: 'KeyI', interact: 'KeyQ' };
        let mobileSettings = { joystickSize: 100, buttonSize: 60, opacity: 80, hapticFeedback: true };
        let weather = { type: 'clear', intensity: 0, particles: [], lastChange: 0 };
        let achievements = [];
        let gameTime = 0;
        let playerStats = { totalDistance: 0, totalJumps: 0, totalAttacks: 0, questsCompleted: 0, secretsFound: 0 };
        let merchants = [], quests = [], particles = [], doors = [], platforms = [];
        let audioContext, sounds = {};
        let saveSlots = [null, null, null];
        let currentSaveSlot = 0;

        // Nuevos sistemas
        let playerSkills = { fireball: 0, heal: 0, shield: 0, teleport: 0 };
        let skillCooldowns = { fireball: 0, heal: 0, shield: 0, teleport: 0 };
        let currentDialogue = null;
        let leaderboard = [];
        let unlockedContent = { areas: ['central'], skills: [], achievements: [] };
        let gameSession = { startTime: Date.now(), deaths: 0, itemsCollected: 0 };

        // Configuraci√≥n
        const config = {
            playerSpeed: 8,
            jumpForce: 12,
            gravity: -30,
            attackRange: 4,
            worldSize: 300,
            maxEnemies: isMobile ? 15 : 30,
            maxParticles: isMobile ? 100 : 200
        };

        // Variables globales para rendimiento
        let deviceRAM = 'unknown';
        let performanceWarningShown = localStorage.getItem('pepequest_show_warning') === 'false';
        let weatherParticlesEnabled = true;
        
        // Ocultar advertencia si est√° desactivada
        if (performanceWarningShown) {
            document.addEventListener('DOMContentLoaded', () => {
                const warning = document.getElementById('performance-warning');
                if (warning) warning.style.display = 'none';
            });
        }

        // Detectar dispositivo m√≥vil + modo inspector
        function detectMobile() {
            const realMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const inspectorMode = window.innerWidth <= 768 || localStorage.getItem('forceInspectorMode') === 'true';

            isMobile = realMobile || inspectorMode;

            // Detectar RAM aproximada
            detectDeviceRAM();

            // Detectar informaci√≥n adicional del dispositivo
            detectDeviceInfo();

            // Aplicar optimizaciones autom√°ticas basadas en RAM
            applyAutoOptimizations();

            // Detectar tipos espec√≠ficos de m√≥vil
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const isWindowsPhone = /IEMobile/i.test(navigator.userAgent);

            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                // Mostrar botones en m√≥viles reales O en modo inspector
                if (realMobile || inspectorMode) {
                    document.getElementById('mobile-attack').style.display = 'block';
                    document.getElementById('mobile-jump').style.display = 'block';
                    document.getElementById('mobile-potion').style.display = 'block';
                    document.getElementById('mobile-inventory').style.display = 'block';
                    document.getElementById('mobile-camera').style.display = 'block';
                    document.getElementById('mobile-pause').style.display = 'block';
                }
                setupMobileControls();
                optimizeForMobile();

                // Configuraciones espec√≠ficas por plataforma
                if (isAndroid) {
                    setupAndroidSpecific();
                } else if (isIOS) {
                    setupIOSSpecific();
                } else if (isWindowsPhone) {
                    setupWindowsPhoneSpecific();
                } else {
                    setupGenericMobileSpecific();
                }
            }
        }

        // Configuraci√≥n espec√≠fica para Android
        function setupAndroidSpecific() {
            // Prevenir el men√∫ contextual en Android
            document.addEventListener('contextmenu', e => e.preventDefault());

            // Optimizar para diferentes versiones de Android
            const androidVersion = parseFloat(navigator.userAgent.match(/Android (\d+\.\d+)/)?.[1] || '0');

            if (androidVersion < 7.0) {
                // Android m√°s antiguo - m√°s optimizaciones
                config.playerSpeed = 6;
                settings.shadows = 'off';
                config.worldSize = 150; // Mundo m√°s peque√±o
            }

            // Configurar wake lock para mantener pantalla activa
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => { });
            }

            // ARREGLADO: Fullscreen persistente para m√≥viles
            if (gameActive && isMobile) {
                enterFullscreen();
                // Mantener fullscreen activo
                setInterval(() => {
                    if (gameActive && !document.fullscreenElement && !document.webkitFullscreenElement) {
                        enterFullscreen();
                    }
                }, 3000);
            }

            // Bot√≥n flotante de configuraci√≥n r√°pida para Android
            addAndroidQuickSettings();

            // Gestos de Android
            setupAndroidGestures();

            // Notificaciones nativas de Android
            setupAndroidNotifications();
        }

        // Configurar controles personalizables
        function setupKeyBindings() {
            const keyInputs = ['forward', 'backward', 'left', 'right', 'run', 'potion', 'inventory', 'interact'];
            keyInputs.forEach(action => {
                const input = document.getElementById(`key-${action}`);
                if (input) {
                    input.addEventListener('input', (e) => {
                        const key = e.target.value.toUpperCase();
                        if (key) {
                            keyBindings[action] = 'Key' + key;
                            localStorage.setItem('pepequest_keybindings', JSON.stringify(keyBindings));
                        }
                    });
                }
            });

            // Cargar configuraci√≥n guardada
            const saved = localStorage.getItem('pepequest_keybindings');
            if (saved) {
                keyBindings = JSON.parse(saved);
                Object.keys(keyBindings).forEach(action => {
                    const input = document.getElementById(`key-${action}`);
                    if (input) input.value = keyBindings[action].replace('Key', '');
                });
            }
        }

        // Configurar ajustes m√≥viles
        function setupMobileSettings() {
            if (!isMobile) return;

            document.getElementById('mobile-settings').style.display = 'block';

            const joystickSizeSlider = document.getElementById('joystick-size');
            const buttonSizeSlider = document.getElementById('button-size');
            const opacitySlider = document.getElementById('controls-opacity');
            const hapticCheck = document.getElementById('haptic-feedback');

            if (joystickSizeSlider) {
                joystickSizeSlider.addEventListener('input', (e) => {
                    mobileSettings.joystickSize = e.target.value;
                    document.getElementById('joystick-size-display').textContent = e.target.value + 'px';
                    updateMobileControls();
                });
            }

            if (buttonSizeSlider) {
                buttonSizeSlider.addEventListener('input', (e) => {
                    mobileSettings.buttonSize = e.target.value;
                    document.getElementById('button-size-display').textContent = e.target.value + 'px';
                    updateMobileControls();
                });
            }

            if (opacitySlider) {
                opacitySlider.addEventListener('input', (e) => {
                    mobileSettings.opacity = e.target.value;
                    document.getElementById('opacity-display').textContent = e.target.value + '%';
                    updateMobileControls();
                });
            }

            if (hapticCheck) {
                hapticCheck.addEventListener('change', (e) => {
                    mobileSettings.hapticFeedback = e.target.checked;
                });
            }

            // Cargar configuraci√≥n guardada
            const saved = localStorage.getItem('pepequest_mobilesettings');
            if (saved) {
                mobileSettings = JSON.parse(saved);
                if (joystickSizeSlider) joystickSizeSlider.value = mobileSettings.joystickSize;
                if (buttonSizeSlider) buttonSizeSlider.value = mobileSettings.buttonSize;
                if (opacitySlider) opacitySlider.value = mobileSettings.opacity;
                if (hapticCheck) hapticCheck.checked = mobileSettings.hapticFeedback;
                updateMobileControls();
            }
        }

        // Actualizar controles m√≥viles
        function updateMobileControls() {
            const joystick = document.getElementById('joystick');
            const buttons = document.querySelectorAll('#mobile-controls button');

            if (joystick) {
                joystick.style.width = mobileSettings.joystickSize + 'px';
                joystick.style.height = mobileSettings.joystickSize + 'px';
                joystick.style.opacity = mobileSettings.opacity / 100;
            }

            buttons.forEach(button => {
                if (button.id !== 'mobile-pause') {
                    button.style.width = mobileSettings.buttonSize + 'px';
                    button.style.height = mobileSettings.buttonSize + 'px';
                    button.style.opacity = mobileSettings.opacity / 100;
                }
            });

            localStorage.setItem('pepequest_mobilesettings', JSON.stringify(mobileSettings));
        }

        // Optimizar para m√≥viles
        function optimizeForMobile() {
            // Reducir calidad autom√°ticamente en m√≥viles
            settings.shadows = 'off';
            updateGraphics();

            // Ajustar controles para pantalla t√°ctil
            document.body.style.touchAction = 'none';
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
            document.body.style.webkitTouchCallout = 'none';

            // Prevenir zoom en iOS y Android
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            document.addEventListener('touchmove', e => {
                if (e.scale !== 1) e.preventDefault();
            }, { passive: false });

            // Orientaci√≥n de pantalla preferida horizontal
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => { });
            }

            // Mostrar bot√≥n de pausa m√≥vil
            document.getElementById('mobile-pause').style.display = 'block';

            // Ajustar UI para m√≥vil
            adjustMobileUI();

            // Optimizar rendimiento para Android
            optimizeAndroidPerformance();

            // Mostrar hint de c√°mara t√°ctil
            setTimeout(() => {
                if (gameActive) {
                    document.getElementById('camera-hint').style.display = 'block';
                    setTimeout(() => {
                        document.getElementById('camera-hint').style.display = 'none';
                    }, 4000);
                }
            }, 3000);
        }

        // Ajustar UI para m√≥vil
        function adjustMobileUI() {
            // Hacer elementos de UI m√°s grandes
            const ui = document.getElementById('ui');
            if (ui) {
                ui.style.fontSize = '14px';
                ui.style.padding = '15px';
            }

            const stats = document.getElementById('stats');
            if (stats) {
                stats.style.fontSize = '12px';
                stats.style.padding = '10px';
            }

            const objective = document.getElementById('objective');
            if (objective) {
                objective.style.fontSize = '14px';
                objective.style.padding = '20px';
                objective.style.bottom = '100px'; // Mover arriba para no tapar controles
            }

            const controls = document.getElementById('controls');
            if (controls) {
                controls.style.display = 'none'; // Ocultar en m√≥vil
            }
        }

        // Optimizar rendimiento para Android
        function optimizeAndroidPerformance() {
            // Reducir FPS objetivo en Android
            const targetFPS = 30;

            // Reducir complejidad de objetos
            config.worldSize = 200;

            // Limitar n√∫mero de enemigos seg√∫n rendimiento
            const maxEnemies = navigator.hardwareConcurrency > 4 ? 20 : 12;

            // Desactivar efectos costosos solo si scene existe
            if (scene && scene.fog) {
                scene.fog.density = 0.01;
            }

            // Usar geometr√≠as m√°s simples
            if (renderer) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                // Modo de bajo consumo
                renderer.powerPreference = 'low-power';
            }

            // Limpieza autom√°tica de memoria m√°s frecuente
            setInterval(() => {
                if (enemies.length > maxEnemies) {
                    // Eliminar enemigos m√°s lejanos
                    enemies.sort((a, b) =>
                        player.position.distanceTo(b.position) - player.position.distanceTo(a.position)
                    );
                    const toRemove = enemies.splice(maxEnemies);
                    toRemove.forEach(enemy => scene.remove(enemy));
                }
            }, 10000);
        }

        // Configurar men√∫s
        // Sistema de tabs para configuraci√≥n
        function setupSettingsTabs() {
            const tabs = document.querySelectorAll('.settings-tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;

                    // Actualizar tabs
                    tabs.forEach(t => {
                        t.style.background = 'transparent';
                        t.style.color = 'rgba(255,255,255,0.7)';
                    });
                    tab.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    tab.style.color = 'white';

                    // Actualizar contenido
                    contents.forEach(content => content.style.display = 'none');
                    document.getElementById(`tab-${targetTab}`).style.display = 'block';
                });
            });
        }

        function setupMenus() {
            // Configurar advertencias iniciales
            setupPerformanceWarning();

            const startBtn = document.getElementById('start-game');
            const settingsBtn = document.getElementById('settings-btn');
            const controlsBtn = document.getElementById('controls-btn');
            const tutorialBtn = document.getElementById('tutorial-btn');
            const tutorialBtnSettings = document.getElementById('tutorial-btn-settings');
            const closeSettingsBtn = document.getElementById('close-settings');
            const resumeBtn = document.getElementById('resume-game');
            const pauseSettingsBtn = document.getElementById('pause-settings');
            const mainMenuBtn = document.getElementById('main-menu-btn');
            const mobileExclusiveBtn = document.getElementById('mobile-exclusive-btn');

            if (startBtn) startBtn.addEventListener('click', startGame);
            if (settingsBtn) settingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (controlsBtn) controlsBtn.addEventListener('click', showControls);
            if (tutorialBtn) tutorialBtn.addEventListener('click', showTutorial);
            if (tutorialBtnSettings) tutorialBtnSettings.addEventListener('click', showTutorial);
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'none';
            });
            if (resumeBtn) resumeBtn.addEventListener('click', resumeGame);
            if (pauseSettingsBtn) pauseSettingsBtn.addEventListener('click', () => {
                document.getElementById('settings-menu').style.display = 'block';
            });
            if (mainMenuBtn) mainMenuBtn.addEventListener('click', () => {
                gameActive = false;
                gamePaused = false;
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
            });

            // Botones de guardado/carga
            const loadBtn = document.getElementById('load-game');
            if (loadBtn) loadBtn.addEventListener('click', showSaveMenu);

            // Configuraci√≥n
            const shadowQuality = document.getElementById('shadow-quality');
            const cameraSelect = document.getElementById('camera-mode');
            const minimapCheck = document.getElementById('show-minimap');
            const compassCheck = document.getElementById('show-compass');
            const dayNightCheck = document.getElementById('day-night-cycle');

            if (shadowQuality) shadowQuality.addEventListener('change', (e) => {
                settings.shadows = e.target.value;
                updateGraphics();
            });
            if (cameraSelect) cameraSelect.addEventListener('change', (e) => {
                cameraMode = e.target.value;
            });
            if (minimapCheck) minimapCheck.addEventListener('change', (e) => {
                settings.minimap = e.target.checked;
                document.getElementById('minimap').style.display = e.target.checked ? 'block' : 'none';
            });

            if (dayNightCheck) dayNightCheck.addEventListener('change', (e) => {
                settings.dayNight = e.target.checked;
            });

            // Fullscreen
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Inspector mode
            const inspectorBtn = document.getElementById('inspector-btn');
            if (inspectorBtn) inspectorBtn.addEventListener('click', toggleInspectorMode);

            // Dev controls
            const devControlsBtn = document.getElementById('dev-controls-btn');
            if (devControlsBtn) devControlsBtn.addEventListener('click', toggleDevControls);

            // Detectar cambios de fullscreen
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.addEventListener('mozfullscreenchange', updateFullscreenButton);
            document.addEventListener('MSFullscreenChange', updateFullscreenButton);

            // Configuraciones adicionales
            const difficultySelect = document.getElementById('difficulty-select');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeDisplay = document.getElementById('volume-display');
            const autoSaveCheck = document.getElementById('auto-save');

            if (difficultySelect) difficultySelect.addEventListener('change', (e) => {
                changeDifficulty(e.target.value);
            });
            if (volumeSlider) volumeSlider.addEventListener('input', (e) => {
                settings.volume = e.target.value / 100;
                volumeDisplay.textContent = e.target.value + '%';
            });
            if (autoSaveCheck) autoSaveCheck.addEventListener('change', (e) => {
                settings.autoSave = e.target.checked;
            });

            // Bot√≥n zona m√≥vil
            if (mobileExclusiveBtn) mobileExclusiveBtn.addEventListener('click', showMobileZone);

            // Configurar controles personalizables
            setupKeyBindings();
            setupMobileSettings();
            setupSettingsTabs();
            setupMobileOptimizations();
        }

        function showControls() {
            const content = document.getElementById('controls-content');

            if (isMobile) {
                content.innerHTML = `
                    <div style="text-align: left; line-height: 1.6;">
                        <h3 style="color: #4CAF50; text-align: center;">Controles M√≥viles</h3>
                        <div style="margin: 15px 0;">
                            <div style="margin: 8px 0;"><strong>Joystick:</strong> Mover (borde para correr)</div>
                            <div style="margin: 8px 0;"><strong>‚öîÔ∏è Bot√≥n Rojo:</strong> Atacar</div>
                            <div style="margin: 8px 0;"><strong>‚Üë Bot√≥n Verde:</strong> Saltar</div>
                            <div style="margin: 8px 0;"><strong>üß™ Bot√≥n Morado:</strong> Usar Poci√≥n</div>
                            <div style="margin: 8px 0;"><strong>üéí Bot√≥n Naranja:</strong> Inventario</div>
                            <div style="margin: 8px 0;"><strong>üì∑ Bot√≥n Azul:</strong> Cambiar C√°mara</div>
                            <div style="margin: 8px 0;"><strong>üíæ Bot√≥n Morado:</strong> Guardar Partida</div>
                            <div style="margin: 8px 0;"><strong>Doble Toque:</strong> Hablar con NPCs</div>
                            <div style="margin: 8px 0;"><strong>‚è∏ Bot√≥n Pausa:</strong> Pausar Juego</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>Tip:</strong> Puedes personalizar el tama√±o y opacidad de los controles en Configuraci√≥n.
                        </div>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <div style="text-align: left; line-height: 1.6;">
                        <h3 style="color: #4CAF50; text-align: center;">Controles PC</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                            <div>
                                <h4 style="color: #FF9800;">Movimiento</h4>
                                <div style="margin: 5px 0;"><strong>${keyBindings.forward.replace('Key', '')}:</strong> Mover Adelante</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.backward.replace('Key', '')}:</strong> Mover Atr√°s</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.left.replace('Key', '')}:</strong> Mover Izquierda</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.right.replace('Key', '')}:</strong> Mover Derecha</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.run.replace('Key', '')}:</strong> Correr</div>
                                <div style="margin: 5px 0;"><strong>Espacio:</strong> Saltar</div>
                            </div>
                            <div>
                                <h4 style="color: #FF9800;">Acciones</h4>
                                <div style="margin: 5px 0;"><strong>Click Izq:</strong> Atacar</div>
                                <div style="margin: 5px 0;"><strong>Click Der:</strong> Bloquear</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.potion.replace('Key', '')}:</strong> Usar Poci√≥n</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.interact.replace('Key', '')}:</strong> Hablar con NPCs</div>
                                <div style="margin: 5px 0;"><strong>${keyBindings.inventory.replace('Key', '')}:</strong> Inventario</div>
                                <div style="margin: 5px 0;"><strong>M:</strong> Minimapa</div>
                            </div>
                        </div>
                        <div style="margin: 15px 0;">
                            <h4 style="color: #FF9800;">Sistema</h4>
                            <div style="margin: 5px 0;"><strong>C:</strong> Cambiar C√°mara</div>
                            <div style="margin: 5px 0;"><strong>F5:</strong> Guardar R√°pido</div>
                            <div style="margin: 5px 0;"><strong>F6:</strong> Men√∫ Guardar/Cargar</div>
                            <div style="margin: 5px 0;"><strong>F9:</strong> Cargar √öltima Partida</div>
                            <div style="margin: 5px 0;"><strong>ESC:</strong> Pausar Juego</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>Tip:</strong> Puedes personalizar las teclas en Configuraci√≥n ‚Üí Controles.
                        </div>
                    </div>
                `;
            }

            document.getElementById('controls-panel').style.display = 'block';
        }

        // Cerrar panel de controles
        document.getElementById('controls-close').addEventListener('click', () => {
            document.getElementById('controls-panel').style.display = 'none';
        });

        function showTutorial() {
            const tutorialSteps = [
                "Bienvenido a Pepe's Quest! Eres el √∫ltimo guardi√°n de Aethermoor.",
                "Tu misi√≥n: Encontrar los 4 cristales principales y derrotar a todos los jefes.",
                "Explora los reinos elementales: Fuego, Agua, Aire y Tierra.",
                "Recoge monedas, pociones y mejoras de armas por el camino.",
                "Habla con aldeanos para obtener pistas sobre los cristales.",
                "Abre cofres para conseguir tesoros y mejoras.",
                "Derrota enemigos para ganar experiencia y subir de nivel.",
                "Usa pociones cuando tu salud est√© baja.",
                "¬°Buena suerte, h√©roe! Aethermoor cuenta contigo."
            ];

            let currentStep = 0;

            function showTutorialStep() {
                if (currentStep < tutorialSteps.length) {
                    const content = document.getElementById('tutorial-content');
                    content.innerHTML = `
                        <div style="margin: 20px 0; font-size: 16px;">
                            <div style="color: #4CAF50; margin-bottom: 10px;">Paso ${currentStep + 1} de ${tutorialSteps.length}</div>
                            <div>${tutorialSteps[currentStep]}</div>
                        </div>
                    `;

                    const nextBtn = document.getElementById('tutorial-next');
                    const skipBtn = document.getElementById('tutorial-skip');

                    nextBtn.textContent = currentStep === tutorialSteps.length - 1 ? 'Finalizar' : 'Siguiente';

                    nextBtn.onclick = () => {
                        currentStep++;
                        if (currentStep >= tutorialSteps.length) {
                            closeTutorial();
                        } else {
                            showTutorialStep();
                        }
                    };

                    skipBtn.onclick = closeTutorial;
                }
            }

            function closeTutorial() {
                document.getElementById('tutorial').style.display = 'none';
                currentStep = 0;
            }

            document.getElementById('tutorial').style.display = 'block';
            showTutorialStep();
        }

        // Iniciar juego
        function startGame() {
            showSlotSelection();
        }

        // Seleccionar slot para nueva aventura
        function showSlotSelection() {
            const container = document.getElementById('save-slots');
            container.innerHTML = '<h4>Selecciona un Slot para Nueva Aventura:</h4>';

            for (let i = 0; i < 3; i++) {
                const saved = localStorage.getItem(`pepequest_slot_${i}`);
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 5px; cursor: pointer; border: 2px solid transparent;';
                slotDiv.onmouseover = () => slotDiv.style.borderColor = '#4CAF50';
                slotDiv.onmouseout = () => slotDiv.style.borderColor = 'transparent';

                if (saved) {
                    const data = JSON.parse(saved);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Nivel ${data.playerLevel || 1}</div>
                        <div style="font-size: 12px; color: #ccc; margin: 5px 0;">${date}</div>
                        <div style="color: #ff9800; font-size: 12px;">‚ö†Ô∏è Se sobrescribir√° la partida existente</div>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Vac√≠o</div>
                        <div style="color: #4CAF50; font-size: 12px;">‚úì Listo para nueva aventura</div>
                    `;
                }

                slotDiv.onclick = () => startNewGame(i);
                container.appendChild(slotDiv);
            }

            document.getElementById('save-menu').style.display = 'block';
        }

        // Iniciar nueva aventura en slot seleccionado
        function startNewGame(slot) {
            currentSaveSlot = slot;
            document.getElementById('save-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'none';

            if (!gameStarted) {
                init();
                gameStarted = true;
            } else {
                // Reiniciar variables para nueva partida
                playerHealth = 100; score = 0; kills = 0; crystalsFound = 0;
                playerLevel = 1; playerXP = 0; gameTime = 0;
                inventory = { sword: 1, shield: 1, potions: 3, keys: 0, coins: 0, artifacts: 0, magic: 0 };
                achievements = []; playerStats = { totalDistance: 0, totalJumps: 0, totalAttacks: 0 };
                if (player) player.position.set(0, 0, 0);
            }

            gameActive = true;
            gamePaused = false;

            // ARREGLADO: Activar fullscreen al iniciar juego en m√≥vil (con delay)
            if (isMobile && document.hasFocus()) {
                setTimeout(enterFullscreen, 500);
            }

            updateUI();
            updateInventoryUI();
            showNotification(`Nueva aventura iniciada en Slot ${slot + 1}`, 3000);
        }

        // Pausar/Reanudar juego
        function togglePause() {
            if (!gameActive) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-menu').style.display = gamePaused ? 'flex' : 'none';
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-menu').style.display = 'none';
        }

        // Inicializar juego
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // Crear c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Crear renderizador
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.body.appendChild(renderer.domElement);

            // Crear luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Crear mundo
            createWorld();
            createPlayer();
            spawnEnemies();
            spawnVillagers();
            spawnItems();
            spawnCrystals();
            spawnBosses();
            spawnTreasureChests();
            initWeatherSystem();
            initAchievements();

            // Configurar eventos
            setupControls();
            setupMenus();
            detectMobile();

            // Iniciar reloj
            clock = new THREE.Clock();
            stats.lastTime = performance.now();

            // Configurar rendimiento autom√°tico
            setupPerformanceOptimization();

            // Mostrar lore inicial
            showNotification("¬°Bienvenido a Aethermoor, Pepe!\n\nLos 4 reinos han ca√≠do en la oscuridad.\nEncuentra los cristales de poder para restaurar la paz.", 5000);

            // Actualizar UI inicial
            updateUI();
            updateInventoryUI();

            // Iniciar bucle de juego
            animate();
        }

        // Crear mundo
        function createWorld() {
            // Terreno base expandido
            const groundGeometry = new THREE.PlaneGeometry(800, 800);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Terrenos adicionales en diferentes elevaciones
            const terrainAreas = [
                { x: 200, z: 200, size: 120, color: 0x8FBC8F, y: 2 },
                { x: -200, z: 200, size: 140, color: 0x9ACD32, y: 1 },
                { x: 200, z: -200, size: 110, color: 0x228B22, y: 3 },
                { x: -200, z: -200, size: 130, color: 0x32CD32, y: 1.5 },
                { x: 0, z: 300, size: 100, color: 0x6B8E23, y: 4 },
                { x: 300, z: 0, size: 105, color: 0x556B2F, y: 2.5 },
                { x: -300, z: 0, size: 95, color: 0x8B7355, y: 3.5 },
                { x: 0, z: -300, size: 115, color: 0x9ACD32, y: 2 }
            ];

            terrainAreas.forEach(area => {
                const areaGeometry = new THREE.PlaneGeometry(area.size, area.size);
                const areaMaterial = new THREE.MeshLambertMaterial({ color: area.color });
                const terrain = new THREE.Mesh(areaGeometry, areaMaterial);
                terrain.rotation.x = -Math.PI / 2;
                terrain.position.set(area.x, area.y, area.z);
                scene.add(terrain);
            });

            // Reino Central (spawn)
            createKingdom(0, 0, 0x4CAF50, "Reino Central");

            // Reinos elementales m√°s alejados
            createKingdom(-150, -150, 0xff4444, "Reino del Fuego");
            createKingdom(150, -150, 0x4444ff, "Reino del Agua");
            createKingdom(150, 150, 0xffff44, "Reino del Aire");
            createKingdom(-150, 150, 0x8B4513, "Reino de la Tierra");

            // Mazmorras m√°s alejadas
            createDungeon(0, -250, 0x444444);
            createDungeon(250, 0, 0x444444);
            createDungeon(0, 250, 0x444444);
            createDungeon(-250, 0, 0x444444);

            // Nuevo contenido del mapa expandido
            createPlatforms();
            createObstacles();
            createSecretAreas();
            createPortals();
        }

        // Puentes conectores expandidos
        function createBridges() {
            const bridgePositions = [
                { start: [-100, 0], end: [100, 0] },
                { start: [0, -100], end: [0, 100] },
                { start: [-120, -120], end: [120, 120] },
                { start: [-120, 120], end: [120, -120] },
                { start: [-200, -50], end: [200, 50] },
                { start: [-50, -200], end: [50, 200] },
                { start: [150, -100], end: [-150, 100] },
                { start: [100, 150], end: [-100, -150] }
            ];

            bridgePositions.forEach(bridge => {
                const length = Math.sqrt(
                    Math.pow(bridge.end[0] - bridge.start[0], 2) +
                    Math.pow(bridge.end[1] - bridge.start[1], 2)
                );

                const bridgeGeometry = new THREE.BoxGeometry(length, 1, 4);
                const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterial);

                bridgeMesh.position.set(
                    (bridge.start[0] + bridge.end[0]) / 2,
                    2,
                    (bridge.start[1] + bridge.end[1]) / 2
                );

                const angle = Math.atan2(
                    bridge.end[1] - bridge.start[1],
                    bridge.end[0] - bridge.start[0]
                );
                bridgeMesh.rotation.y = angle;

                scene.add(bridgeMesh);
            });
        }

        // Plataformas saltables mejoradas
        function createPlatforms() {
            for (let i = 0; i < 30; i++) {
                const platform = new THREE.Mesh(
                    new THREE.BoxGeometry(8 + Math.random() * 4, 1.5, 8 + Math.random() * 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B7355 })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 60 + Math.random() * 150;
                platform.position.set(
                    Math.cos(angle) * distance,
                    3 + Math.random() * 6,
                    Math.sin(angle) * distance
                );

                platform.castShadow = true;
                platform.userData = { type: 'platform', visited: false };
                platforms.push(platform);
                scene.add(platform);
            }
        }

        // Obst√°culos variados
        function createObstacles() {
            const obstacleTypes = [
                { geo: () => new THREE.BoxGeometry(2, 3, 2), color: 0x8B4513, name: 'pillar' },
                { geo: () => new THREE.ConeGeometry(1.5, 4, 6), color: 0x654321, name: 'cone' },
                { geo: () => new THREE.CylinderGeometry(0.8, 1.2, 2.5, 8), color: 0x2F4F4F, name: 'crystal' },
                { geo: () => new THREE.OctahedronGeometry(1.5), color: 0x4682B4, name: 'gem' }
            ];

            for (let i = 0; i < 60; i++) {
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const obstacle = new THREE.Mesh(
                    type.geo(),
                    new THREE.MeshLambertMaterial({ color: type.color })
                );

                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 250;
                obstacle.position.set(
                    Math.cos(angle) * distance,
                    type.name === 'pillar' ? 1.5 : (type.name === 'cone' ? 2 : 1.25),
                    Math.sin(angle) * distance
                );

                obstacle.castShadow = true;
                obstacle.userData = { type: type.name };
                scene.add(obstacle);
            }
        }

        // √Åreas secretas expandidas
        function createSecretAreas() {
            const secretPositions = [
                { x: 280, z: 280, reward: 'artifact' },
                { x: -280, z: -280, reward: 'coins' },
                { x: 280, z: -280, reward: 'potion' },
                { x: -280, z: 280, reward: 'weapon' },
                { x: 350, z: 100, reward: 'magic' },
                { x: -350, z: -100, reward: 'armor' },
                { x: 100, z: 350, reward: 'treasure' },
                { x: -100, z: -350, reward: 'skill' },
                { x: 320, z: -120, reward: 'crystal' },
                { x: -320, z: 120, reward: 'legendary' }
            ];

            secretPositions.forEach(secret => {
                // √Årea secreta invisible (sin marcador visual)
                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshLambertMaterial({
                        transparent: true,
                        opacity: 0
                    })
                );
                marker.position.set(secret.x, 1, secret.z);

                marker.userData = {
                    type: 'secret',
                    reward: secret.reward,
                    discovered: false
                };

                scene.add(marker);
                items.push(marker);
            });
        }

        // Portales de teletransporte expandidos
        function createPortals() {
            const portalPairs = [
                { from: { x: 180, z: 180 }, to: { x: -180, z: -180 } },
                { from: { x: -180, z: 180 }, to: { x: 180, z: -180 } },
                { from: { x: 250, z: 0 }, to: { x: -250, z: 0 } },
                { from: { x: 0, z: 250 }, to: { x: 0, z: -250 } },
                { from: { x: 300, z: 150 }, to: { x: -300, z: -150 } },
                { from: { x: 150, z: 300 }, to: { x: -150, z: -300 } }
            ];

            portalPairs.forEach((pair, index) => {
                [pair.from, pair.to].forEach((pos, i) => {
                    const portal = new THREE.Mesh(
                        new THREE.RingGeometry(2, 3, 16),
                        new THREE.MeshLambertMaterial({
                            color: i === 0 ? 0x00ffff : 0xff00ff,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    portal.rotation.x = -Math.PI / 2;
                    portal.position.set(pos.x, 0.5, pos.z);

                    portal.userData = {
                        type: 'portal',
                        destination: i === 0 ? pair.to : pair.from,
                        pairIndex: index
                    };

                    scene.add(portal);
                    items.push(portal);
                });
            });
        }

        // Crear reino
        function createKingdom(x, z, color, name) {
            const kingdom = new THREE.Group();

            // Castillo principal
            const castleGeometry = new THREE.BoxGeometry(10, 15, 10);
            const castleMaterial = new THREE.MeshLambertMaterial({ color });
            const castle = new THREE.Mesh(castleGeometry, castleMaterial);
            castle.position.y = 7.5;
            castle.castShadow = true;
            kingdom.add(castle);

            // Torres
            for (let i = 0; i < 4; i++) {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 18, 8),
                    castleMaterial
                );
                const angle = (i * Math.PI) / 2;
                tower.position.set(Math.cos(angle) * 8, 9, Math.sin(angle) * 8);
                tower.castShadow = true;
                kingdom.add(tower);
            }

            // Casas
            for (let i = 0; i < 8; i++) {
                const house = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                const angle = (i * Math.PI) / 4;
                house.position.set(Math.cos(angle) * 20, 3, Math.sin(angle) * 20);
                house.castShadow = true;
                kingdom.add(house);
            }

            kingdom.position.set(x, 0, z);
            scene.add(kingdom);
        }

        // Crear mazmorra
        function createDungeon(x, z, color) {
            const dungeon = new THREE.Group();

            // Entrada
            const entrance = new THREE.Mesh(
                new THREE.BoxGeometry(8, 4, 8),
                new THREE.MeshLambertMaterial({ color })
            );
            entrance.position.y = 2;
            entrance.castShadow = true;
            dungeon.add(entrance);

            // Pilares
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1, 10, 6),
                    new THREE.MeshLambertMaterial({ color })
                );
                const angle = (i * Math.PI) / 2;
                pillar.position.set(Math.cos(angle) * 6, 5, Math.sin(angle) * 6);
                pillar.castShadow = true;
                dungeon.add(pillar);
            }

            dungeon.position.set(x, 0, z);
            scene.add(dungeon);
        }

        // Crear jugador
        function createPlayer() {
            player = new THREE.Group();

            // Cuerpo
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 0.5),
                new THREE.MeshLambertMaterial({ color: 0x3366ff })
            );
            body.position.y = 1;
            body.castShadow = true;
            player.add(body);

            // Cabeza
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 2.4;
            head.castShadow = true;
            player.add(head);

            // Brazos
            const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.65, 1.4, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.65, 1.4, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // Piernas
            const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x3333ff });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.6, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.6, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            // Espada
            const sword = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 2, 0.1),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            sword.position.set(1, 1.5, 0);
            sword.visible = false;
            player.add(sword);

            player.position.set(0, 0, 0);
            player.userData = {
                velocity: new THREE.Vector3(),
                isGrounded: true,
                isAttacking: false,
                attackTime: 0,
                parts: { body, head, leftArm, rightArm, leftLeg, rightLeg, sword }
            };

            scene.add(player);

            // Posicionar c√°mara
            camera.position.set(0, 8, 12);
            camera.lookAt(player.position);
        }

        // Generar enemigos - MUCHOS M√ÅS
        function spawnEnemies() {
            // Enemigos b√°sicos (30)
            for (let i = 0; i < 30; i++) {
                createEnemy('basic');
            }
            // Enemigos fuertes (15)
            for (let i = 0; i < 15; i++) {
                createEnemy('strong');
            }
            // Enemigos √©lite (8)
            for (let i = 0; i < 8; i++) {
                createEnemy('elite');
            }
        }

        // Crear enemigo con tipos
        function createEnemy(type = 'basic') {
            const enemy = new THREE.Group();

            let color, health, speed, damage, size, xpReward, scoreReward;

            switch (type) {
                case 'strong':
                    color = 0x660000;
                    health = 60;
                    speed = 2;
                    damage = 15;
                    size = 1.2;
                    xpReward = 40;
                    scoreReward = 150;
                    break;
                case 'elite':
                    color = 0x330000;
                    health = 100;
                    speed = 1.5;
                    damage = 25;
                    size = 1.5;
                    xpReward = 75;
                    scoreReward = 250;
                    break;
                default: // basic
                    color = 0x990000;
                    health = 30;
                    speed = 2.5;
                    damage = 10;
                    size = 1;
                    xpReward = 25;
                    scoreReward = 100;
            }

            // Cuerpo principal
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4 * size, 0.6 * size, 1.8 * size, 8),
                new THREE.MeshLambertMaterial({ color })
            );
            body.position.y = 0.9 * size;
            body.castShadow = true;
            enemy.add(body);

            // Cabeza esf√©rica
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.5 * size, 12, 12),
                new THREE.MeshLambertMaterial({ color: color + 0x111111 })
            );
            head.position.y = 2.2 * size;
            head.castShadow = true;
            enemy.add(head);

            // Ojos rojos brillantes
            const eyeGeometry = new THREE.SphereGeometry(0.08 * size, 6, 6);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x440000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2 * size, 2.3 * size, 0.4 * size);
            enemy.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2 * size, 2.3 * size, 0.4 * size);
            enemy.add(rightEye);

            // Brazos
            const armGeometry = new THREE.CylinderGeometry(0.15 * size, 0.2 * size, 1.2 * size, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: color - 0x222222 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.8 * size, 1.2 * size, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            enemy.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8 * size, 1.2 * size, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            enemy.add(rightArm);

            // Piernas
            const legGeometry = new THREE.CylinderGeometry(0.2 * size, 0.25 * size, 1 * size, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: color - 0x111111 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3 * size, 0.5 * size, 0);
            leftLeg.castShadow = true;
            enemy.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3 * size, 0.5 * size, 0);
            rightLeg.castShadow = true;
            enemy.add(rightLeg);

            // Arma seg√∫n tipo
            if (type === 'strong' || type === 'elite') {
                const weaponGeometry = new THREE.BoxGeometry(0.1 * size, 1.5 * size, 0.1 * size);
                const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(1.2 * size, 1.5 * size, 0);
                weapon.castShadow = true;
                enemy.add(weapon);
            }

            // Posici√≥n aleatoria
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 120;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            enemy.userData = {
                type,
                health,
                maxHealth: health,
                speed,
                damage,
                attackRange: 3,
                attackCooldown: 0,
                xpReward,
                scoreReward,
                lastPlayerPosition: new THREE.Vector3(),
                searchTime: 0,
                state: 'patrol',
                patrolTarget: new THREE.Vector3(
                    enemy.position.x + (Math.random() - 0.5) * 20,
                    0,
                    enemy.position.z + (Math.random() - 0.5) * 20
                ),
                parts: { body, head, leftEye, rightEye, leftArm, rightArm, leftLeg, rightLeg }
            };

            enemies.push(enemy);
            scene.add(enemy);
        }

        // Generar √≠tems variados
        function spawnItems() {
            // Monedas (30 - nerfeadas)
            for (let i = 0; i < 30; i++) {
                const item = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xffff00 })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 120;
                item.position.set(Math.cos(angle) * distance, 0.5, Math.sin(angle) * distance);
                item.userData = { points: 5, type: 'coin', coins: 3 };
                items.push(item);
                scene.add(item);
            }

            // Pociones (15 - nerfeadas)
            for (let i = 0; i < 15; i++) {
                const item = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xff0080 })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 120;
                item.position.set(Math.cos(angle) * distance, 0.8, Math.sin(angle) * distance);
                item.userData = { points: 15, type: 'potion' };
                items.push(item);
                scene.add(item);
            }

            // Llaves (12 - nuevo)
            for (let i = 0; i < 12; i++) {
                const item = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.2, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0xffd700 })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 25 + Math.random() * 100;
                item.position.set(Math.cos(angle) * distance, 0.6, Math.sin(angle) * distance);
                item.userData = { points: 30, type: 'key' };
                items.push(item);
                scene.add(item);
            }

            // Gemas (20 - nuevo)
            for (let i = 0; i < 20; i++) {
                const item = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.4),
                    new THREE.MeshLambertMaterial({ color: 0x9932cc })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 110;
                item.position.set(Math.cos(angle) * distance, 0.7, Math.sin(angle) * distance);
                item.userData = { points: 40, type: 'gem' };
                items.push(item);
                scene.add(item);
            }

            // Comida (25 - nuevo)
            for (let i = 0; i < 25; i++) {
                const item = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 6, 6),
                    new THREE.MeshLambertMaterial({ color: 0xff6347 })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 130;
                item.position.set(Math.cos(angle) * distance, 0.4, Math.sin(angle) * distance);
                item.userData = { points: 8, type: 'food' };
                items.push(item);
                scene.add(item);
            }

            // Armas (8 - nerfeadas)
            for (let i = 0; i < 8; i++) {
                const item = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1.5, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 100;
                item.position.set(Math.cos(angle) * distance, 1, Math.sin(angle) * distance);
                item.userData = { points: 50, type: 'weapon' };
                items.push(item);
                scene.add(item);
            }
        }

        // Generar cristales - MUCHOS M√ÅS
        function spawnCrystals() {
            // Cristales principales (4)
            const mainPositions = [[-80, -80], [80, -80], [80, 80], [-80, 80]];
            const mainColors = [0xff0000, 0x0000ff, 0xffff00, 0x8B4513];

            for (let i = 0; i < 4; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 4, 6),
                    new THREE.MeshLambertMaterial({ color: mainColors[i] })
                );
                crystal.position.set(mainPositions[i][0], 3, mainPositions[i][1]);
                crystal.userData = { type: 'main_crystal', id: i, power: 100 };
                crystals.push(crystal);
                scene.add(crystal);
            }

            // Cristales menores (20)
            for (let i = 0; i < 20; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.5, 1.5, 6),
                    new THREE.MeshLambertMaterial({ color: 0x00ffff })
                );
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 100;
                crystal.position.set(
                    Math.cos(angle) * distance,
                    1.5,
                    Math.sin(angle) * distance
                );
                crystal.userData = { type: 'minor_crystal', power: 25 };
                crystals.push(crystal);
                scene.add(crystal);
            }
        }

        // Variables para control de c√°mara universal
        let cameraRotation = { x: 0, y: 0 };
        let isDraggingCamera = false;
        let lastTouchX = 0, lastTouchY = 0;
        let lastMouseX = 0, lastMouseY = 0;
        let freeCameraPosition = new THREE.Vector3(0, 8, 12);
        let freeCameraSpeed = 10;

        // Configurar controles
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (!gameActive && e.code !== 'Escape') return;

                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Escape') togglePause();
                if (e.code === keyBindings.inventory && gameActive && !gamePaused) toggleInventory();
                if (e.code === 'KeyM' && gameActive && !gamePaused) toggleMinimap();
                if (e.code === 'KeyC' && gameActive && !gamePaused) cycleCameraMode();
                if (e.code === keyBindings.potion && gameActive && !gamePaused) usePotion();
                if (e.code === keyBindings.interact && gameActive && !gamePaused) interactWithNearbyNPC();
                if (e.code === 'F5' && gameActive && !gamePaused) { saveSlot(currentSaveSlot || 0); e.preventDefault(); }
                if (e.code === 'F6' && gameActive && !gamePaused) { showSaveMenu(); e.preventDefault(); }
                if (e.code === 'F9' && gameActive && !gamePaused) { loadAutoSave(); e.preventDefault(); }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameActive && !gamePaused) {
                    // Click izquierdo: atacar o rotar c√°mara
                    if (e.shiftKey) {
                        // Shift + Click izquierdo = rotar c√°mara
                        isDraggingCamera = true;
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        e.preventDefault();
                    } else {
                        attack();
                    }
                }
                if (e.button === 2 && gameActive && !gamePaused) block();
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Controles de c√°mara universales
            setupCameraControls();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Configurar controles de c√°mara universales
        function setupCameraControls() {
            // Mouse controls para PC
            document.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.ctrlKey)) { // Bot√≥n medio o Ctrl+Click
                    isDraggingCamera = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingCamera && gameActive && !gamePaused) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    const sensitivity = 0.005;
                    cameraRotation.y += deltaX * sensitivity;
                    cameraRotation.x += deltaY * sensitivity;

                    cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 1 || e.button === 0) {
                    isDraggingCamera = false;
                }
            });

            // Touch controls para m√≥vil
            document.addEventListener('touchstart', (e) => {
                // Solo activar rotaci√≥n de c√°mara si no se toca un control
                if (e.touches.length === 1 && !e.target.closest('#mobile-controls') && !e.target.closest('#mobile-pause')) {
                    isDraggingCamera = true;
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingCamera && e.touches.length === 1 && gameActive && !gamePaused) {
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;

                    const sensitivity = 0.005;
                    cameraRotation.y -= deltaX * sensitivity; // Invertido para c√°mara libre
                    cameraRotation.x -= deltaY * sensitivity; // Invertido para c√°mara libre

                    // Limitar rotaci√≥n vertical para evitar que se voltee
                    cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));

                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchend', (e) => {
                if (isDraggingCamera) {
                    isDraggingCamera = false;
                    if (navigator.vibrate && mobileSettings.hapticFeedback) {
                        navigator.vibrate(20);
                    }
                }
            });

            // Prevenir scroll cuando se arrastra la c√°mara
            document.addEventListener('touchmove', (e) => {
                if (isDraggingCamera) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // ARREGLADO: Controles m√≥viles sin duplicados
        function setupMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');

            // LIMPIAR controles existentes para evitar duplicados
            const existingButtons = mobileControls.querySelectorAll('button:not([id])');
            existingButtons.forEach(btn => btn.remove());

            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystick-knob');
            let isDragging = false;
            let touchId = null;

            // MEJORADO: Joystick con soporte mouse + touch
            joystick.addEventListener('touchstart', (e) => {
                if (touchId === null) {
                    isDragging = true;
                    touchId = e.touches[0].identifier;
                    joystick.style.background = 'rgba(255,255,255,0.5)';
                    e.preventDefault();
                }
            });

            // Mouse support para modo dev
            joystick.addEventListener('mousedown', (e) => {
                isDragging = true;
                joystick.style.background = 'rgba(255,255,255,0.5)';
                e.preventDefault();
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging || touchId === null) return;

                let touch = null;
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        touch = e.touches[i];
                        break;
                    }
                }

                if (!touch) return;

                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const maxDistance = 45;
                const distance = Math.min(maxDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                knob.style.left = (32.5 + Math.cos(angle) * distance) + 'px';
                knob.style.top = (32.5 + Math.sin(angle) * distance) + 'px';

                // ARREGLADO: Movimiento suave con zona muerta mejorada
                const deadZone = 8; // Zona muerta m√°s grande
                const intensity = Math.min(1, Math.max(0, (distance - deadZone) / (maxDistance - deadZone)));

                // Solo activar movimiento si supera la zona muerta
                if (distance > deadZone) {
                    keys['KeyW'] = deltaY < -deadZone;
                    keys['KeyS'] = deltaY > deadZone;
                    keys['KeyA'] = deltaX < -deadZone;
                    keys['KeyD'] = deltaX > deadZone;
                    keys['KeyR'] = distance > 25;
                } else {
                    // Detener movimiento en zona muerta
                    keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = keys['KeyR'] = false;
                }

                // Velocidad gradual basada en distancia
                window.joystickIntensity = intensity;

                knob.style.background = distance > 20 ? 'rgba(255,255,255,1)' : 'rgba(255,255,255,0.9)';
                e.preventDefault();
            });

            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        isDragging = false;
                        touchId = null;
                        knob.style.left = '32.5px';
                        knob.style.top = '32.5px';
                        knob.style.background = 'rgba(255,255,255,0.9)';
                        joystick.style.background = 'rgba(255,255,255,0.3)';
                        keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = keys['KeyR'] = false;
                        break;
                    }
                }
            });

            // Mouse events para joystick
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || touchId !== null) return;

                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                const maxDistance = 45;
                const distance = Math.min(maxDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                knob.style.left = (32.5 + Math.cos(angle) * distance) + 'px';
                knob.style.top = (32.5 + Math.sin(angle) * distance) + 'px';

                const threshold = 1;
                const intensity = Math.min(1, distance / 20);

                keys['KeyW'] = deltaY < -threshold;
                keys['KeyS'] = deltaY > threshold;
                keys['KeyA'] = deltaX < -threshold;
                keys['KeyD'] = deltaX > threshold;
                keys['KeyR'] = distance > 12;

                window.joystickIntensity = intensity;
                knob.style.background = distance > 12 ? 'rgba(255,255,255,1)' : 'rgba(255,255,255,0.9)';
            });

            document.addEventListener('mouseup', (e) => {
                if (isDragging && touchId === null) {
                    isDragging = false;
                    knob.style.left = '32.5px';
                    knob.style.top = '32.5px';
                    knob.style.background = 'rgba(255,255,255,0.9)';
                    joystick.style.background = 'rgba(255,255,255,0.3)';
                    keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = keys['KeyR'] = false;
                }
            });

            // ARREGLADO: Mejor manejo de orientaci√≥n y fullscreen
            let orientationTimeout;
            window.addEventListener('orientationchange', () => {
                clearTimeout(orientationTimeout);
                orientationTimeout = setTimeout(() => {
                    setupMobileControls();
                    // Forzar fullscreen despu√©s de cambio de orientaci√≥n
                    if (gameActive) {
                        setTimeout(enterFullscreen, 500);
                    }
                }, 200);
            });

            window.addEventListener('resize', () => {
                clearTimeout(orientationTimeout);
                orientationTimeout = setTimeout(() => {
                    setupMobileControls();
                    // Mantener fullscreen en resize
                    if (gameActive && !document.fullscreenElement) {
                        setTimeout(enterFullscreen, 100);
                    }
                }, 100);
            });

            // MEJORADO: Botones con soporte mouse + touch
            const setupButton = (id, action, vibration = 50) => {
                const btn = document.getElementById(id);
                if (!btn) return;

                // Touch events
                btn.addEventListener('touchstart', (e) => {
                    action();
                    if (navigator.vibrate && mobileSettings.hapticFeedback) navigator.vibrate(vibration);
                    btn.style.transform = 'scale(0.85)';
                    btn.style.filter = 'brightness(1.3)';
                    e.preventDefault();
                });

                btn.addEventListener('touchend', (e) => {
                    btn.style.transform = 'scale(1)';
                    btn.style.filter = 'brightness(1)';
                    e.preventDefault();
                });

                // Mouse events para modo dev
                btn.addEventListener('mousedown', (e) => {
                    action();
                    btn.style.transform = 'scale(0.85)';
                    btn.style.filter = 'brightness(1.3)';
                    e.preventDefault();
                });

                btn.addEventListener('mouseup', (e) => {
                    btn.style.transform = 'scale(1)';
                    btn.style.filter = 'brightness(1)';
                    e.preventDefault();
                });
            };

            setupButton('mobile-attack', attack, 60);
            setupButton('mobile-jump', () => keys['Space'] = true, 40);
            setupButton('mobile-potion', usePotion, 50);
            setupButton('mobile-inventory', toggleInventory, 30);
            setupButton('mobile-camera', cycleCameraMode, 30);

            // Eventos especiales para salto
            const jumpBtn = document.getElementById('mobile-jump');
            jumpBtn.addEventListener('touchend', () => keys['Space'] = false);
            jumpBtn.addEventListener('mouseup', () => keys['Space'] = false);

            // Configurar doble toque para interacciones
            setupDoubleTap();
        }

        // Configurar doble toque para interacciones
        function setupDoubleTap() {
            let lastTap = 0;

            document.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;

                if (tapLength < 500 && tapLength > 0) {
                    // Doble toque detectado
                    if (gameActive && !gamePaused) {
                        interactWithNearbyNPC();
                        if (navigator.vibrate) navigator.vibrate(60);
                    }
                    e.preventDefault();
                }

                lastTap = currentTime;
            });
        }

        // Actualizar jugador
        function updatePlayer(delta) {
            const userData = player.userData;
            let baseSpeed = config.playerSpeed;

            // Aplicar intensidad del joystick para movimiento suave
            if (window.joystickIntensity) {
                baseSpeed *= (0.3 + window.joystickIntensity * 0.7); // 30% m√≠n, 100% m√°x
            }

            const speed = (keys[keyBindings.run] ? baseSpeed * 1.5 : baseSpeed) * weather.effects.speed;

            // Definir moveVector en el scope de la funci√≥n
            const moveVector = new THREE.Vector3();
            if (keys[keyBindings.forward]) moveVector.z -= 1;
            if (keys[keyBindings.backward]) moveVector.z += 1;
            if (keys[keyBindings.left]) moveVector.x -= 1;
            if (keys[keyBindings.right]) moveVector.x += 1;

            // Movimiento fluido - solo para jugador, no para c√°mara libre
            if (cameraMode !== 'free') {
                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    const oldPos = player.position.clone();

                    // Movimiento relativo a la rotaci√≥n de la c√°mara
                    const cameraYRotation = cameraRotation.y;

                    // Calcular direcci√≥n de movimiento basada en la rotaci√≥n de c√°mara
                    const forward = new THREE.Vector3(
                        -Math.sin(cameraYRotation),
                        0,
                        -Math.cos(cameraYRotation)
                    );

                    const right = new THREE.Vector3(
                        Math.cos(cameraYRotation),
                        0,
                        -Math.sin(cameraYRotation)
                    );

                    const movement = new THREE.Vector3();
                    movement.addScaledVector(forward, -moveVector.z);
                    movement.addScaledVector(right, moveVector.x);
                    movement.normalize();

                    player.position.x += movement.x * speed * delta;
                    player.position.z += movement.z * speed * delta;
                    playerStats.totalDistance += oldPos.distanceTo(player.position);

                    // Rotaci√≥n suave hacia direcci√≥n de movimiento
                    const targetRotation = Math.atan2(movement.x, movement.z);
                    player.rotation.y += (targetRotation - player.rotation.y) * delta * 8;
                }
            }

            // ANIMACIONES DEL JUGADOR - Ejecutar siempre
            const time = Date.now() * 0.004;
            const isMoving = moveVector.length() > 0 && userData.isGrounded;
            const isRunning = keys[keyBindings.run];
            const intensity = window.joystickIntensity || 1;

            if (isMoving) {
                // Animaci√≥n simple y natural
                const walkSpeed = isRunning ? 4 : 2.5;
                const walkCycle = time * walkSpeed;

                // Brazos simples - movimiento opuesto
                userData.parts.leftArm.rotation.x = Math.sin(walkCycle) * 0.4;
                userData.parts.rightArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.4;
                userData.parts.leftArm.rotation.z = 0;
                userData.parts.rightArm.rotation.z = 0;

                // Piernas naturales
                userData.parts.leftLeg.rotation.x = Math.sin(walkCycle) * 0.6;
                userData.parts.rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.6;

                // Cuerpo estable
                userData.parts.body.rotation.z = 0;
                userData.parts.head.rotation.x = 0;

            } else {
                // Animaci√≥n de reposo mejorada
                const idleCycle = time * 0.8;

                // Animaci√≥n de reposo simple
                userData.parts.leftArm.rotation.x = Math.sin(idleCycle * 0.5) * 0.1;
                userData.parts.rightArm.rotation.x = Math.sin(idleCycle * 0.5 + 1) * 0.1;
                userData.parts.leftLeg.rotation.x = Math.sin(idleCycle * 0.3) * 0.05;
                userData.parts.rightLeg.rotation.x = Math.sin(idleCycle * 0.3 + 0.5) * 0.05;
                userData.parts.body.rotation.z = 0;
                userData.parts.head.rotation.x = 0;
            }

            // Salto con animaci√≥n
            if (keys['Space'] && userData.isGrounded) {
                userData.velocity.y = config.jumpForce * weather.effects.speed;
                userData.isGrounded = false;
                jumpAnimation.isJumping = true;
                jumpAnimation.startTime = Date.now();
                playerStats.totalJumps++;
                checkAchievement('jumper');
            }

            // Animaci√≥n de salto
            if (jumpAnimation.isJumping) {
                const elapsed = Date.now() - jumpAnimation.startTime;
                const progress = Math.min(elapsed / jumpAnimation.duration, 1);
                
                if (progress < 0.3) {
                    // Fase impulso - comprimir
                    const compress = Math.sin(progress * Math.PI / 0.3) * 0.3;
                    userData.parts.body.scale.y = 1 - compress * 0.2;
                    userData.parts.leftLeg.rotation.x = -0.8;
                    userData.parts.rightLeg.rotation.x = -0.8;
                    userData.parts.leftArm.rotation.x = -0.5;
                    userData.parts.rightArm.rotation.x = -0.5;
                } else if (progress < 0.7) {
                    // Fase vuelo - extender
                    userData.parts.body.scale.y = 1.1;
                    userData.parts.leftLeg.rotation.x = 0.4;
                    userData.parts.rightLeg.rotation.x = 0.4;
                    userData.parts.leftArm.rotation.x = -1.2;
                    userData.parts.rightArm.rotation.x = -1.2;
                } else {
                    // Fase aterrizaje
                    userData.parts.body.scale.y = 0.9;
                    userData.parts.leftLeg.rotation.x = -0.3;
                    userData.parts.rightLeg.rotation.x = -0.3;
                    userData.parts.leftArm.rotation.x = 0.8;
                    userData.parts.rightArm.rotation.x = 0.8;
                }
                
                if (userData.isGrounded || progress >= 1) {
                    jumpAnimation.isJumping = false;
                    userData.parts.body.scale.y = 1;
                }
            }

            // Gravedad
            userData.velocity.y += config.gravity * delta;
            player.position.y += userData.velocity.y * delta;

            // Colisi√≥n con suelo y plataformas
            let onPlatform = false;
            platforms.forEach(platform => {
                const distance = player.position.distanceTo(platform.position);
                if (distance < 6 && player.position.y > platform.position.y - 1 && player.position.y < platform.position.y + 3) {
                    if (userData.velocity.y <= 0) {
                        player.position.y = platform.position.y + 1.5;
                        userData.velocity.y = 0;
                        userData.isGrounded = true;
                        onPlatform = true;
                        
                        if (!platform.userData.visited) {
                            platform.userData.visited = true;
                            playerStats.platformsVisited = (playerStats.platformsVisited || 0) + 1;
                            showNotification('üèóÔ∏è Plataforma visitada!', 1000);
                        }
                    }
                }
            });
            
            if (!onPlatform && player.position.y <= 0) {
                player.position.y = 0;
                userData.velocity.y = 0;
                userData.isGrounded = true;
            }

            // Actualizar c√°mara seg√∫n modo
            switch (cameraMode) {
                case 'first':
                    camera.position.copy(player.position);
                    camera.position.y += 1.8;
                    // C√°mara primera persona con rotaci√≥n universal
                    const euler = new THREE.Euler(cameraRotation.x, cameraRotation.y, 0, 'YXZ');
                    camera.setRotationFromEuler(euler);
                    break;
                case 'free':
                    // C√°mara libre verdadera con movimiento WASD
                    updateFreeCamera(delta);
                    camera.position.copy(freeCameraPosition);

                    // Aplicar rotaci√≥n de c√°mara libre
                    const freeEuler = new THREE.Euler(cameraRotation.x, cameraRotation.y, 0, 'YXZ');
                    camera.setRotationFromEuler(freeEuler);
                    break;
                default: // third person
                    // Tercera persona con rotaci√≥n universal
                    const tpRadius = 12;
                    const height = 8;
                    const tpX = Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x) * tpRadius;
                    const tpY = height + Math.sin(cameraRotation.x) * 5;
                    const tpZ = Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x) * tpRadius;

                    camera.position.set(
                        player.position.x + tpX,
                        player.position.y + tpY,
                        player.position.z + tpZ
                    );
                    camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
            }

            // Animaci√≥n de ataque
            if (userData.isAttacking) {
                userData.attackTime += delta;
                userData.parts.sword.visible = true;

                if (userData.attackTime > 0.5) {
                    userData.isAttacking = false;
                    userData.attackTime = 0;
                    userData.parts.sword.visible = false;
                }
            }
        }

        // Actualizar c√°mara libre
        function updateFreeCamera(delta) {
            if (cameraMode !== 'free' || !player) return;

            const moveVector = new THREE.Vector3();
            const speed = freeCameraSpeed * delta;

            // Movimiento WASD en c√°mara libre
            if (keys[keyBindings.forward]) moveVector.z -= 1;
            if (keys[keyBindings.backward]) moveVector.z += 1;
            if (keys[keyBindings.left]) moveVector.x -= 1;
            if (keys[keyBindings.right]) moveVector.x += 1;
            if (keys['Space']) moveVector.y += 1;
            if (keys['ShiftLeft'] || keys['ShiftRight']) moveVector.y -= 1;

            if (moveVector.length() > 0) {
                moveVector.normalize();

                // Aplicar rotaci√≥n de c√°mara al movimiento
                const forward = new THREE.Vector3(
                    -Math.sin(cameraRotation.y),
                    0,
                    -Math.cos(cameraRotation.y)
                );

                const right = new THREE.Vector3(
                    Math.cos(cameraRotation.y),
                    0,
                    -Math.sin(cameraRotation.y)
                );

                const up = new THREE.Vector3(0, 1, 0);

                const movement = new THREE.Vector3();
                movement.addScaledVector(forward, -moveVector.z * speed);
                movement.addScaledVector(right, moveVector.x * speed);
                movement.addScaledVector(up, moveVector.y * speed);

                freeCameraPosition.add(movement);
            }


        }

        // Atacar
        function attack() {
            if (player.userData.isAttacking) return;

            player.userData.isAttacking = true;
            player.userData.attackTime = 0;
            playerStats.totalAttacks++;
            checkAchievement('warrior');

            // Buscar enemigos en rango
            enemies.forEach((enemy, index) => {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < config.attackRange * weather.effects.visibility) {
                    const damage = 20 * inventory.sword * weather.effects.damage;
                    enemy.userData.health -= damage;

                    if (enemy.userData.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                        score += enemy.userData.scoreReward;
                        kills++;
                        playerXP += enemy.userData.xpReward;
                        inventory.coins += Math.floor(Math.random() * 20) + 5;
                        checkLevelUp();
                        checkAchievement('first_kill');
                        updateUI();
                        updateInventoryUI();
                        showNotification(`+${enemy.userData.scoreReward} puntos! +${enemy.userData.xpReward} XP`, 1000);
                    }
                }
            });

            // Atacar jefes
            bosses.forEach((boss, index) => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < config.attackRange) {
                    boss.userData.health -= 30 * inventory.sword;

                    if (boss.userData.health <= 0) {
                        scene.remove(boss);
                        bosses.splice(index, 1);
                        score += 500;
                        playerXP += 100;
                        inventory.sword++;
                        checkLevelUp();
                        checkAchievement('boss_slayer');
                        updateUI();
                        updateInventoryUI();
                        showNotification("¬°Jefe derrotado! +500 puntos! Espada mejorada!", 3000);

                        // Verificar victoria total
                        if (crystalsFound >= 4 && bosses.length === 0) {
                            setTimeout(() => {
                                showNotification("¬°VICTORIA TOTAL!\n¬°Has derrotado a todos los jefes y encontrado todos los cristales!\n¬°Aethermoor est√° a salvo!", 5000);
                                setTimeout(() => gameOver(), 5000);
                            }, 3000);
                        }
                    }
                }
            });
        }

        // Sistema de niveles mejorado
        function checkLevelUp() {
            const xpNeeded = playerLevel * 100;
            if (playerXP >= xpNeeded) {
                playerXP -= xpNeeded;
                playerLevel++;
                playerHealth = Math.min(100, playerHealth + 20);
                inventory.potions++;

                if (isMobile && navigator.vibrate) navigator.vibrate([200, 100, 200]);

                showNotification(`¬°NIVEL ${playerLevel}! +20 HP, +1 Poci√≥n`, 3000);
                checkUnlocks();
                updateUI();
                updateInventoryUI();
            }
        }

        // Usar poci√≥n
        function usePotion() {
            if (inventory.potions > 0 && playerHealth < 100) {
                inventory.potions--;
                playerHealth = Math.min(100, playerHealth + 50);
                updateUI();
                updateInventoryUI();
                showNotification("+50 HP", 1500);
            }
        }

        // Actualizar enemigos con IA mejorada
        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                const userData = enemy.userData;
                const distance = player.position.distanceTo(enemy.position);
                const time = Date.now() * 0.003;

                // Estados de IA
                if (distance < 20) {
                    userData.state = 'chase';
                    userData.lastPlayerPosition.copy(player.position);
                    userData.searchTime = 0;
                } else if (userData.state === 'chase' && distance > 25) {
                    userData.state = 'search';
                    userData.searchTime = 3; // Buscar por 3 segundos
                } else if (userData.state === 'search') {
                    userData.searchTime -= delta;
                    if (userData.searchTime <= 0) {
                        userData.state = 'patrol';
                        // Nuevo punto de patrulla
                        userData.patrolTarget.set(
                            enemy.position.x + (Math.random() - 0.5) * 30,
                            0,
                            enemy.position.z + (Math.random() - 0.5) * 30
                        );
                    }
                }

                let targetPosition;
                switch (userData.state) {
                    case 'chase':
                        targetPosition = player.position;
                        break;
                    case 'search':
                        targetPosition = userData.lastPlayerPosition;
                        break;
                    case 'patrol':
                        targetPosition = userData.patrolTarget;
                        if (enemy.position.distanceTo(userData.patrolTarget) < 2) {
                            userData.patrolTarget.set(
                                enemy.position.x + (Math.random() - 0.5) * 30,
                                0,
                                enemy.position.z + (Math.random() - 0.5) * 30
                            );
                        }
                        break;
                }

                // Movimiento hacia objetivo
                const direction = new THREE.Vector3()
                    .subVectors(targetPosition, enemy.position)
                    .normalize();

                const moveSpeed = (userData.state === 'chase' ? userData.speed : userData.speed * 0.5) * weather.effects.speed;
                enemy.position.add(direction.multiplyScalar(moveSpeed * delta));
                enemy.lookAt(targetPosition);

                // Atacar si est√° persiguiendo y cerca
                if (userData.state === 'chase' && distance < userData.attackRange * weather.effects.visibility && userData.attackCooldown <= 0) {
                    const damage = Math.floor(userData.damage * weather.effects.damage);
                    playerHealth -= damage;
                    userData.attackCooldown = 2;
                    updateUI();
                    showNotification(`-${damage} HP`, 800);

                    // Vibraci√≥n y notificaci√≥n en m√≥vil
                    if (isMobile && navigator.vibrate && mobileSettings.hapticFeedback) {
                        navigator.vibrate([100, 50, 100]); // Patr√≥n de vibraci√≥n
                    }

                    // Notificaci√≥n de Android si la app est√° en segundo plano
                    if (document.hidden) {
                        showAndroidNotification('¬°Pepe bajo ataque!', `Enemigo ${userData.type} te atac√≥ por ${userData.damage} HP`);
                    }

                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }

                if (userData.attackCooldown > 0) {
                    userData.attackCooldown -= delta;
                }

                // Animaciones mejoradas
                if (userData.state === 'chase') {
                    // Animaci√≥n agresiva
                    userData.parts.leftArm.rotation.x = Math.sin(time * 2) * 0.8;
                    userData.parts.rightArm.rotation.x = Math.sin(time * 2 + Math.PI) * 0.8;
                    userData.parts.leftLeg.rotation.x = Math.sin(time * 3) * 0.6;
                    userData.parts.rightLeg.rotation.x = Math.sin(time * 3 + Math.PI) * 0.6;
                    userData.parts.body.rotation.z = Math.sin(time * 4) * 0.2;
                } else {
                    // Animaci√≥n calmada
                    userData.parts.leftArm.rotation.x = Math.sin(time) * 0.3;
                    userData.parts.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.3;
                    userData.parts.leftLeg.rotation.x = Math.sin(time * 1.5) * 0.4;
                    userData.parts.rightLeg.rotation.x = Math.sin(time * 1.5 + Math.PI) * 0.4;
                    userData.parts.body.rotation.z = Math.sin(time) * 0.1;
                }

                // Ojos brillantes cuando persigue
                if (userData.parts.leftEye && userData.parts.rightEye) {
                    const intensity = userData.state === 'chase' ? 0.8 : 0.2;
                    userData.parts.leftEye.material.emissive.setHex(userData.state === 'chase' ? 0x880000 : 0x440000);
                    userData.parts.rightEye.material.emissive.setHex(userData.state === 'chase' ? 0x880000 : 0x440000);
                }
            });
        }

        // Actualizar √≠tems
        function updateItems(delta) {
            items.forEach((item, index) => {
                // Rotaci√≥n
                if (item.userData.type !== 'portal') {
                    item.rotation.y += delta * 2;
                }

                // Efecto de flotaci√≥n para portales
                if (item.userData.type === 'portal') {
                    item.position.y = 0.5 + Math.sin(Date.now() * 0.003 + index) * 0.2;
                }

                // Colisi√≥n con jugador
                const distance = player.position.distanceTo(item.position);
                if (distance < 2) {

                    switch (item.userData.type) {
                        case 'coin':
                            scene.remove(item);
                            items.splice(index, 1);
                            inventory.coins += item.userData.coins || 5;
                            score += item.userData.points || 10;
                            showNotification(`+${item.userData.coins || 5} monedas!`, 800);
                            break;

                        case 'potion':
                            scene.remove(item);
                            items.splice(index, 1);
                            inventory.potions++;
                            score += item.userData.points || 25;
                            showNotification(`+1 Poci√≥n de Salud!`, 1000);
                            break;

                        case 'weapon':
                            scene.remove(item);
                            items.splice(index, 1);
                            inventory.sword++;
                            score += item.userData.points || 50;
                            showNotification(`‚öîÔ∏è ¬°Espada mejorada! Nivel ${inventory.sword}`, 2000);
                            break;

                        case 'key':
                            scene.remove(item);
                            items.splice(index, 1);
                            inventory.keys++;
                            playerStats.keysCollected = (playerStats.keysCollected || 0) + 1;
                            score += item.userData.points || 30;
                            showNotification(`üóùÔ∏è ¬°Llave obtenida! Total: ${inventory.keys}`, 1500);
                            break;

                        case 'gem':
                            scene.remove(item);
                            items.splice(index, 1);
                            inventory.artifacts++;
                            playerStats.gemsCollected = (playerStats.gemsCollected || 0) + 1;
                            score += item.userData.points || 40;
                            showNotification(`üíé ¬°Gema encontrada! +${item.userData.points} pts`, 1500);
                            break;

                        case 'food':
                            scene.remove(item);
                            items.splice(index, 1);
                            playerHealth = Math.min(100, playerHealth + 10);
                            playerStats.foodCollected = (playerStats.foodCollected || 0) + 1;
                            score += item.userData.points || 8;
                            showNotification(`üçé +10 HP | +${item.userData.points} pts`, 1000);
                            break;

                        case 'secret':
                            if (!item.userData.discovered) {
                                item.userData.discovered = true;
                                playerStats.secretsFound++;

                                switch (item.userData.reward) {
                                    case 'artifact':
                                        inventory.artifacts++;
                                        score += 500;
                                        showNotification('‚ú® ¬°ARTEFACTO SECRETO ENCONTRADO! +500 pts', 3000);
                                        break;
                                    case 'coins':
                                        inventory.coins += 100;
                                        score += 200;
                                        showNotification('üí∞ ¬°TESORO SECRETO! +100 monedas', 3000);
                                        break;
                                    case 'potion':
                                        inventory.potions += 5;
                                        showNotification('üß™ ¬°CACHE DE POCIONES! +5 pociones', 3000);
                                        break;
                                    case 'weapon':
                                        inventory.sword += 2;
                                        showNotification('‚öîÔ∏è ¬°ARMA LEGENDARIA! Espada +2 niveles', 3000);
                                        break;
                                }

                                item.material.color.setHex(0x888888);
                                item.material.opacity = 0.3;
                            }
                            break;

                        case 'portal':
                            if (distance < 1.5) {
                                const dest = item.userData.destination;
                                player.position.set(dest.x, player.position.y, dest.z);
                                showNotification('‚ö° ¬°Teletransportado!', 1500);
                                if (isMobile && navigator.vibrate) navigator.vibrate(200);
                            }
                            break;
                    }

                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Actualizar cristales
        function updateCrystals(delta) {
            crystals.forEach((crystal, index) => {
                // Rotaci√≥n y flotaci√≥n
                crystal.rotation.y += delta;
                crystal.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.5;

                // Colisi√≥n con jugador
                const distance = player.position.distanceTo(crystal.position);
                if (distance < 3) {
                    scene.remove(crystal);
                    crystals.splice(index, 1);

                    if (crystal.userData.type === 'main_crystal') {
                        crystalsFound++;
                        score += 1000;
                        playerXP += 200;
                        inventory.artifacts++;
                        showNotification(`¬°Cristal Principal! +1000 puntos +200 XP`, 3000);

                        if (crystalsFound >= 4 && bosses.length === 0) {
                            checkAchievement('savior');
                            showNotification("¬°Misi√≥n completada!\n¬°Aethermoor ha sido salvado!", 5000);
                            setTimeout(() => gameOver(), 5000);
                        } else if (crystalsFound >= 4) {
                            showNotification("¬°Todos los cristales principales encontrados!\nAhora debes derrotar a todos los jefes!", 5000);
                        }
                    } else {
                        score += 200;
                        playerXP += 50;
                        inventory.coins += 25;
                        showNotification(`Cristal Menor: +200 puntos +50 XP`, 1500);
                    }

                    checkAchievement('crystal_collector');
                    checkLevelUp();
                    updateUI();
                    updateInventoryUI();
                }
            });
        }

        // Sistema de Misiones Expandido
        let currentMissions = [
            { id: 'crystals', name: 'Cristales de Poder', progress: 0, total: 4, reward: 1000, type: 'main' },
            { id: 'bosses', name: 'Derrotar Jefes', progress: 0, total: 4, reward: 2000, type: 'main' },
            { id: 'enemies', name: 'Eliminar Enemigos', progress: 0, total: 30, reward: 400, type: 'side' },
            { id: 'platforms', name: 'Saltar Plataformas', progress: 0, total: 15, reward: 300, type: 'side' },
            { id: 'treasures', name: 'Abrir Cofres', progress: 0, total: 12, reward: 500, type: 'side' },
            { id: 'keys', name: 'Recolectar Llaves', progress: 0, total: 8, reward: 250, type: 'side' },
            { id: 'gems', name: 'Encontrar Gemas', progress: 0, total: 10, reward: 400, type: 'side' },
            { id: 'food', name: 'Recolectar Comida', progress: 0, total: 15, reward: 200, type: 'side' },
            { id: 'survival', name: 'Sobrevivir 5 min', progress: 0, total: 300, reward: 800, type: 'challenge' }
        ];

        function updateMissions() {
            // Actualizar progreso de misiones
            currentMissions.forEach(mission => {
                switch (mission.id) {
                    case 'crystals':
                        mission.progress = crystalsFound;
                        break;
                    case 'bosses':
                        mission.progress = 4 - bosses.length;
                        break;
                    case 'enemies':
                        mission.progress = kills;
                        break;
                    case 'explore':
                        mission.progress = Math.floor(playerStats.totalDistance);
                        break;
                    case 'platforms':
                        mission.progress = playerStats.platformsVisited || 0;
                        break;
                    case 'treasures':
                        mission.progress = playerStats.chestsOpened || 0;
                        break;
                    case 'secrets':
                        mission.progress = playerStats.secretsFound || 0;
                        break;
                    case 'survival':
                        mission.progress = Math.floor(gameTime);
                        break;
                    case 'keys':
                        mission.progress = playerStats.keysCollected || 0;
                        break;
                    case 'gems':
                        mission.progress = playerStats.gemsCollected || 0;
                        break;
                    case 'food':
                        mission.progress = playerStats.foodCollected || 0;
                        break;
                }

                // Completar misi√≥n
                if (mission.progress >= mission.total && !mission.completed) {
                    mission.completed = true;
                    score += mission.reward;
                    playerXP += mission.reward / 2;
                    showNotification(`‚úÖ MISI√ìN COMPLETADA: ${mission.name}\n+${mission.reward} puntos!`, 4000);
                    checkLevelUp();

                    // Agregar nueva misi√≥n secundaria
                    if (mission.type === 'side') {
                        addRandomMission();
                    }
                }
            });
        }

        function addRandomMission() {
            const randomMissions = [
                { id: 'treasure', name: 'Abrir Cofres', progress: 0, total: 10, reward: 400, type: 'side' },
                { id: 'potions', name: 'Recolectar Pociones', progress: 0, total: 15, reward: 250, type: 'side' },
                { id: 'survive', name: 'Sobrevivir Tiempo', progress: 0, total: 300, reward: 600, type: 'side' },
                { id: 'skills', name: 'Usar Habilidades', progress: 0, total: 25, reward: 350, type: 'side' }
            ];

            const newMission = randomMissions[Math.floor(Math.random() * randomMissions.length)];
            newMission.id += '_' + Date.now(); // ID √∫nico
            currentMissions.push(newMission);
            showNotification(`üìã NUEVA MISI√ìN: ${newMission.name}`, 3000);
        }

        // Actualizar UI
        function updateUI() {
            const scoreEl = document.getElementById('score');
            const killsEl = document.getElementById('kills');
            const crystalsEl = document.getElementById('crystals');
            const healthFillEl = document.getElementById('health-fill');
            const healthTextEl = document.getElementById('health-text');
            const levelInfoEl = document.getElementById('level-info');
            const missionTextEl = document.getElementById('mission-text');

            if (scoreEl) scoreEl.textContent = Number(score) || 0;
            if (killsEl) killsEl.textContent = Number(kills) || 0;
            if (crystalsEl) crystalsEl.textContent = Number(crystalsFound) || 0;

            // Actualizar barra de vida RPG
            const healthPercent = Math.max(0, playerHealth);
            if (healthFillEl) {
                healthFillEl.style.width = healthPercent + '%';

                // Cambiar color de la barra seg√∫n la vida
                if (healthPercent > 60) {
                    healthFillEl.style.background = 'linear-gradient(90deg, #44ff44 0%, #88ff44 100%)';
                    healthFillEl.style.boxShadow = '0 0 10px rgba(68,255,68,0.5)';
                } else if (healthPercent > 30) {
                    healthFillEl.style.background = 'linear-gradient(90deg, #ffaa00 0%, #ffcc44 100%)';
                    healthFillEl.style.boxShadow = '0 0 10px rgba(255,170,0,0.5)';
                } else {
                    healthFillEl.style.background = 'linear-gradient(90deg, #ff4444 0%, #ff6666 100%)';
                    healthFillEl.style.boxShadow = '0 0 10px rgba(255,68,68,0.5)';
                }
            }

            if (healthTextEl) healthTextEl.textContent = `${Math.max(0, playerHealth)}/100`;
            if (levelInfoEl) levelInfoEl.textContent = `‚≠ê Nivel ${playerLevel} | üí∞ ${inventory.coins || 0}`;

            // Actualizar misiones din√°micas
            updateMissions();
            const activeMissions = currentMissions.filter(m => !m.completed).slice(0, 2);
            const missionText = activeMissions.map(m =>
                `${m.name}: ${m.progress}/${m.total}`
            ).join('<br>');

            if (missionTextEl) missionTextEl.innerHTML = missionText || 'Misiones completadas!';
        }

        // Mostrar notificaci√≥n
        function showNotification(text, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        // Game Over mejorado
        function gameOver() {
            gameActive = false;
            gamePaused = true;

            saveToLeaderboard(score);

            const totalCrystalsCollected = 24 - crystals.length;
            const isVictory = crystalsFound >= 4 && bosses.length === 0;
            const sessionTime = Math.floor((Date.now() - gameSession.startTime) / 60000);

            const finalStats = `
                ${isVictory ? '¬°VICTORIA TOTAL!' : '¬°GAME OVER!'}
                
                Puntuaci√≥n final: ${score || 0}
                Nivel alcanzado: ${playerLevel}
                Enemigos derrotados: ${kills}
                Cristales: ${crystalsFound}/4
                Tiempo: ${sessionTime} min
                
                üèÜ ¬°Puntuaci√≥n guardada!
            `;

            showNotification(finalStats, 10000);

            setTimeout(() => {
                document.getElementById('main-menu').style.display = 'flex';
            }, 10000);
        }

        // Actualizar estad√≠sticas
        function updateStats() {
            stats.frames++;
            const now = performance.now();

            if (now - stats.lastTime >= 1000) {
                stats.fps = Math.round((stats.frames * 1000) / (now - stats.lastTime));
                stats.frames = 0;
                stats.lastTime = now;

                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('objects').textContent = scene.children.length;
            }
        }

        // Funciones adicionales
        function toggleInventory() {
            const inv = document.getElementById('inventory');
            inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
        }

        function toggleMinimap() {
            settings.minimap = !settings.minimap;
            document.getElementById('minimap').style.display = settings.minimap ? 'block' : 'none';
        }

        function toggleObjectives() {
            const objectivePanel = document.getElementById('objective');
            const missionText = document.getElementById('mission-text');
            const toggleBtn = document.getElementById('toggle-objectives');
            
            if (missionText.style.display === 'none') {
                missionText.style.display = 'block';
                toggleBtn.textContent = '‚ûñ';
            } else {
                missionText.style.display = 'none';
                toggleBtn.textContent = '‚ûï';
            }
        }

        // Configurar bot√≥n de objetivos
        document.addEventListener('click', (e) => {
            if (e.target.id === 'toggle-objectives') {
                toggleObjectives();
            }
        });

        function cycleCameraMode() {
            const modes = ['third', 'first', 'free'];
            const currentIndex = modes.indexOf(cameraMode);
            cameraMode = modes[(currentIndex + 1) % modes.length];

            // Resetear rotaci√≥n de c√°mara al cambiar modo para mejor experiencia
            if (isMobile) {
                cameraRotation = { x: 0, y: 0 };
            }

            const modeNames = {
                'third': '3¬™ Persona - Desliza para rotar c√°mara',
                'first': '1¬™ Persona - Desliza para mirar alrededor',
                'free': 'C√°mara Libre - WASD para mover, mouse para mirar'
            };

            // Inicializar posici√≥n de c√°mara libre
            if (cameraMode === 'free' && player) {
                freeCameraPosition.set(
                    player.position.x,
                    player.position.y + 8,
                    player.position.z + 12
                );
            }

            showNotification(`üì∑ ${modeNames[cameraMode]}`, 3000);

            // Mostrar hint adicional para m√≥vil
            if (isMobile) {
                setTimeout(() => {
                    showNotification('üí° Desliza fuera de los controles para rotar la c√°mara', 2000);
                }, 3500);
            }
        }

        function block() {
            if (inventory.shield > 0) {
                showNotification('Bloqueando...', 500);
            }
        }

        function updateInventoryUI() {
            const itemGrid = document.getElementById('item-grid');
            if (itemGrid) {
                itemGrid.innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #ff6b6b; cursor: pointer;">
                        <div style="font-size: 20px;">‚öîÔ∏è</div>
                        <div style="font-size: 10px;">Espada</div>
                        <div style="font-size: 12px; color: #ff6b6b;">Nv.${inventory.sword}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #4ecdc4; cursor: pointer;">
                        <div style="font-size: 20px;">üõ°Ô∏è</div>
                        <div style="font-size: 10px;">Escudo</div>
                        <div style="font-size: 12px; color: #4ecdc4;">Nv.${inventory.shield}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #ff9ff3; cursor: pointer;">
                        <div style="font-size: 20px;">üß™</div>
                        <div style="font-size: 10px;">Pociones</div>
                        <div style="font-size: 12px; color: #ff9ff3;">${inventory.potions}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #feca57; cursor: pointer;">
                        <div style="font-size: 20px;">üóùÔ∏è</div>
                        <div style="font-size: 10px;">Llaves</div>
                        <div style="font-size: 12px; color: #feca57;">${inventory.keys}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #ffd700; cursor: pointer;">
                        <div style="font-size: 20px;">ü™ô</div>
                        <div style="font-size: 10px;">Monedas</div>
                        <div style="font-size: 12px; color: #ffd700;">${inventory.coins}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; text-align: center; border: 2px solid #a55eea; cursor: pointer;">
                        <div style="font-size: 20px;">üîÆ</div>
                        <div style="font-size: 10px;">Artefactos</div>
                        <div style="font-size: 12px; color: #a55eea;">${inventory.artifacts}</div>
                    </div>
                `;
            }

            const stats = document.getElementById('player-stats');
            const hours = Math.floor(gameTime / 3600);
            const minutes = Math.floor((gameTime % 3600) / 60);
            if (stats) {
                stats.innerHTML = `
                    <div>üï∞Ô∏è ${hours}h ${minutes}m</div>
                    <div>üö∂ ${Math.floor(playerStats.totalDistance)}m</div>
                    <div>üöÄ ${playerStats.totalJumps}</div>
                    <div>‚öîÔ∏è ${playerStats.totalAttacks}</div>
                    <div>üéØ Nivel ${playerLevel}</div>
                    <div>‚ú® XP: ${playerXP}/${playerLevel * 100}</div>
                `;
            }
        }

        // Cerrar inventario
        document.addEventListener('click', (e) => {
            if (e.target.id === 'close-inventory') {
                document.getElementById('inventory').style.display = 'none';
            }
        });

        // Sistema de Di√°logos RPG
        function interactWithNearbyNPC() {
            villagers.forEach(villager => {
                const distance = player.position.distanceTo(villager.position);
                if (distance < 4) {
                    startDialogue(villager);
                }
            });
        }

        function startDialogue(npc) {
            currentDialogue = npc;
            const dialogueSystem = document.getElementById('dialogue-system');
            const portrait = document.getElementById('npc-portrait');
            const name = document.getElementById('npc-name');
            const text = document.getElementById('dialogue-text');
            const options = document.getElementById('dialogue-options');

            // Configurar NPC
            portrait.textContent = npc.userData.portrait || 'üë§';
            name.textContent = npc.userData.name || 'Aldeano';

            // Mostrar di√°logo actual
            const currentText = npc.userData.dialogue[npc.userData.currentDialogue];
            text.textContent = currentText;

            // Crear opciones
            options.innerHTML = '';
            const dialogueOptions = npc.userData.options || [
                { text: 'Continuar', action: 'next' },
                { text: 'Adi√≥s', action: 'close' }
            ];

            dialogueOptions.forEach(option => {
                const btn = document.createElement('button');
                btn.textContent = option.text;
                btn.style.cssText = 'padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;';
                btn.onclick = () => handleDialogueOption(option.action, npc);
                options.appendChild(btn);
            });

            dialogueSystem.style.display = 'block';
            gamePaused = true;
        }

        function handleDialogueOption(action, npc) {
            switch (action) {
                case 'next':
                    npc.userData.currentDialogue = (npc.userData.currentDialogue + 1) % npc.userData.dialogue.length;
                    startDialogue(npc);
                    break;
                case 'close':
                    closeDialogue();
                    break;
                case 'quest':
                    giveQuest(npc);
                    closeDialogue();
                    break;
                case 'shop':
                    openShop(npc);
                    closeDialogue();
                    break;
            }
        }

        function closeDialogue() {
            document.getElementById('dialogue-system').style.display = 'none';
            currentDialogue = null;
            gamePaused = false;
        }

        // Limpieza de memoria mejorada
        function cleanupMemory() {
            if (!scene || window.gc) {
                if (window.gc) window.gc();
                return;
            }

            // Limpiar objetos eliminados
            scene.traverse((object) => {
                if (object.geometry && object.userData.disposed) {
                    object.geometry.dispose();
                }
                if (object.material && object.userData.disposed) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
            });

            // Limpiar part√≠culas de clima si hay demasiadas
            if (weather.particleSystem && weather.particleSystem.geometry.attributes.position.array.length > 3000) {
                clearWeatherParticles();
                applyWeatherEffects(); // Recrear con menos part√≠culas
            }
        }

        // Auto-limpieza cada 30 segundos
        setInterval(cleanupMemory, 30000);

        function updateGraphics() {
            if (!renderer) return;

            switch (settings.shadows) {
                case 'off':
                    renderer.shadowMap.enabled = false;
                    break;
                case 'low':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    break;
                case 'high':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    break;
            }
        }

        function setupPerformanceOptimization() {
            setInterval(() => {
                if (stats.fps < 30 && settings.shadows !== 'off') {
                    settings.shadows = 'off';
                    updateGraphics();
                    showNotification('Optimizando rendimiento...', 2000);
                }
            }, 5000);
        }

        // Generar aldeanos
        function spawnVillagers() {
            for (let i = 0; i < 6; i++) {
                const villager = createVillager();
                villagers.push(villager);
                scene.add(villager);
            }
        }

        function createVillager() {
            const villager = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.6, 0.4),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            body.position.y = 0.8;
            villager.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xffcc99 })
            );
            head.position.y = 1.8;
            villager.add(head);

            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 60;
            villager.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );

            // Tipos de aldeanos con di√°logos √∫nicos
            const villagerTypes = [
                {
                    name: 'Anciano Sabio',
                    portrait: 'üßô‚Äç‚ôÇÔ∏è',
                    dialogue: [
                        '¬°Ah, el elegido ha llegado! Los cristales te esperan, joven h√©roe.',
                        'Los reinos elementales guardan secretos antiguos. ¬°Prep√°rate!',
                        'Recuerda: la magia fluye a trav√©s de ti. Usa tus habilidades sabiamente.'
                    ],
                    options: [
                        { text: 'Ens√©√±ame magia', action: 'quest' },
                        { text: 'Continuar', action: 'next' },
                        { text: 'Adi√≥s', action: 'close' }
                    ]
                },
                {
                    name: 'Mercader',
                    portrait: 'üë®‚Äçüíº',
                    dialogue: [
                        '¬°Bienvenido a mi tienda! Tengo los mejores art√≠culos del reino.',
                        'Las pociones y armas m√°gicas te ayudar√°n en tu aventura.',
                        '¬°Vuelve cuando tengas m√°s monedas!'
                    ],
                    options: [
                        { text: 'Ver tienda', action: 'shop' },
                        { text: 'Continuar', action: 'next' },
                        { text: 'Adi√≥s', action: 'close' }
                    ]
                },
                {
                    name: 'Guardia',
                    portrait: 'üíÇ',
                    dialogue: [
                        'Los enemigos se vuelven m√°s fuertes cada d√≠a. ¬°Ten cuidado!',
                        'He visto criaturas extra√±as cerca de los reinos elementales.',
                        'Tu valor nos da esperanza, h√©roe.'
                    ]
                }
            ];

            const type = villagerTypes[Math.floor(Math.random() * villagerTypes.length)];
            villager.userData = {
                type: 'villager',
                name: type.name,
                portrait: type.portrait,
                dialogue: type.dialogue,
                options: type.options,
                currentDialogue: 0
            };

            return villager;
        }

        // Generar jefes
        function spawnBosses() {
            const bossPositions = [[0, -120], [120, 0], [0, 120], [-120, 0]];

            bossPositions.forEach((pos, i) => {
                const boss = createBoss(pos[0], pos[1], i);
                bosses.push(boss);
                scene.add(boss);
            });
        }

        function createBoss(x, z, type) {
            const boss = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 1),
                new THREE.MeshLambertMaterial({ color: 0x330000 })
            );
            body.position.y = 2;
            body.castShadow = true;
            boss.add(body);

            const head = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.5, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x660000 })
            );
            head.position.y = 4.5;
            head.castShadow = true;
            boss.add(head);

            boss.position.set(x, 0, z);
            boss.userData = {
                type: 'boss',
                health: 200,
                maxHealth: 200,
                damage: 25,
                speed: 2,
                attackRange: 5,
                attackCooldown: 0,
                bossType: type
            };

            return boss;
        }

        // Bucle principal
        function animate() {
            requestAnimationFrame(animate);

            if (!gameActive || gamePaused) {
                renderer.render(scene, camera);
                return;
            }

            const delta = Math.min(clock.getDelta(), 0.033);
            gameTime += delta;

            updatePlayer(delta);
            updateEnemies(delta);
            updateVillagers(delta);
            updateBosses(delta);
            updateItems(delta);
            updateCrystals(delta);
            updateTreasureChests(delta);
            updateWeather(delta);
            updateDayNight(delta);
            updateMinimap();

            updateAchievements();
            updateStats();

            renderer.render(scene, camera);
        }

        function updateVillagers(delta) {
            villagers.forEach(villager => {
                const distance = player.position.distanceTo(villager.position);
                if (distance < 3 && !villager.userData.dialogueShown) {
                    const dialogue = villager.userData.dialogue[villager.userData.currentDialogue];
                    showNotification(dialogue, 2000);
                    villager.userData.currentDialogue = (villager.userData.currentDialogue + 1) % villager.userData.dialogue.length;
                    villager.userData.dialogueShown = true;
                    // Reset despu√©s de 3 segundos
                    setTimeout(() => {
                        villager.userData.dialogueShown = false;
                    }, 3000);
                }
            });
        }

        function updateBosses(delta) {
            bosses.forEach(boss => {
                const distance = player.position.distanceTo(boss.position);
                if (distance < 20) {
                    const direction = new THREE.Vector3()
                        .subVectors(player.position, boss.position)
                        .normalize();

                    boss.position.add(direction.multiplyScalar(boss.userData.speed * delta));
                    boss.lookAt(player.position);

                    if (distance < boss.userData.attackRange * weather.effects.visibility && boss.userData.attackCooldown <= 0) {
                        const damage = Math.floor(boss.userData.damage * weather.effects.damage);
                        playerHealth -= damage;
                        boss.userData.attackCooldown = 2;
                        updateUI();
                        showNotification(`¬°Jefe te ataca! -${damage} HP`, 1500);

                        if (playerHealth <= 0) {
                            gameOver();
                        }
                    }
                }

                if (boss.userData.attackCooldown > 0) {
                    boss.userData.attackCooldown -= delta;
                }
            });
        }

        function updateDayNight(delta) {
            if (!settings.dayNight) return;

            dayTime += delta * 0.1;
            if (dayTime > 1) dayTime = 0;

            const intensity = 0.3 + Math.sin(dayTime * Math.PI * 2) * 0.5;
            scene.children.forEach(child => {
                if (child.type === 'DirectionalLight') {
                    child.intensity = Math.max(0.2, intensity);
                }
            });
        }

        function updateMinimap() {
            if (!settings.minimap) return;

            const minimap = document.getElementById('minimap');
            if (!minimap) return;

            // Crear canvas para minimapa si no existe
            let canvas = minimap.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                minimap.appendChild(canvas);
            }

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 150);

            // Fondo
            ctx.fillStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.fillRect(0, 0, 150, 150);

            // Jugador (centro)
            ctx.fillStyle = 'blue';
            ctx.fillRect(72, 72, 6, 6);

            // Enemigos
            ctx.fillStyle = 'red';
            enemies.forEach(enemy => {
                const dx = enemy.position.x - player.position.x;
                const dz = enemy.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 3, 3);
                }
            });

            // Cristales
            ctx.fillStyle = 'yellow';
            crystals.forEach(crystal => {
                const dx = crystal.position.x - player.position.x;
                const dz = crystal.position.z - player.position.z;
                const x = 75 + dx * 0.5;
                const z = 75 + dz * 0.5;
                if (x > 0 && x < 150 && z > 0 && z < 150) {
                    ctx.fillRect(x, z, 4, 4);
                }
            });
        }



        // Sistemas adicionales - M√ÅS COFRES
        function spawnTreasureChests() {
            for (let i = 0; i < 20; i++) {
                const chest = new THREE.Group();

                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 1.5),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                box.position.y = 0.5;
                chest.add(box);

                const lid = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.2, 1.6),
                    new THREE.MeshLambertMaterial({ color: 0xA0522D })
                );
                lid.position.y = 1.1;
                chest.add(lid);

                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 80;
                chest.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );

                chest.userData = {
                    type: 'chest',
                    opened: false,
                    contents: {
                        coins: 100 + Math.floor(Math.random() * 200),
                        potions: 1 + Math.floor(Math.random() * 4),
                        artifacts: Math.random() > 0.5 ? 1 : 0,
                        weaponUpgrade: Math.random() > 0.8 ? 1 : 0
                    }
                };

                scene.add(chest);
                items.push(chest);
            }
        }

        function updateTreasureChests(delta) {
            items.forEach((item, index) => {
                if (item.userData.type === 'chest' && !item.userData.opened) {
                    const distance = player.position.distanceTo(item.position);
                    if (distance < 2) {
                        item.userData.opened = true;
                        const contents = item.userData.contents;

                        inventory.coins += contents.coins;
                        inventory.potions += contents.potions;
                        inventory.artifacts += contents.artifacts;
                        if (contents.weaponUpgrade) inventory.sword++;

                        score += contents.coins;
                        updateUI();
                        updateInventoryUI();

                        let message = `Cofre abierto!\n+${contents.coins} monedas\n+${contents.potions} pociones`;
                        if (contents.artifacts) message += `\n+${contents.artifacts} artefactos`;
                        if (contents.weaponUpgrade) message += `\n¬°Espada mejorada!`;
                        showNotification(message, 3000);

                        // Cambiar color del cofre
                        item.children[0].material.color.setHex(0x666666);

                        checkAchievement('treasure_hunter');
                    }
                }
            });
        }

        function initWeatherSystem() {
            weather.type = ['clear', 'rain', 'snow', 'fog'][Math.floor(Math.random() * 4)];
            weather.lastChange = 0;
            weather.effects = { speed: 1, visibility: 1, health: 1, damage: 1 };
            weather.extremeActive = false;
            weather.particles = [];
            weather.particleSystem = null;
            updateWeatherDisplay();
            applyWeatherEffects();
        }

        function updateWeather(delta) {
            // Cambio de clima m√°s realista cada 5-10 minutos
            const currentMinute = Math.floor(gameTime / 60);
            const timeSinceLastChange = currentMinute - weather.lastChange;

            if (timeSinceLastChange >= 5 && Math.random() < 0.1) { // 10% probabilidad cada minuto despu√©s de 5 min
                const weatherTypes = ['clear', 'rain', 'snow', 'fog'];
                let newWeather;

                // Transiciones m√°s realistas
                switch (weather.type) {
                    case 'clear':
                        newWeather = Math.random() < 0.4 ? 'fog' : (Math.random() < 0.7 ? 'rain' : 'snow');
                        break;
                    case 'rain':
                        newWeather = Math.random() < 0.6 ? 'clear' : 'fog';
                        break;
                    case 'snow':
                        newWeather = Math.random() < 0.5 ? 'clear' : 'fog';
                        break;
                    case 'fog':
                        newWeather = Math.random() < 0.5 ? 'clear' : 'rain';
                        break;
                }

                weather.type = newWeather;
                weather.lastChange = currentMinute;
                updateWeatherDisplay();
                applyWeatherEffects();
                showNotification(`üå§Ô∏è El clima ha cambiado a ${getWeatherName(weather.type)}`, 2000);
            }

            // Animar part√≠culas
            if (weather.particleSystem) {
                const positions = weather.particleSystem.geometry.attributes.position.array;

                for (let i = 1; i < positions.length; i += 3) {
                    if (weather.type === 'rain') {
                        positions[i] -= 50 * delta;
                        if (positions[i] < 0) positions[i] = 100;
                    } else if (weather.type === 'snow') {
                        positions[i] -= 10 * delta;
                        positions[i - 1] += Math.sin(Date.now() * 0.001 + i) * 0.1;
                        if (positions[i] < 0) {
                            positions[i] = 100;
                            positions[i - 1] = (Math.random() - 0.5) * 200;
                        }
                    }

                    // Animaci√≥n para eventos extremos
                    if (weather.extremeActive) {
                        positions[i] -= 80 * delta; // Ca√≠da m√°s r√°pida
                        positions[i - 1] += Math.sin(Date.now() * 0.005 + i) * 0.5; // M√°s movimiento
                        if (positions[i] < 0) {
                            positions[i] = 150;
                            positions[i - 1] = (Math.random() - 0.5) * 300;
                        }
                    }
                }

                weather.particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            // Efectos de clima en tiempo real
            if (weather.type === 'rain' && Math.random() < 0.01) {
                playerHealth = Math.max(1, playerHealth - 1);
                updateUI();
            }

            if (weather.type === 'snow' && Math.random() < 0.005) {
                config.playerSpeed = Math.max(2, config.playerSpeed * 0.99);
            }

            // Eventos clim√°ticos extremos (1% probabilidad cada minuto)
            if (Math.random() < 0.0003) {
                triggerExtremeWeather();
            }
        }

        function applyWeatherEffects() {
            clearWeatherParticles();

            switch (weather.type) {
                case 'rain':
                    weather.effects = { speed: 0.8, visibility: 0.7, health: 0.95, damage: 1.1 };
                    scene.fog.density = 0.015;
                    scene.background.setHex(0x555566);
                    config.playerSpeed = 6;
                    createRainParticles();
                    showNotification('üåßÔ∏è La lluvia reduce velocidad y visibilidad', 2000);
                    break;
                case 'snow':
                    weather.effects = { speed: 0.6, visibility: 0.8, health: 0.9, damage: 0.9 };
                    scene.fog.density = 0.012;
                    scene.background.setHex(0xccccdd);
                    config.playerSpeed = 5;
                    createSnowParticles();
                    changeTerrainColor(0xffffff);
                    showNotification('‚ùÑÔ∏è La nieve ralentiza movimiento', 2000);
                    break;
                case 'fog':
                    weather.effects = { speed: 0.9, visibility: 0.5, health: 1, damage: 0.8 };
                    scene.fog.density = 0.025;
                    scene.background.setHex(0x999999);
                    showNotification('üå´Ô∏è La niebla reduce visibilidad', 2000);
                    break;
                default: // clear
                    weather.effects = { speed: 1, visibility: 1, health: 1, damage: 1 };
                    scene.fog.density = 0.005;
                    scene.background.setHex(0x87CEEB);
                    config.playerSpeed = 8;
                    changeTerrainColor(0x4CAF50);
            }
        }

        function createRainParticles() {
            if (!weatherParticlesEnabled) return;

            const particleCount = isMobile ? 200 : 500;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = Math.random() * 100 + 50;
                positions[i + 2] = (Math.random() - 0.5) * 200;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x4444ff,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            weather.particleSystem = new THREE.Points(particles, material);
            scene.add(weather.particleSystem);
        }

        function createSnowParticles() {
            if (!weatherParticlesEnabled) return;

            const particleCount = isMobile ? 150 : 300;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = Math.random() * 100 + 50;
                positions[i + 2] = (Math.random() - 0.5) * 200;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                transparent: true,
                opacity: 0.8
            });

            weather.particleSystem = new THREE.Points(particles, material);
            scene.add(weather.particleSystem);
        }

        function clearWeatherParticles() {
            if (weather.particleSystem) {
                scene.remove(weather.particleSystem);
                weather.particleSystem.geometry.dispose();
                weather.particleSystem.material.dispose();
                weather.particleSystem = null;
            }
        }

        function changeTerrainColor(color) {
            scene.traverse((child) => {
                if (child.isMesh && child.geometry.type === 'PlaneGeometry') {
                    child.material.color.setHex(color);
                }
            });
        }

        function triggerExtremeWeather() {
            const extremeEvents = ['tormenta', 'ventisca', 'niebla_densa'];
            const event = extremeEvents[Math.floor(Math.random() * extremeEvents.length)];

            weather.extremeActive = true;

            switch (event) {
                case 'tormenta':
                    weather.effects.speed *= 0.5;
                    weather.effects.damage *= 1.5;
                    playerHealth = Math.max(1, playerHealth - 10);
                    scene.background.setHex(0x222244);
                    createLightningEffect();
                    showNotification('‚ö° ¬°TORMENTA EL√âCTRICA! -10 HP, -50% velocidad', 4000);
                    break;
                case 'ventisca':
                    weather.effects.speed *= 0.3;
                    weather.effects.visibility *= 0.3;
                    scene.background.setHex(0xaaaacc);
                    createBlizzardEffect();
                    showNotification('üå®Ô∏è ¬°VENTISCA! -70% velocidad y visibilidad', 4000);
                    break;
                case 'niebla_densa':
                    weather.effects.visibility *= 0.2;
                    config.attackRange *= 0.5;
                    scene.background.setHex(0x666666);
                    scene.fog.density = 0.05;
                    showNotification('üå´Ô∏è ¬°NIEBLA DENSA! -80% visibilidad, -50% rango ataque', 4000);
                    break;
            }

            updateUI();

            // Restaurar efectos normales despu√©s de 30 segundos
            setTimeout(() => {
                weather.extremeActive = false;
                applyWeatherEffects();
                config.attackRange = 4;
                showNotification('üå§Ô∏è El clima extremo ha pasado', 2000);
            }, 30000);
        }

        function createLightningEffect() {
            if (!weatherParticlesEnabled) return;

            clearWeatherParticles();

            // Crear lluvia intensa
            const particleCount = isMobile ? 300 : 800;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 300;
                positions[i + 1] = Math.random() * 150 + 50;
                positions[i + 2] = (Math.random() - 0.5) * 300;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x2222ff,
                size: 1,
                transparent: true,
                opacity: 0.8
            });

            weather.particleSystem = new THREE.Points(particles, material);
            scene.add(weather.particleSystem);

            // Efecto de rayo cada 3 segundos
            const lightningInterval = setInterval(() => {
                scene.background.setHex(0xffffff);
                setTimeout(() => scene.background.setHex(0x222244), 100);
            }, 3000);

            setTimeout(() => clearInterval(lightningInterval), 30000);
        }

        function createBlizzardEffect() {
            if (!weatherParticlesEnabled) return;

            clearWeatherParticles();

            // Crear nieve intensa
            const particleCount = isMobile ? 250 : 600;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 300;
                positions[i + 1] = Math.random() * 150 + 50;
                positions[i + 2] = (Math.random() - 0.5) * 300;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                transparent: true,
                opacity: 0.9
            });

            weather.particleSystem = new THREE.Points(particles, material);
            scene.add(weather.particleSystem);

            // Terreno completamente blanco
            changeTerrainColor(0xffffff);
        }

        function getWeatherName(type) {
            const names = {
                clear: 'Despejado ‚òÄÔ∏è',
                rain: 'Lluvia üåßÔ∏è',
                snow: 'Nieve ‚ùÑÔ∏è',
                fog: 'Niebla üå´Ô∏è'
            };
            return names[type] || 'Desconocido';
        }

        function updateWeatherDisplay() {
            const weatherInfo = {
                clear: { name: 'Despejado ‚òÄÔ∏è', effect: 'Condiciones normales' },
                rain: { name: 'Lluvia üåßÔ∏è', effect: '-20% velocidad, -5% salud/tiempo' },
                snow: { name: 'Nieve ‚ùÑÔ∏è', effect: '-40% velocidad, -10% salud/tiempo' },
                fog: { name: 'Niebla üå´Ô∏è', effect: '-50% visibilidad, -20% da√±o enemigo' }
            };
            const info = weatherInfo[weather.type];
            const weatherPanel = document.getElementById('weather-info');
            if (weatherPanel) {
                weatherPanel.innerHTML = `${info.name}<br><small>${info.effect}</small>`;
            }
        }

        function initAchievements() {
            const achievementDefs = {
                first_kill: { name: 'Primer Enemigo', desc: 'Derrota tu primer enemigo' },
                treasure_hunter: { name: 'Cazatesoros', desc: 'Abre tu primer cofre' },
                crystal_collector: { name: 'Coleccionista', desc: 'Encuentra tu primer cristal' },
                level_up: { name: 'Crecimiento', desc: 'Alcanza el nivel 2' },
                boss_slayer: { name: 'Matajefes', desc: 'Derrota tu primer jefe' },
                explorer: { name: 'Explorador', desc: 'Recorre 1000 metros' },
                jumper: { name: 'Saltar√≠n', desc: 'Realiza 100 saltos' },
                warrior: { name: 'Guerrero', desc: 'Realiza 50 ataques' },
                savior: { name: 'Salvador de Aethermoor', desc: 'Encuentra todos los cristales' }
            };

            window.achievementDefs = achievementDefs;
        }

        function checkAchievement(id) {
            if (achievements.includes(id)) return;

            let unlocked = false;

            switch (id) {
                case 'first_kill':
                    unlocked = kills >= 1;
                    break;
                case 'treasure_hunter':
                    unlocked = true; // Se llama cuando se abre un cofre
                    break;
                case 'crystal_collector':
                    unlocked = crystalsFound >= 1;
                    break;
                case 'level_up':
                    unlocked = playerLevel >= 2;
                    break;
                case 'boss_slayer':
                    unlocked = bosses.length < 4;
                    break;
                case 'explorer':
                    unlocked = playerStats.totalDistance >= 1000;
                    break;
                case 'jumper':
                    unlocked = playerStats.totalJumps >= 100;
                    break;
                case 'warrior':
                    unlocked = playerStats.totalAttacks >= 50;
                    break;
                case 'savior':
                    unlocked = crystalsFound >= 4;
                    break;
            }

            if (unlocked) {
                achievements.push(id);
                const def = window.achievementDefs[id];
                showNotification(`üèÜ LOGRO DESBLOQUEADO!\n${def.name}\n${def.desc}`, 4000);
                updateAchievementsUI();
            }
        }

        function updateAchievements() {
            checkAchievement('first_kill');
            checkAchievement('crystal_collector');
            checkAchievement('level_up');
            checkAchievement('boss_slayer');
            checkAchievement('explorer');
            checkAchievement('jumper');
            checkAchievement('warrior');
            checkAchievement('savior');
        }

        function updateAchievementsUI() {
            const list = document.getElementById('achievement-list');
            list.innerHTML = achievements.map(id => {
                const def = window.achievementDefs[id];
                return `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">üèÜ ${def.name}</div>`;
            }).join('');

            if (achievements.length > 0) {
                document.getElementById('achievements').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('achievements').style.display = 'none';
                }, 5000);
            }
        }

        // ARREGLADO: Funciones de fullscreen mejoradas
        function toggleFullscreen() {
            if (!isFullscreen()) {
                enterFullscreen();
            } else {
                exitFullscreen();
            }
        }

        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement);
        }

        function enterFullscreen() {
            // Solo intentar fullscreen si la pesta√±a tiene foco y el juego est√° activo
            if (!document.hasFocus() || !gameActive) return;

            const elem = document.documentElement;
            try {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen({ navigationUI: 'hide' }).catch(() => { });
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } catch (e) {
                // Silenciar errores de fullscreen
            }
        }

        function exitFullscreen() {
            try {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            } catch (e) {
                console.log('Exit fullscreen error:', e);
            }
        }

        function updateFullscreenButton() {
            const btn = document.getElementById('fullscreen-btn');
            if (!btn) return;

            const fullscreen = isFullscreen();
            btn.textContent = fullscreen ? 'Salir' : 'Activar';
            btn.style.background = fullscreen ? '#f44336' : '#4CAF50';
        }

        function toggleInspectorMode() {
            const isActive = localStorage.getItem('forceInspectorMode') === 'true';
            localStorage.setItem('forceInspectorMode', !isActive);
            updateInspectorButton();
            location.reload();
        }

        function updateInspectorButton() {
            const btn = document.getElementById('inspector-btn');
            if (!btn) return;

            const active = localStorage.getItem('forceInspectorMode') === 'true';
            btn.textContent = active ? 'Desactivar' : 'Activar';
            btn.style.background = active ? '#f44336' : '#FF5722';
        }

        function toggleDevControls() {
            const controls = document.getElementById('mobile-controls');
            const isVisible = controls.style.display !== 'none';

            controls.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                // Mostrar todos los controles m√≥viles en modo dev
                document.getElementById('mobile-attack').style.display = 'block';
                document.getElementById('mobile-jump').style.display = 'block';
                document.getElementById('mobile-potion').style.display = 'block';
                document.getElementById('mobile-inventory').style.display = 'block';
                document.getElementById('mobile-camera').style.display = 'block';
                document.getElementById('mobile-pause').style.display = 'block';
                setupMobileControls();
                showNotification('üéÆ Controles Android activados\nüñ±Ô∏è Usa mouse para testing', 3000);
            } else {
                // Ocultar botones en modo dev
                document.getElementById('mobile-attack').style.display = 'none';
                document.getElementById('mobile-jump').style.display = 'none';
                document.getElementById('mobile-potion').style.display = 'none';
                document.getElementById('mobile-inventory').style.display = 'none';
                document.getElementById('mobile-camera').style.display = 'none';
                document.getElementById('mobile-pause').style.display = 'none';
                showNotification('üéÆ Controles Android desactivados', 2000);
            }

            updateDevControlsButton();
        }

        function updateDevControlsButton() {
            const btn = document.getElementById('dev-controls-btn');
            if (!btn) return;

            const controls = document.getElementById('mobile-controls');
            const isVisible = controls.style.display !== 'none';

            btn.textContent = isVisible ? 'Ocultar' : 'Mostrar';
            btn.style.background = isVisible ? '#f44336' : '#FF5722';
        }

        // NUEVO: Mantener fullscreen activo en m√≥viles
        function maintainFullscreen() {
            if (!isMobile || !gameActive || !document.hasFocus()) return;

            if (!isFullscreen()) {
                enterFullscreen();
            }
        }



        // Cambiar dificultad
        function changeDifficulty(level) {
            settings.difficulty = level;
            switch (level) {
                case 'easy':
                    config.playerSpeed = 10;
                    if (player) playerHealth = Math.min(150, playerHealth + 50);
                    break;
                case 'hard':
                    config.playerSpeed = 6;
                    if (player) playerHealth = Math.max(50, playerHealth - 25);
                    break;
                default: // normal
                    config.playerSpeed = 8;
            }
            updateUI();
            showNotification(`Dificultad: ${level.toUpperCase()}`, 2000);
        }

        // Auto-guardar en slot actual
        function autoSave() {
            if (!settings.autoSave || !gameActive || currentSaveSlot === null) return;
            const saveData = {
                playerHealth, score, kills, crystalsFound, playerLevel, playerXP,
                inventory, achievements, gameTime, playerStats,
                position: player ? { x: player.position.x, y: player.position.y, z: player.position.z } : null,
                timestamp: Date.now()
            };
            localStorage.setItem(`pepequest_slot_${currentSaveSlot}`, JSON.stringify(saveData));
        }

        // Funci√≥n obsoleta - ahora se usa el sistema de slots
        function loadAutoSave() {
            return false;
        }

        // Sistema de slots de guardado
        function showSaveMenu() {
            updateSaveSlots();
            document.getElementById('save-menu').style.display = 'block';
        }

        function updateSaveSlots() {
            const container = document.getElementById('save-slots');
            container.innerHTML = '<h4>Partidas Guardadas:</h4>';

            for (let i = 0; i < 3; i++) {
                const saved = localStorage.getItem(`pepequest_slot_${i}`);
                const slotDiv = document.createElement('div');
                const isCurrentSlot = i === currentSaveSlot;
                slotDiv.style.cssText = `margin: 10px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 5px; ${isCurrentSlot ? 'border: 2px solid #4CAF50;' : ''}`;

                if (saved) {
                    const data = JSON.parse(saved);
                    const date = new Date(data.timestamp).toLocaleString();
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Nivel ${data.playerLevel || 1} ${isCurrentSlot ? '(Actual)' : ''}</div>
                        <div style="font-size: 12px; color: #ccc; margin: 5px 0;">${date}</div>
                        <div style="margin-top: 10px;">
                            <button onclick="loadSlot(${i})" style="margin: 5px; padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Cargar</button>
                            ${gameActive ? `<button onclick="saveSlot(${i})" style="margin: 5px; padding: 8px 15px; background: #2196F3; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Sobrescribir</button>` : ''}
                        </div>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div style="font-size: 16px;">Slot ${i + 1} - Vac√≠o</div>
                        ${gameActive ? `<button onclick="saveSlot(${i})" style="margin: 10px 5px 5px 0; padding: 8px 15px; background: #2196F3; color: white; border: none; border-radius: 3px; ${isMobile ? 'font-size: 16px;' : ''}">Guardar</button>` : ''}
                    `;
                }
                container.appendChild(slotDiv);
            }
        }

        function saveSlot(slot) {
            const saveData = {
                playerHealth, score, kills, crystalsFound, playerLevel, playerXP,
                inventory, achievements, gameTime, playerStats,
                position: player ? { x: player.position.x, y: player.position.y, z: player.position.z } : null,
                timestamp: Date.now()
            };
            localStorage.setItem(`pepequest_slot_${slot}`, JSON.stringify(saveData));
            showNotification(`Guardado en Slot ${slot + 1}`, 2000);
            updateSaveSlots();
        }

        function loadSlot(slot) {
            const saved = localStorage.getItem(`pepequest_slot_${slot}`);
            if (!saved) return;

            try {
                const data = JSON.parse(saved);
                currentSaveSlot = slot;
                playerHealth = data.playerHealth || 100;
                score = data.score || 0;
                kills = data.kills || 0;
                crystalsFound = data.crystalsFound || 0;
                playerLevel = data.playerLevel || 1;
                playerXP = data.playerXP || 0;
                inventory = data.inventory || inventory;
                achievements = data.achievements || [];
                gameTime = data.gameTime || 0;
                playerStats = data.playerStats || playerStats;

                if (!gameStarted) {
                    init();
                    gameStarted = true;
                    setTimeout(() => {
                        if (data.position && player) {
                            player.position.set(data.position.x, data.position.y, data.position.z);
                        }
                    }, 100);
                } else if (data.position && player) {
                    player.position.set(data.position.x, data.position.y, data.position.z);
                }

                gameActive = true;
                gamePaused = false;
                document.getElementById('main-menu').style.display = 'none';
                updateUI();
                updateInventoryUI();
                showNotification(`Cargado Slot ${slot + 1}`, 2000);
                document.getElementById('save-menu').style.display = 'none';
            } catch (e) {
                showNotification('Error al cargar', 2000);
            }
        }

        // Cerrar men√∫ de guardado
        document.getElementById('close-save').addEventListener('click', () => {
            document.getElementById('save-menu').style.display = 'none';
        });

        // Bot√≥n de guardado r√°pido para m√≥vil (se a√±ade despu√©s de detectar m√≥vil)
        function addMobileSaveButton() {
            if (!isMobile) return;
            const mobileControls = document.getElementById('mobile-controls');
            if (!mobileControls) return;

            const saveBtn = document.createElement('button');
            saveBtn.innerHTML = 'üíæ';
            saveBtn.style.cssText = 'position: absolute; right: -260px; bottom: 0; width: 50px; height: 50px; background: #673AB7; color: white; border: none; border-radius: 50%; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.1s;';
            saveBtn.addEventListener('touchstart', (e) => {
                if (gameActive) saveSlot(currentSaveSlot || 0);
                e.target.style.transform = 'scale(0.9)';
                e.preventDefault();
            });
            saveBtn.addEventListener('touchend', (e) => {
                e.target.style.transform = 'scale(1)';
            });
            mobileControls.appendChild(saveBtn);
        }

        // Auto-guardado cada 30 segundos
        setInterval(autoSave, 30000);

        // Funciones espec√≠ficas para Android
        function addAndroidQuickSettings() {
            const quickBtn = document.createElement('button');
            quickBtn.innerHTML = '‚öôÔ∏è';
            quickBtn.style.cssText = 'position: fixed; top: 80px; right: 20px; width: 50px; height: 50px; background: rgba(0,0,0,0.7); color: white; border: 2px solid white; border-radius: 50%; font-size: 20px; z-index: 102; display: none;';
            quickBtn.onclick = () => {
                const menu = document.getElementById('settings-menu');
                menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
            };
            document.body.appendChild(quickBtn);

            if (isMobile) quickBtn.style.display = 'block';
        }

        function setupAndroidGestures() {
            let swipeStartX = 0, swipeStartY = 0;

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    swipeStartX = e.touches[0].clientX;
                    swipeStartY = e.touches[0].clientY;
                }
            });

            document.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const deltaX = e.changedTouches[0].clientX - swipeStartX;
                    const deltaY = e.changedTouches[0].clientY - swipeStartY;

                    // Gesto hacia arriba con 2 dedos = inventario
                    if (deltaY < -100 && Math.abs(deltaX) < 50) {
                        toggleInventory();
                    }
                    // Gesto hacia abajo con 2 dedos = pausa
                    else if (deltaY > 100 && Math.abs(deltaX) < 50) {
                        togglePause();
                    }
                }
            });
        }

        function setupAndroidNotifications() {
            // Solicitar permisos de notificaci√≥n
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }

        function showAndroidNotification(title, message) {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>'
                });
            }
        }

        // Configuraciones espec√≠ficas por plataforma m√≥vil
        function setupIOSSpecific() {
            // Prevenir bounce en iOS
            document.body.style.overscrollBehavior = 'none';

            // Configurar viewport para iOS
            const viewport = document.querySelector('meta[name=viewport]');
            if (viewport) {
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            }

            // Configuraciones espec√≠ficas de iOS
            addMobileFeatures('iOS');
        }

        function setupWindowsPhoneSpecific() {
            // Configuraciones para Windows Phone
            document.body.style.msContentZooming = 'none';
            document.body.style.msTouchAction = 'manipulation';

            addMobileFeatures('Windows Phone');
        }

        function setupGenericMobileSpecific() {
            // Configuraciones para otros m√≥viles
            addMobileFeatures('Mobile');
        }

        // Mejoras universales para todos los m√≥viles
        function addMobileFeatures(platform = 'Mobile') {
            // Bot√≥n de ayuda r√°pida (universal)
            const helpBtn = document.createElement('button');
            helpBtn.innerHTML = '?';
            helpBtn.style.cssText = 'position: fixed; bottom: 20px; right: 80px; width: 50px; height: 50px; background: #2196F3; color: white; border: none; border-radius: 50%; font-size: 20px; z-index: 102; display: block;';
            helpBtn.onclick = () => {
                const helpText = platform === 'iOS' ?
                    'üì± Desliza para rotar c√°mara\nüëÜ 2 dedos arriba = Inventario\nüëá 2 dedos abajo = Pausa\nüçé Optimizado para iOS' :
                    platform === 'Windows Phone' ?
                        'üì± Desliza para rotar c√°mara\nüëÜ 2 dedos arriba = Inventario\nüëá 2 dedos abajo = Pausa\nü™ü Optimizado para Windows Phone' :
                        'üì± Desliza para rotar c√°mara\nüëÜ 2 dedos arriba = Inventario\nüëá 2 dedos abajo = Pausa';
                showNotification(helpText, 4000);
            };
            document.body.appendChild(helpBtn);

            // Modo de ahorro de bater√≠a (universal)
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    if (battery.level < 0.2) {
                        settings.shadows = 'off';
                        config.playerSpeed *= 0.8;
                        showNotification(`üîã Modo ahorro activado (${platform})`, 3000);
                    }
                }).catch(() => {
                    // Fallback si no hay API de bater√≠a
                    console.log('Battery API no disponible en', platform);
                });
            }

            // Configuraci√≥n de gestos (universal)
            setupMobileGestures();

            // Configuraci√≥n de notificaciones (universal)
            setupMobileNotifications();
        }

        // Renombrar funciones para ser universales
        function setupMobileGestures() {
            let swipeStartX = 0, swipeStartY = 0;

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    swipeStartX = e.touches[0].clientX;
                    swipeStartY = e.touches[0].clientY;
                }
            });

            document.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const deltaX = e.changedTouches[0].clientX - swipeStartX;
                    const deltaY = e.changedTouches[0].clientY - swipeStartY;

                    // Gesto hacia arriba con 2 dedos = inventario
                    if (deltaY < -100 && Math.abs(deltaX) < 50) {
                        toggleInventory();
                        if (navigator.vibrate && mobileSettings.hapticFeedback) navigator.vibrate(50);
                    }
                    // Gesto hacia abajo con 2 dedos = pausa
                    else if (deltaY > 100 && Math.abs(deltaX) < 50) {
                        togglePause();
                        if (navigator.vibrate && mobileSettings.hapticFeedback) navigator.vibrate(100);
                    }
                }
            });
        }

        function setupMobileNotifications() {
            // Solicitar permisos de notificaci√≥n (universal)
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }

        function showMobileNotification(title, message) {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>'
                });
            }
        }

        // Configurar paneles colapsables
        function setupCollapsiblePanels() {
            const toggleControls = document.getElementById('toggle-controls');
            const controlsContent = document.getElementById('controls-content');
            const toggleObjective = document.getElementById('toggle-objective');
            const missionContent = document.getElementById('mission-content');

            if (toggleControls) {
                toggleControls.addEventListener('click', () => {
                    if (controlsContent.style.display === 'none') {
                        controlsContent.style.display = 'block';
                        toggleControls.textContent = '‚ûñ';
                    } else {
                        controlsContent.style.display = 'none';
                        toggleControls.textContent = '‚ûï';
                    }
                });
            }

            // Panel de misi√≥n ahora es siempre visible y compacto

            // Auto-colapsar controles en m√≥viles despu√©s de 10 segundos
            if (isMobile && controlsContent && toggleControls) {
                setTimeout(() => {
                    controlsContent.style.display = 'none';
                    toggleControls.textContent = '‚ûï';
                }, 10000);
            }
        }

        // Funciones de advertencias y optimizaciones
        function setupPerformanceWarning() {
            const acceptBtn = document.getElementById('accept-warning');
            const mobileSettingsBtn = document.getElementById('mobile-settings');

            if (acceptBtn) acceptBtn.addEventListener('click', () => {
                document.getElementById('performance-warning').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
                performanceWarningShown = true;
            });

            if (mobileSettingsBtn) mobileSettingsBtn.addEventListener('click', () => {
                document.getElementById('performance-warning').style.display = 'none';
                document.getElementById('settings-menu').style.display = 'block';
                // Cambiar a tab m√≥vil
                document.querySelectorAll('.settings-tab').forEach(t => {
                    t.style.background = 'transparent';
                    t.style.color = 'rgba(255,255,255,0.7)';
                });
                document.querySelector('[data-tab="mobile"]').style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                document.querySelector('[data-tab="mobile"]').style.color = 'white';
                document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
                document.getElementById('tab-mobile').style.display = 'block';
            });
        }

        function detectDeviceRAM() {
            let ramGB = 'Desconocida';
            let ramStatus = 'unknown';
            let ramColor = '#999';
            let ramEmoji = 'üìä';
            let ramDetails = '';
            let detectionMethods = [];

            // M√©todo 1: API Device Memory (m√°s precisa)
            if (navigator.deviceMemory) {
                ramGB = navigator.deviceMemory;
                detectionMethods.push(`Device Memory API: ${ramGB}GB`);
            }

            // M√©todo 2: Estimaci√≥n avanzada por CPU + plataforma
            let estimatedRAM = 4; // Default
            if (navigator.hardwareConcurrency) {
                const cores = navigator.hardwareConcurrency;
                const platform = navigator.platform.toLowerCase();
                const ua = navigator.userAgent;

                // Estimaci√≥n m√°s precisa basada en CPU y plataforma
                if (platform.includes('win')) {
                    // Windows PC
                    if (cores <= 2) estimatedRAM = 4;
                    else if (cores <= 4) estimatedRAM = 8;
                    else if (cores <= 8) estimatedRAM = 16;
                    else estimatedRAM = 32;
                } else if (platform.includes('mac')) {
                    // Mac
                    if (cores <= 4) estimatedRAM = 8;
                    else if (cores <= 8) estimatedRAM = 16;
                    else estimatedRAM = 32;
                } else if (platform.includes('linux')) {
                    // Linux
                    if (cores <= 2) estimatedRAM = 4;
                    else if (cores <= 4) estimatedRAM = 8;
                    else if (cores <= 8) estimatedRAM = 16;
                    else estimatedRAM = 32;
                } else {
                    // M√≥vil/Tablet
                    if (cores <= 2) estimatedRAM = 2;
                    else if (cores <= 4) estimatedRAM = 4;
                    else if (cores <= 6) estimatedRAM = 6;
                    else estimatedRAM = 8;
                }

                detectionMethods.push(`CPU + Plataforma: ${estimatedRAM}GB (${cores} cores, ${platform})`);

                // Si no hay Device Memory API, usar estimaci√≥n
                if (!navigator.deviceMemory) {
                    ramGB = estimatedRAM;
                }
            }

            // M√©todo 3: An√°lisis de rendimiento (test r√°pido)
            const performanceRAM = estimateRAMByPerformance();
            if (performanceRAM) {
                detectionMethods.push(`Test de rendimiento: ${performanceRAM}GB`);
            }

            // M√©todo 4: Estimaci√≥n por User Agent
            const uaRAM = estimateRAMByUserAgent();
            if (uaRAM) {
                detectionMethods.push(`User Agent: ${uaRAM}GB`);
            }

            // L√≥gica de selecci√≥n inteligente
            if (navigator.deviceMemory) {
                // Si tenemos Device Memory API, es la m√°s confiable
                ramGB = navigator.deviceMemory;
                detectionMethods.push(`Valor final (Device Memory API): ${ramGB}GB`);
            } else {
                // Sin Device Memory API, usar promedio ponderado
                const estimates = [];
                if (estimatedRAM) estimates.push({ value: estimatedRAM, weight: 3 }); // CPU+Platform m√°s confiable
                if (uaRAM) estimates.push({ value: uaRAM, weight: 2 }); // User Agent moderadamente confiable
                if (performanceRAM && performanceRAM <= 8) estimates.push({ value: performanceRAM, weight: 1 }); // Performance test menos confiable

                if (estimates.length > 0) {
                    const weightedSum = estimates.reduce((sum, est) => sum + (est.value * est.weight), 0);
                    const totalWeight = estimates.reduce((sum, est) => sum + est.weight, 0);
                    ramGB = Math.round(weightedSum / totalWeight);
                    detectionMethods.push(`Valor final (promedio ponderado): ${ramGB}GB`);
                } else {
                    ramGB = 4; // Fallback conservador
                    detectionMethods.push(`Valor final (fallback): ${ramGB}GB`);
                }
            }

            // Determinar estado basado en RAM final
            if (typeof ramGB === 'number') {
                if (ramGB <= 2) {
                    ramStatus = 'low';
                    ramColor = '#f44336';
                    ramEmoji = 'üî¥';
                } else if (ramGB <= 4) {
                    ramStatus = 'medium';
                    ramColor = '#FF9800';
                    ramEmoji = 'üü°';
                } else if (ramGB <= 8) {
                    ramStatus = 'good';
                    ramColor = '#4CAF50';
                    ramEmoji = 'üü¢';
                } else {
                    ramStatus = 'excellent';
                    ramColor = '#2196F3';
                    ramEmoji = 'üîµ';
                }
            }

            ramDetails = detectionMethods.join(' | ');

            deviceRAM = {
                amount: ramGB,
                status: ramStatus,
                color: ramColor,
                emoji: ramEmoji,
                details: ramDetails,
                methods: detectionMethods
            };

            // Actualizar UI
            updateRAMDisplay();
        }

        function updateRAMDisplay() {
            const ramInfo = document.getElementById('ram-info');
            if (ramInfo && deviceRAM.amount) {
                const statusText = {
                    'low': 'Baja - Riesgo alto',
                    'medium': 'Media - Precauci√≥n',
                    'good': 'Buena - Estable',
                    'excellent': 'Excelente - √ìptima',
                    'unknown': 'Desconocida'
                };

                ramInfo.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.2em;">${deviceRAM.emoji}</span>
                        <div>
                            <div style="color: ${deviceRAM.color}; font-weight: bold;">${deviceRAM.amount}GB</div>
                            <div style="font-size: 10px; color: #999;">${statusText[deviceRAM.status]}</div>
                        </div>
                    </div>
                `;
            }

            // Mostrar detalles adicionales en zona m√≥vil
            const mobileRAMDetails = document.getElementById('mobile-ram-details');
            if (mobileRAMDetails && deviceRAM.details) {
                mobileRAMDetails.innerHTML = `
                    <div style="background: rgba(33,150,243,0.1); padding: 15px; border-radius: 10px; margin: 10px 0;">
                        <h4 style="color: #2196F3; margin: 0 0 10px 0;">üìä An√°lisis de RAM</h4>
                        <div style="font-size: 12px; line-height: 1.4;">
                            <div style="background: rgba(255,193,7,0.1); padding: 10px; border-radius: 5px; margin-bottom: 10px; border-left: 3px solid #FFC107;">
                                <p style="margin: 0; font-size: 11px; color: #FF8F00;"><strong>‚ö†Ô∏è LIMITACIONES:</strong></p>
                                <p style="margin: 5px 0 0 0; font-size: 10px;">Los navegadores limitan el acceso a RAM por privacidad. Solo Chrome/Edge exponen la RAM real via Device Memory API.</p>
                            </div>
                            <p><strong>M√©todos de detecci√≥n:</strong></p>
                            <ul style="margin: 5px 0; padding-left: 15px; font-size: 11px;">
                                ${deviceRAM.methods.map(method => `<li>${method}</li>`).join('')}
                            </ul>
                            <p><strong>Estado:</strong> <span style="color: ${deviceRAM.color};">${deviceRAM.emoji} ${deviceRAM.status.toUpperCase()}</span></p>
                            <p><strong>Recomendaci√≥n:</strong> ${getRAMRecommendation()}</p>
                        </div>
                    </div>
                `;
            }
        }

        function estimateRAMByPerformance() {
            try {
                const start = performance.now();

                // Test m√°s conservador de asignaci√≥n de memoria
                const testArrays = [];
                for (let i = 0; i < 5; i++) {
                    testArrays.push(new Array(50000).fill(i));
                }

                const end = performance.now();
                const time = end - start;

                // Limpiar
                testArrays.length = 0;

                // Estimaci√≥n m√°s conservadora basada en tiempo
                if (time < 5) return 8;   // Muy r√°pido = RAM buena
                if (time < 15) return 6;  // R√°pido = RAM decente
                if (time < 30) return 4;  // Normal = RAM media
                if (time < 60) return 2;  // Lento = RAM baja
                return 1; // Muy lento = RAM muy baja
            } catch (e) {
                return null;
            }
        }

        function estimateRAMByUserAgent() {
            const ua = navigator.userAgent;

            // Dispositivos Android
            if (/Android/i.test(ua)) {
                if (/Android [2-4]\./i.test(ua)) return 1;
                if (/Android [5-6]\./i.test(ua)) return 2;
                if (/Android [7-8]\./i.test(ua)) return 3;
                if (/Android [9]\./i.test(ua)) return 4;
                if (/Android 1[0-9]/i.test(ua)) return 6;
                return 4;
            }

            // Dispositivos iOS
            if (/iPhone|iPad/i.test(ua)) {
                if (/OS [8-9]_/i.test(ua)) return 1;
                if (/OS 1[0-2]_/i.test(ua)) return 2;
                if (/OS 1[3-4]_/i.test(ua)) return 3;
                if (/OS 1[5-9]_/i.test(ua)) return 4;
                return 4;
            }

            // Escritorio (Windows/Mac/Linux)
            if (/Windows|Macintosh|Linux/i.test(ua)) {
                return 8;
            }

            return null;
        }

        function getRAMRecommendation() {
            switch (deviceRAM.status) {
                case 'low':
                    return 'Activar modo ultra bajo, desactivar part√≠culas, sesiones de 10-15 min';
                case 'medium':
                    return 'Desactivar part√≠culas de clima, sesiones de 15-20 min';
                case 'good':
                    return 'Configuraci√≥n normal, monitorear temperatura';
                case 'excellent':
                    return 'Todas las funciones disponibles, rendimiento √≥ptimo';
                default:
                    return 'Usar configuraci√≥n conservadora por precauci√≥n';
            }
        }

        function detectDeviceInfo() {
            const deviceInfo = {
                platform: navigator.platform || 'Desconocida',
                cores: navigator.hardwareConcurrency || 'Desconocido',
                connection: navigator.connection ? navigator.connection.effectiveType : 'Desconocida',
                gpu: getGPUInfo(),
                screen: `${screen.width}x${screen.height}`,
                pixelRatio: window.devicePixelRatio || 1
            };

            // Actualizar informaci√≥n en zona m√≥vil
            const deviceDetails = document.getElementById('device-details');
            if (deviceDetails) {
                deviceDetails.innerHTML = `
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 10px; margin: 10px 0;">
                        <h4 style="color: #4CAF50; margin: 0 0 10px 0;">üì± Informaci√≥n del Dispositivo</h4>
                        <div style="font-size: 11px; line-height: 1.3; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div><strong>Plataforma:</strong><br>${deviceInfo.platform}</div>
                            <div><strong>CPU N√∫cleos:</strong><br>${deviceInfo.cores}</div>
                            <div><strong>Resoluci√≥n:</strong><br>${deviceInfo.screen}</div>
                            <div><strong>Pixel Ratio:</strong><br>${deviceInfo.pixelRatio}x</div>
                            <div><strong>Conexi√≥n:</strong><br>${deviceInfo.connection}</div>
                            <div><strong>GPU:</strong><br>${deviceInfo.gpu}</div>
                        </div>
                    </div>
                `;
            }
        }

        function getGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    // M√©todo moderno: usar RENDERER directamente
                    try {
                        const renderer = gl.getParameter(gl.RENDERER);
                        if (renderer && renderer !== 'WebKit WebGL') {
                            return renderer.substring(0, 25) + '...';
                        }
                    } catch (e) {
                        // Fallback silencioso
                    }

                    // Informaci√≥n b√°sica de WebGL
                    const version = gl.getParameter(gl.VERSION);
                    const vendor = gl.getParameter(gl.VENDOR);

                    if (version && version.includes('WebGL')) {
                        return `WebGL ${version.includes('2.0') ? '2.0' : '1.0'}`;
                    }

                    return 'WebGL Disponible';
                }
                return 'No WebGL';
            } catch (e) {
                return 'Desconocida';
            }
        }

        function applyAutoOptimizations() {
            if (!deviceRAM.status) return;

            let optimizationsApplied = [];

            switch (deviceRAM.status) {
                case 'low':
                    // RAM baja: optimizaciones agresivas
                    settings.shadows = 'off';
                    weatherParticlesEnabled = false;
                    config.worldSize = 100;
                    config.playerSpeed *= 0.8;
                    optimizationsApplied = [
                        'Sombras desactivadas',
                        'Part√≠culas desactivadas',
                        'Mundo reducido 50%',
                        'Velocidad reducida 20%'
                    ];
                    break;

                case 'medium':
                    // RAM media: optimizaciones moderadas
                    settings.shadows = 'low';
                    weatherParticlesEnabled = false;
                    config.worldSize = 200;
                    optimizationsApplied = [
                        'Sombras en calidad baja',
                        'Part√≠culas desactivadas',
                        'Mundo reducido 25%'
                    ];
                    break;

                case 'good':
                    // RAM buena: optimizaciones m√≠nimas
                    settings.shadows = 'low';
                    optimizationsApplied = [
                        'Sombras en calidad baja'
                    ];
                    break;

                case 'excellent':
                    // RAM excelente: sin optimizaciones
                    optimizationsApplied = [
                        'Sin optimizaciones necesarias'
                    ];
                    break;
            }

            // Mostrar optimizaciones aplicadas
            if (optimizationsApplied.length > 0) {
                const autoOptInfo = document.getElementById('auto-opt-info');
                if (autoOptInfo) {
                    const color = deviceRAM.status === 'low' ? '#f44336' :
                        deviceRAM.status === 'medium' ? '#FF9800' : '#4CAF50';

                    autoOptInfo.innerHTML = `
                        <div style="background: rgba(255,152,0,0.1); padding: 15px; border-radius: 10px; margin: 10px 0; border-left: 4px solid ${color};">
                            <h4 style="color: ${color}; margin: 0 0 10px 0;">‚ö° Optimizaciones Autom√°ticas</h4>
                            <div style="font-size: 12px; line-height: 1.4;">
                                <p style="margin: 0 0 8px 0;"><strong>Aplicadas para ${deviceRAM.amount}GB RAM:</strong></p>
                                <ul style="margin: 0; padding-left: 15px;">
                                    ${optimizationsApplied.map(opt => `<li>${opt}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                }
            }
        }

        function showMobileZone() {
            const mobileZone = document.getElementById('mobile-zone');
            const content = document.getElementById('mobile-zone-content');

            if (isMobile) {
                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #4CAF50;">‚úÖ ACCESO CONCEDIDO</h3>
                        <p>Dispositivo m√≥vil detectado</p>
                        <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 10px; margin: 15px 0;">
                            <h4>üéÆ FUNCIONES EXCLUSIVAS M√ìVIL:</h4>
                            <ul style="text-align: left; margin: 10px 0;">
                                <li>üïπÔ∏è Controles t√°ctiles optimizados</li>
                                <li>üîã Modo ahorro de bater√≠a</li>
                                <li>üå°Ô∏è Monitor de temperatura</li>
                                <li>‚öôÔ∏è Optimizaciones autom√°ticas</li>
                                <li>üì± Gestos especiales (2 dedos)</li>
                                <li>üîî Notificaciones nativas</li>
                            </ul>
                        </div>
                        <p style="color: #FF9800;">RAM detectada: ${deviceRAM.amount}GB</p>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 4em; margin-bottom: 20px;">üîí</div>
                        <h3 style="color: #f44336;">‚ùå ACCESO DENEGADO</h3>
                        <p>Esta secci√≥n es exclusiva para dispositivos m√≥viles</p>
                        <div style="background: rgba(244,67,54,0.1); padding: 15px; border-radius: 10px; margin: 15px 0;">
                            <p>üíª Detectado: Dispositivo de escritorio</p>
                            <p>üì± Requerido: Tel√©fono o tablet</p>
                        </div>
                        <p style="color: #999; font-size: 14px;">Usa el modo inspector en Configuraci√≥n > Dev para simular m√≥vil</p>
                    </div>
                `;
            }

            mobileZone.style.display = 'flex';
        }

        function setupMobileOptimizations() {
            // Bot√≥n cerrar zona m√≥vil
            document.getElementById('close-mobile-zone').addEventListener('click', () => {
                document.getElementById('mobile-zone').style.display = 'none';
            });

            // Configuraciones de part√≠culas
            const weatherParticlesCheck = document.getElementById('weather-particles');
            if (weatherParticlesCheck) {
                weatherParticlesCheck.addEventListener('change', (e) => {
                    weatherParticlesEnabled = e.target.checked;
                    if (!weatherParticlesEnabled) {
                        clearWeatherParticles();
                    } else {
                        applyWeatherEffects();
                    }
                });
            }

            // Botones de optimizaci√≥n m√≥vil
            const batterySaverBtn = document.getElementById('battery-saver-btn');
            const disableParticlesBtn = document.getElementById('disable-particles-btn');
            const ultraLowBtn = document.getElementById('ultra-low-btn');

            if (batterySaverBtn) batterySaverBtn.addEventListener('click', activateBatterySaver);
            if (disableParticlesBtn) disableParticlesBtn.addEventListener('click', disableAllParticles);
            if (ultraLowBtn) ultraLowBtn.addEventListener('click', activateUltraLowMode);

            // Monitor de temperatura (simulado)
            if (isMobile) {
                setInterval(updateTemperatureMonitor, 10000);
            }
        }

        function activateBatterySaver() {
            settings.shadows = 'off';
            weatherParticlesEnabled = false;
            config.playerSpeed *= 0.8;
            document.getElementById('weather-particles').checked = false;
            document.getElementById('shadow-quality').value = 'off';
            clearWeatherParticles();
            updateGraphics();
            showNotification('üîã Modo ahorro de bater√≠a activado', 3000);
        }

        function disableAllParticles() {
            weatherParticlesEnabled = false;
            document.getElementById('weather-particles').checked = false;
            clearWeatherParticles();
            showNotification('‚ùÑÔ∏è Todas las part√≠culas desactivadas', 2000);
        }

        function activateUltraLowMode() {
            settings.shadows = 'off';
            weatherParticlesEnabled = false;
            config.worldSize = 150;
            config.playerSpeed *= 0.7;
            document.getElementById('weather-particles').checked = false;
            document.getElementById('shadow-quality').value = 'off';
            clearWeatherParticles();
            updateGraphics();
            showNotification('üåÜ Modo ultra bajo activado - M√°ximo rendimiento', 4000);
        }

        function updateTemperatureMonitor() {
            const monitor = document.getElementById('temp-monitor');
            if (!monitor) return;

            // Simulaci√≥n basada en FPS y tiempo de juego
            const fps = stats.fps || 60;
            const gameMinutes = gameTime / 60;

            let status, color, emoji;

            if (fps > 45 && gameMinutes < 10) {
                status = 'Normal';
                color = '#4CAF50';
                emoji = 'üü¢';
            } else if (fps > 30 && gameMinutes < 20) {
                status = 'Tibio';
                color = '#FF9800';
                emoji = 'üü°';
            } else {
                status = 'Caliente';
                color = '#f44336';
                emoji = 'üî¥';

                if (gameMinutes > 25) {
                    showNotification('üî• ADVERTENCIA: Dispositivo caliente\nToma un descanso de 5 minutos', 5000);
                }
            }

            monitor.innerHTML = `${status} ${emoji}`;
            monitor.style.color = color;
        }

        // Sistema de Habilidades
        function initSkills() {
            const skillsPanel = document.getElementById('skills-panel');
            const skillSlots = document.getElementById('skill-slots');

            const skills = [
                { id: 'fireball', icon: 'üî•', key: '1' },
                { id: 'heal', icon: '‚ù§Ô∏è', key: '2' },
                { id: 'shield', icon: 'üõ°Ô∏è', key: '3' },
                { id: 'teleport', icon: '‚ö°', key: '4' }
            ];

            skills.forEach(skill => {
                const slot = document.createElement('div');
                slot.style.cssText = 'width: 60px; height: 60px; background: rgba(255,255,255,0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center; margin-bottom: 5px; cursor: pointer; border: 2px solid transparent;';
                slot.innerHTML = `<div style="text-align: center;"><div style="font-size: 20px;">${skill.icon}</div><div style="font-size: 10px;">${skill.key}</div></div>`;
                slot.onclick = () => useSkill(skill.id);
                skillSlots.appendChild(slot);
            });

            if (gameActive) skillsPanel.style.display = 'block';
        }

        function useSkill(skillId) {
            if (skillCooldowns[skillId] > 0) {
                showNotification(`Habilidad en recarga: ${Math.ceil(skillCooldowns[skillId])}s`, 1000);
                return;
            }

            if (playerSkills[skillId] === 0) {
                showNotification('Habilidad no desbloqueada', 1000);
                return;
            }

            switch (skillId) {
                case 'fireball':
                    castFireball();
                    skillCooldowns.fireball = 5;
                    break;
                case 'heal':
                    castHeal();
                    skillCooldowns.heal = 10;
                    break;
                case 'shield':
                    castShield();
                    skillCooldowns.shield = 15;
                    break;
                case 'teleport':
                    castTeleport();
                    skillCooldowns.teleport = 8;
                    break;
            }

            // Vibrar en m√≥vil
            if (isMobile && navigator.vibrate) navigator.vibrate(100);
        }

        function castFireball() {
            // Crear proyectil de fuego
            const fireball = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0xff4444, emissive: 0x440000 })
            );
            fireball.position.copy(player.position);
            fireball.position.y += 1.5;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(player.quaternion);

            fireball.userData = {
                velocity: direction.multiplyScalar(20),
                damage: 50,
                lifetime: 3
            };

            scene.add(fireball);
            particles.push(fireball);
            showNotification('üî• Bola de fuego lanzada!', 1000);
        }

        function castHeal() {
            const healAmount = 30 + (playerSkills.heal * 10);
            playerHealth = Math.min(100, playerHealth + healAmount);
            updateUI();
            showNotification(`‚ù§Ô∏è +${healAmount} HP`, 2000);
        }

        function castShield() {
            player.userData.shielded = true;
            player.userData.shieldTime = 5 + playerSkills.shield;
            showNotification('üõ°Ô∏è Escudo activado!', 2000);
        }

        function castTeleport() {
            const direction = new THREE.Vector3(0, 0, -10);
            direction.applyQuaternion(player.quaternion);
            player.position.add(direction);
            showNotification('‚ö° Teletransporte!', 1000);
        }

        // Sistema de Progreso y Desbloqueos
        function checkUnlocks() {
            // Desbloquear habilidades por nivel
            if (playerLevel >= 3 && playerSkills.fireball === 0) {
                playerSkills.fireball = 1;
                showNotification('üéÜ NUEVA HABILIDAD: Bola de Fuego desbloqueada!', 4000);
            }
            if (playerLevel >= 5 && playerSkills.heal === 0) {
                playerSkills.heal = 1;
                showNotification('üéÜ NUEVA HABILIDAD: Curaci√≥n desbloqueada!', 4000);
            }
            if (playerLevel >= 7 && playerSkills.shield === 0) {
                playerSkills.shield = 1;
                showNotification('üéÜ NUEVA HABILIDAD: Escudo desbloqueado!', 4000);
            }
            if (playerLevel >= 10 && playerSkills.teleport === 0) {
                playerSkills.teleport = 1;
                showNotification('üéÜ NUEVA HABILIDAD: Teletransporte desbloqueado!', 4000);
            }

            // Desbloquear √°reas
            if (crystalsFound >= 2 && !unlockedContent.areas.includes('fire')) {
                unlockedContent.areas.push('fire');
                showNotification('üéÜ NUEVA √ÅREA: Reino del Fuego desbloqueado!', 4000);
            }
        }

        // Auto-guardado inteligente
        function smartAutoSave() {
            if (!settings.autoSave || !gameActive) return;

            // Solo auto-guardar en momentos importantes
            const shouldSave =
                playerStats.totalDistance % 500 < 10 || // Cada 500m
                kills % 5 === 0 || // Cada 5 enemigos
                crystalsFound > (JSON.parse(localStorage.getItem(`pepequest_slot_${currentSaveSlot}`))?.crystalsFound || 0);

            if (shouldSave) {
                autoSave();
                if (isMobile) {
                    showNotification('üíæ Progreso guardado', 1000);
                }
            }
        }

        // Inicializar cuando la p√°gina cargue
        window.addEventListener('load', () => {
            setupMenus();
            detectMobile();
            addMobileSaveButton();
            setupCollapsiblePanels();
            initSkills();
            loadLeaderboard();

            // Verificar fullscreen cada 5 segundos en m√≥viles (menos frecuente)
            if (isMobile) {
                setInterval(maintainFullscreen, 5000);
                // Optimizaciones m√≥viles adicionales
                setupAdvancedMobileOptimizations();
            }

            // Manejar cambios de foco de pesta√±a
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    smartAutoSave(); // Guardar al cambiar de pesta√±a
                    return;
                } else if (isMobile && gameActive) {
                    setTimeout(enterFullscreen, 1000);
                }
            });

            // Auto-guardado inteligente cada 30 segundos
            setInterval(smartAutoSave, 30000);

            // Actualizar bot√≥n inspector
            updateInspectorButton();
            updateDevControlsButton();

            // Mostrar indicador de modo inspector
            if (localStorage.getItem('forceInspectorMode') === 'true' && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) {
                showNotification('üîç MODO INSPECTOR ACTIVO\nControles m√≥viles habilitados para testing', 4000);
            }
        });

        // Optimizaciones m√≥viles avanzadas
        function setupAdvancedMobileOptimizations() {
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 1) e.preventDefault();
            }, { passive: false });

            if (screen.orientation) {
                screen.orientation.lock('landscape-primary').catch(() => { });
            }

            if (navigator.vibrate) {
                const originalAttack = attack;
                window.attack = function () {
                    navigator.vibrate([50, 10, 50]);
                    return originalAttack.apply(this, arguments);
                };
            }
        }

        // Sistema de Tabla de Puntuaciones
        function loadLeaderboard() {
            const saved = localStorage.getItem('pepequest_leaderboard');
            leaderboard = saved ? JSON.parse(saved) : [];
        }

        function saveToLeaderboard(finalScore) {
            const entry = {
                score: finalScore,
                level: playerLevel,
                crystals: crystalsFound,
                kills: kills,
                time: Math.floor(gameTime / 60),
                date: new Date().toLocaleDateString(),
                device: isMobile ? 'M√≥vil' : 'PC'
            };

            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10);

            localStorage.setItem('pepequest_leaderboard', JSON.stringify(leaderboard));
        }

        function updateSkillCooldowns(delta) {
            Object.keys(skillCooldowns).forEach(skill => {
                if (skillCooldowns[skill] > 0) {
                    skillCooldowns[skill] = Math.max(0, skillCooldowns[skill] - delta);
                }
            });
        }

        function updateProjectiles(delta) {
            particles.forEach((projectile, index) => {
                if (projectile.userData.velocity) {
                    projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(delta));
                    projectile.userData.lifetime -= delta;

                    enemies.forEach((enemy, enemyIndex) => {
                        const distance = projectile.position.distanceTo(enemy.position);
                        if (distance < 2) {
                            enemy.userData.health -= projectile.userData.damage;
                            scene.remove(projectile);
                            particles.splice(index, 1);

                            if (enemy.userData.health <= 0) {
                                scene.remove(enemy);
                                enemies.splice(enemyIndex, 1);
                                score += enemy.userData.scoreReward;
                                kills++;
                                updateUI();
                            }
                        }
                    });

                    if (projectile.userData.lifetime <= 0) {
                        scene.remove(projectile);
                        particles.splice(index, 1);
                    }
                }
            });
        }

        // Controles de teclado para habilidades
        document.addEventListener('keydown', (e) => {
            if (!gameActive || gamePaused) return;

            switch (e.code) {
                case 'Digit1': useSkill('fireball'); break;
                case 'Digit2': useSkill('heal'); break;
                case 'Digit3': useSkill('shield'); break;
                case 'Digit4': useSkill('teleport'); break;
                case 'KeyL':
                    const saved = localStorage.getItem('pepequest_leaderboard');
                    if (saved) {
                        leaderboard = JSON.parse(saved);
                        const content = document.getElementById('leaderboard-content');
                        content.innerHTML = leaderboard.slice(0, 5).map((entry, index) => `
                            <div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 2px 0; border-radius: 3px; font-size: 11px;">
                                #${index + 1} - ${entry.score} pts (Nv.${entry.level})
                            </div>
                        `).join('') || '<p>Sin puntuaciones</p>';
                        document.getElementById('leaderboard').style.display = 'block';
                    }
                    break;
            }
        });
    </script>
</body>

</html>